Description: Add rtmidi 2.0.1 source code.
Author: Jof Thibaut <tangostudio@tuxfamily.org>

--- /dev/null
+++ giada-0.7.2/src/rtmidi/Makefile.in
@@ -0,0 +1,55 @@
+### Do not edit -- Generated by 'configure --with-whatever' from Makefile.in
+### RtMidi library Makefile
+
+RM = /bin/rm
+LN = /bin/ln
+
+OBJECTS	= RtMidi.o
+
+SHARED = @sharedlib@
+RELEASE = 2.0.1
+MAJOR = 1
+LIBRARIES = $(SHARED)
+
+CC       = @CXX@
+AR       = @AR@
+RANLIB   = @RANLIB@
+
+DEFS     = @CPPFLAGS@
+CFLAGS   += @CXXFLAGS@ -Iinclude -fPIC
+
+all : $(LIBRARIES)
+
+check:
+	cd tests && $(MAKE) all
+
+$(LIBRARIES): $(OBJECTS)
+	$(CC) -fPIC @libflags@ $(OBJECTS) @LIBS@
+	$(LN) -s @sharedname@.$(RELEASE) $(SHARED)
+	$(LN) -s @sharedname@.$(RELEASE) $(SHARED).$(MAJOR)
+
+#	$(CC) -shared $(OBJECTS) -o $(SHARED) @LIBS@
+
+%.o : %.cpp
+	$(CC) $(CFLAGS) $(DEFS) -c $(<) -o $@
+
+%.o : include/%.cpp
+	$(CC) $(CFLAGS) $(DEFS) -c $(<) -o $@
+
+clean : 
+	$(RM) -f $(LIBRARIES) @sharedname@ $(SHARED)*
+	$(RM) -f $(OBJECTS)
+	$(RM) -f *~
+	cd tests && $(MAKE) clean
+
+distclean:
+	$(RM) -f $(LIBRARIES) @sharedname@ $(SHARED)*
+	$(RM) -f $(OBJECTS)
+	$(RM) -f *~
+	$(RM) -rf config.log config.status autom4te.cache Makefile rtmidi-config
+	cd tests && $(MAKE) distclean
+
+strip : 
+	strip $(LIBRARIES)
+	ranlib $(LIBRARIES)
+	cd tests && $(MAKE) strip
--- /dev/null
+++ giada-0.7.2/src/rtmidi/RtMidi.h
@@ -0,0 +1,685 @@
+/**********************************************************************/
+/*! \class RtMidi
+    \brief An abstract base class for realtime MIDI input/output.
+
+    This class implements some common functionality for the realtime
+    MIDI input/output subclasses RtMidiIn and RtMidiOut.
+
+    RtMidi WWW site: http://music.mcgill.ca/~gary/rtmidi/
+
+    RtMidi: realtime MIDI i/o C++ classes
+    Copyright (c) 2003-2012 Gary P. Scavone
+
+    Permission is hereby granted, free of charge, to any person
+    obtaining a copy of this software and associated documentation files
+    (the "Software"), to deal in the Software without restriction,
+    including without limitation the rights to use, copy, modify, merge,
+    publish, distribute, sublicense, and/or sell copies of the Software,
+    and to permit persons to whom the Software is furnished to do so,
+    subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be
+    included in all copies or substantial portions of the Software.
+
+    Any person wishing to distribute modifications to the Software is
+    asked to send the modifications to the original developer so that
+    they can be incorporated into the canonical version.  This is,
+    however, not a binding provision of this license.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+/**********************************************************************/
+
+/*!
+  \file RtMidi.h
+ */
+
+// RtMidi: Version 2.0.1
+
+#ifndef RTMIDI_H
+#define RTMIDI_H
+
+#if defined _WIN32 || defined __CYGWIN__
+  #define RTMIDI_DLL_PUBLIC
+#else
+  #if __GNUC__ >= 4
+    #define RTMIDI_DLL_PUBLIC __attribute__( (visibility( "default" )) )
+  #else
+    #define RTMIDI_DLL_PUBLIC
+  #endif
+#endif
+
+#include "RtError.h"
+#include <string>
+#include <vector>
+
+class RtMidi
+{
+ public:
+
+  //! MIDI API specifier arguments.
+  enum Api {
+    UNSPECIFIED,    /*!< Search for a working compiled API. */
+    MACOSX_CORE,    /*!< Macintosh OS-X Core Midi API. */
+    LINUX_ALSA,     /*!< The Advanced Linux Sound Architecture API. */
+    UNIX_JACK,      /*!< The Jack Low-Latency MIDI Server API. */
+    WINDOWS_MM,     /*!< The Microsoft Multimedia MIDI API. */
+    WINDOWS_KS,     /*!< The Microsoft Kernel Streaming MIDI API. */
+    RTMIDI_DUMMY    /*!< A compilable but non-functional API. */
+  };
+
+  //! A static function to determine the available compiled MIDI APIs.
+  /*!
+    The values returned in the std::vector can be compared against
+    the enumerated list values.  Note that there can be more than one
+    API compiled for certain operating systems.
+  */
+  static void getCompiledApi( std::vector<RtMidi::Api> &apis ) throw();
+
+  //! Pure virtual openPort() function.
+  virtual void openPort( unsigned int portNumber = 0, const std::string portName = std::string( "RtMidi" ) ) = 0;
+
+  //! Pure virtual openVirtualPort() function.
+  virtual void openVirtualPort( const std::string portName = std::string( "RtMidi" ) ) = 0;
+
+  //! Pure virtual getPortCount() function.
+  virtual unsigned int getPortCount() = 0;
+
+  //! Pure virtual getPortName() function.
+  virtual std::string getPortName( unsigned int portNumber = 0 ) = 0;
+
+  //! Pure virtual closePort() function.
+  virtual void closePort( void ) = 0;
+
+  //! A basic error reporting function for RtMidi classes.
+  static void error( RtError::Type type, std::string errorString );
+
+ protected:
+
+  RtMidi() {};
+  virtual ~RtMidi() {};
+};
+
+/**********************************************************************/
+/*! \class RtMidiIn
+    \brief A realtime MIDI input class.
+
+    This class provides a common, platform-independent API for
+    realtime MIDI input.  It allows access to a single MIDI input
+    port.  Incoming MIDI messages are either saved to a queue for
+    retrieval using the getMessage() function or immediately passed to
+    a user-specified callback function.  Create multiple instances of
+    this class to connect to more than one MIDI device at the same
+    time.  With the OS-X and Linux ALSA MIDI APIs, it is also possible
+    to open a virtual input port to which other MIDI software clients
+    can connect.
+
+    by Gary P. Scavone, 2003-2012.
+*/
+/**********************************************************************/
+
+// **************************************************************** //
+//
+// RtMidiIn and RtMidiOut class declarations.
+//
+// RtMidiIn / RtMidiOut are "controllers" used to select an available
+// MIDI input or output interface.  They present common APIs for the
+// user to call but all functionality is implemented by the classes
+// MidiInApi, MidiOutApi and their subclasses.  RtMidiIn and RtMidiOut
+// each create an instance of a MidiInApi or MidiOutApi subclass based
+// on the user's API choice.  If no choice is made, they attempt to
+// make a "logical" API selection.
+//
+// **************************************************************** //
+
+class MidiInApi;
+class MidiOutApi;
+
+class RTMIDI_DLL_PUBLIC RtMidiIn : public RtMidi
+{
+ public:
+
+  //! User callback function type definition.
+  typedef void (*RtMidiCallback)( double timeStamp, std::vector<unsigned char> *message, void *userData);
+
+  //! Default constructor that allows an optional api, client name and queue size.
+  /*!
+    An exception will be thrown if a MIDI system initialization
+    error occurs.  The queue size defines the maximum number of
+    messages that can be held in the MIDI queue (when not using a
+    callback function).  If the queue size limit is reached,
+    incoming messages will be ignored.
+
+    If no API argument is specified and multiple API support has been
+    compiled, the default order of use is JACK, ALSA (Linux) and CORE,
+    Jack (OS-X).
+  */
+  RtMidiIn( RtMidi::Api api=UNSPECIFIED,
+            const std::string clientName = std::string( "RtMidi Input Client"),
+            unsigned int queueSizeLimit = 100 );
+
+  //! If a MIDI connection is still open, it will be closed by the destructor.
+  ~RtMidiIn ( void ) throw();
+
+  //! Returns the MIDI API specifier for the current instance of RtMidiIn.
+  RtMidi::Api getCurrentApi( void ) throw();
+
+  //! Open a MIDI input connection.
+  /*!
+    An optional port number greater than 0 can be specified.
+    Otherwise, the default or first port found is opened.
+  */
+  void openPort( unsigned int portNumber = 0, const std::string portName = std::string( "RtMidi Input" ) );
+
+  //! Create a virtual input port, with optional name, to allow software connections (OS X and ALSA only).
+  /*!
+    This function creates a virtual MIDI input port to which other
+    software applications can connect.  This type of functionality
+    is currently only supported by the Macintosh OS-X and Linux ALSA
+    APIs (the function does nothing for the other APIs).
+  */
+  void openVirtualPort( const std::string portName = std::string( "RtMidi Input" ) );
+
+  //! Set a callback function to be invoked for incoming MIDI messages.
+  /*!
+    The callback function will be called whenever an incoming MIDI
+    message is received.  While not absolutely necessary, it is best
+    to set the callback function before opening a MIDI port to avoid
+    leaving some messages in the queue.
+  */
+  void setCallback( RtMidiCallback callback, void *userData = 0 );
+
+  //! Cancel use of the current callback function (if one exists).
+  /*!
+    Subsequent incoming MIDI messages will be written to the queue
+    and can be retrieved with the \e getMessage function.
+  */
+  void cancelCallback();
+
+  //! Close an open MIDI connection (if one exists).
+  void closePort( void );
+
+  //! Return the number of available MIDI input ports.
+  unsigned int getPortCount();
+
+  //! Return a string identifier for the specified MIDI input port number.
+  /*!
+    An empty string is returned if an invalid port specifier is provided.
+  */
+  std::string getPortName( unsigned int portNumber = 0 );
+
+  //! Specify whether certain MIDI message types should be queued or ignored during input.
+  /*!
+    o      By default, MIDI timing and active sensing messages are ignored
+    during message input because of their relative high data rates.
+    MIDI sysex messages are ignored by default as well.  Variable
+    values of "true" imply that the respective message type will be
+    ignored.
+  */
+  void ignoreTypes( bool midiSysex = true, bool midiTime = true, bool midiSense = true );
+
+  //! Fill the user-provided vector with the data bytes for the next available MIDI message in the input queue and return the event delta-time in seconds.
+  /*!
+    This function returns immediately whether a new message is
+    available or not.  A valid message is indicated by a non-zero
+    vector size.  An exception is thrown if an error occurs during
+    message retrieval or an input connection was not previously
+    established.
+  */
+  double getMessage( std::vector<unsigned char> *message );
+
+ protected:
+  void openMidiApi( RtMidi::Api api, const std::string clientName, unsigned int queueSizeLimit );
+  MidiInApi *rtapi_;
+
+};
+
+/**********************************************************************/
+/*! \class RtMidiOut
+    \brief A realtime MIDI output class.
+
+    This class provides a common, platform-independent API for MIDI
+    output.  It allows one to probe available MIDI output ports, to
+    connect to one such port, and to send MIDI bytes immediately over
+    the connection.  Create multiple instances of this class to
+    connect to more than one MIDI device at the same time.  With the
+    OS-X and Linux ALSA MIDI APIs, it is also possible to open a
+    virtual port to which other MIDI software clients can connect.
+
+    by Gary P. Scavone, 2003-2012.
+*/
+/**********************************************************************/
+
+class RTMIDI_DLL_PUBLIC RtMidiOut : public RtMidi
+{
+ public:
+
+  //! Default constructor that allows an optional client name.
+  /*!
+    An exception will be thrown if a MIDI system initialization error occurs.
+
+    If no API argument is specified and multiple API support has been
+    compiled, the default order of use is JACK, ALSA (Linux) and CORE,
+    Jack (OS-X).
+  */
+  RtMidiOut( RtMidi::Api api=UNSPECIFIED,
+             const std::string clientName = std::string( "RtMidi Output Client") );
+
+  //! The destructor closes any open MIDI connections.
+  ~RtMidiOut( void ) throw();
+
+  //! Returns the MIDI API specifier for the current instance of RtMidiOut.
+  RtMidi::Api getCurrentApi( void ) throw();
+
+  //! Open a MIDI output connection.
+  /*!
+      An optional port number greater than 0 can be specified.
+      Otherwise, the default or first port found is opened.  An
+      exception is thrown if an error occurs while attempting to make
+      the port connection.
+  */
+  void openPort( unsigned int portNumber = 0, const std::string portName = std::string( "RtMidi Output" ) );
+
+  //! Close an open MIDI connection (if one exists).
+  void closePort( void );
+
+  //! Create a virtual output port, with optional name, to allow software connections (OS X and ALSA only).
+  /*!
+      This function creates a virtual MIDI output port to which other
+      software applications can connect.  This type of functionality
+      is currently only supported by the Macintosh OS-X and Linux ALSA
+      APIs (the function does nothing with the other APIs).  An
+      exception is thrown if an error occurs while attempting to create
+      the virtual port.
+  */
+  void openVirtualPort( const std::string portName = std::string( "RtMidi Output" ) );
+
+  //! Return the number of available MIDI output ports.
+  unsigned int getPortCount( void );
+
+  //! Return a string identifier for the specified MIDI port type and number.
+  /*!
+      An empty string is returned if an invalid port specifier is provided.
+  */
+  std::string getPortName( unsigned int portNumber = 0 );
+
+  //! Immediately send a single message out an open MIDI output port.
+  /*!
+      An exception is thrown if an error occurs during output or an
+      output connection was not previously established.
+  */
+  void sendMessage( std::vector<unsigned char> *message );
+
+ protected:
+  void openMidiApi( RtMidi::Api api, const std::string clientName );
+  MidiOutApi *rtapi_;
+};
+
+
+// **************************************************************** //
+//
+// MidiInApi / MidiOutApi class declarations.
+//
+// Subclasses of MidiInApi and MidiOutApi contain all API- and
+// OS-specific code necessary to fully implement the RtMidi API.
+//
+// Note that MidiInApi and MidiOutApi are abstract base classes and
+// cannot be explicitly instantiated.  RtMidiIn and RtMidiOut will
+// create instances of a MidiInApi or MidiOutApi subclass.
+//
+// **************************************************************** //
+
+class MidiInApi
+{
+ public:
+
+  MidiInApi( unsigned int queueSizeLimit );
+  virtual ~MidiInApi( void );
+  virtual RtMidi::Api getCurrentApi( void ) = 0;
+  virtual void openPort( unsigned int portNumber, const std::string portName ) = 0;
+  virtual void openVirtualPort( const std::string portName ) = 0;
+  virtual void closePort( void ) = 0;
+  void setCallback( RtMidiIn::RtMidiCallback callback, void *userData );
+  void cancelCallback( void );
+  virtual unsigned int getPortCount( void ) = 0;
+  virtual std::string getPortName( unsigned int portNumber ) = 0;
+  virtual void ignoreTypes( bool midiSysex, bool midiTime, bool midiSense );
+  double getMessage( std::vector<unsigned char> *message );
+
+  // A MIDI structure used internally by the class to store incoming
+  // messages.  Each message represents one and only one MIDI message.
+  struct MidiMessage { 
+    std::vector<unsigned char> bytes; 
+    double timeStamp;
+
+    // Default constructor.
+  MidiMessage()
+  :bytes(0), timeStamp(0.0) {}
+  };
+
+  struct MidiQueue {
+    unsigned int front;
+    unsigned int back;
+    unsigned int size;
+    unsigned int ringSize;
+    MidiMessage *ring;
+
+    // Default constructor.
+  MidiQueue()
+  :front(0), back(0), size(0), ringSize(0) {}
+  };
+
+  // The RtMidiInData structure is used to pass private class data to
+  // the MIDI input handling function or thread.
+  struct RtMidiInData {
+    MidiQueue queue;
+    MidiMessage message;
+    unsigned char ignoreFlags;
+    bool doInput;
+    bool firstMessage;
+    void *apiData;
+    bool usingCallback;
+    void *userCallback;
+    void *userData;
+    bool continueSysex;
+
+    // Default constructor.
+  RtMidiInData()
+  : ignoreFlags(7), doInput(false), firstMessage(true),
+      apiData(0), usingCallback(false), userCallback(0), userData(0),
+      continueSysex(false) {}
+  };
+
+ protected:
+  virtual void initialize( const std::string& clientName ) = 0;
+  RtMidiInData inputData_;
+
+  void *apiData_;
+  bool connected_;
+  std::string errorString_;
+};
+
+class MidiOutApi
+{
+ public:
+
+  MidiOutApi( void );
+  virtual ~MidiOutApi( void );
+  virtual RtMidi::Api getCurrentApi( void ) = 0;
+  virtual void openPort( unsigned int portNumber, const std::string portName ) = 0;
+  virtual void openVirtualPort( const std::string portName ) = 0;
+  virtual void closePort( void ) = 0;
+  virtual unsigned int getPortCount( void ) = 0;
+  virtual std::string getPortName( unsigned int portNumber ) = 0;
+  virtual void sendMessage( std::vector<unsigned char> *message ) = 0;
+
+ protected:
+  virtual void initialize( const std::string& clientName ) = 0;
+
+  void *apiData_;
+  bool connected_;
+  std::string errorString_;
+};
+
+// **************************************************************** //
+//
+// Inline RtMidiIn and RtMidiOut definitions.
+//
+// **************************************************************** //
+
+inline RtMidi::Api RtMidiIn :: getCurrentApi( void ) throw() { return rtapi_->getCurrentApi(); }
+inline void RtMidiIn :: openPort( unsigned int portNumber, const std::string portName ) { return rtapi_->openPort( portNumber, portName ); }
+inline void RtMidiIn :: openVirtualPort( const std::string portName ) { return rtapi_->openVirtualPort( portName ); }
+inline void RtMidiIn :: closePort( void ) { return rtapi_->closePort(); }
+inline void RtMidiIn :: setCallback( RtMidiCallback callback, void *userData ) { return rtapi_->setCallback( callback, userData ); }
+inline void RtMidiIn :: cancelCallback( void ) { return rtapi_->cancelCallback(); }
+inline unsigned int RtMidiIn :: getPortCount( void ) { return rtapi_->getPortCount(); }
+inline std::string RtMidiIn :: getPortName( unsigned int portNumber ) { return rtapi_->getPortName( portNumber ); }
+inline void RtMidiIn :: ignoreTypes( bool midiSysex, bool midiTime, bool midiSense ) { return rtapi_->ignoreTypes( midiSysex, midiTime, midiSense ); }
+inline double RtMidiIn :: getMessage( std::vector<unsigned char> *message ) { return rtapi_->getMessage( message ); }
+
+inline RtMidi::Api RtMidiOut :: getCurrentApi( void ) throw() { return rtapi_->getCurrentApi(); }
+inline void RtMidiOut :: openPort( unsigned int portNumber, const std::string portName ) { return rtapi_->openPort( portNumber, portName ); }
+inline void RtMidiOut :: openVirtualPort( const std::string portName ) { return rtapi_->openVirtualPort( portName ); }
+inline void RtMidiOut :: closePort( void ) { return rtapi_->closePort(); }
+inline unsigned int RtMidiOut :: getPortCount( void ) { return rtapi_->getPortCount(); }
+inline std::string RtMidiOut :: getPortName( unsigned int portNumber ) { return rtapi_->getPortName( portNumber ); }
+inline void RtMidiOut :: sendMessage( std::vector<unsigned char> *message ) { return rtapi_->sendMessage( message ); }
+
+// **************************************************************** //
+//
+// MidiInApi and MidiOutApi subclass prototypes.
+//
+// **************************************************************** //
+
+#if !defined(__LINUX_ALSA__) && !defined(__UNIX_JACK__) && !defined(__MACOSX_CORE__) && !defined(__WINDOWS_MM__) && !defined(__WINDOWS_KS__)
+  #define __RTMIDI_DUMMY__
+#endif
+
+#if defined(__MACOSX_CORE__)
+
+class MidiInCore: public MidiInApi
+{
+ public:
+  MidiInCore( const std::string clientName, unsigned int queueSizeLimit );
+  ~MidiInCore( void );
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::MACOSX_CORE; };
+  void openPort( unsigned int portNumber, const std::string portName );
+  void openVirtualPort( const std::string portName );
+  void closePort( void );
+  unsigned int getPortCount( void );
+  std::string getPortName( unsigned int portNumber );
+
+ protected:
+  void initialize( const std::string& clientName );
+};
+
+class MidiOutCore: public MidiOutApi
+{
+ public:
+  MidiOutCore( const std::string clientName );
+  ~MidiOutCore( void );
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::MACOSX_CORE; };
+  void openPort( unsigned int portNumber, const std::string portName );
+  void openVirtualPort( const std::string portName );
+  void closePort( void );
+  unsigned int getPortCount( void );
+  std::string getPortName( unsigned int portNumber );
+  void sendMessage( std::vector<unsigned char> *message );
+
+ protected:
+  void initialize( const std::string& clientName );
+};
+
+#endif
+
+#if defined(__UNIX_JACK__)
+
+class MidiInJack: public MidiInApi
+{
+ public:
+  MidiInJack( const std::string clientName, unsigned int queueSizeLimit );
+  ~MidiInJack( void );
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::UNIX_JACK; };
+  void openPort( unsigned int portNumber, const std::string portName );
+  void openVirtualPort( const std::string portName );
+  void closePort( void );
+  unsigned int getPortCount( void );
+  std::string getPortName( unsigned int portNumber );
+
+ protected:
+  void initialize( const std::string& clientName );
+};
+
+class MidiOutJack: public MidiOutApi
+{
+ public:
+  MidiOutJack( const std::string clientName );
+  ~MidiOutJack( void );
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::UNIX_JACK; };
+  void openPort( unsigned int portNumber, const std::string portName );
+  void openVirtualPort( const std::string portName );
+  void closePort( void );
+  unsigned int getPortCount( void );
+  std::string getPortName( unsigned int portNumber );
+  void sendMessage( std::vector<unsigned char> *message );
+
+ protected:
+  void initialize( const std::string& clientName );
+};
+
+#endif
+
+#if defined(__LINUX_ALSA__)
+
+class MidiInAlsa: public MidiInApi
+{
+ public:
+  MidiInAlsa( const std::string clientName, unsigned int queueSizeLimit );
+  ~MidiInAlsa( void );
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::LINUX_ALSA; };
+  void openPort( unsigned int portNumber, const std::string portName );
+  void openVirtualPort( const std::string portName );
+  void closePort( void );
+  unsigned int getPortCount( void );
+  std::string getPortName( unsigned int portNumber );
+
+ protected:
+  void initialize( const std::string& clientName );
+};
+
+class MidiOutAlsa: public MidiOutApi
+{
+ public:
+  MidiOutAlsa( const std::string clientName );
+  ~MidiOutAlsa( void );
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::LINUX_ALSA; };
+  void openPort( unsigned int portNumber, const std::string portName );
+  void openVirtualPort( const std::string portName );
+  void closePort( void );
+  unsigned int getPortCount( void );
+  std::string getPortName( unsigned int portNumber );
+  void sendMessage( std::vector<unsigned char> *message );
+
+ protected:
+  void initialize( const std::string& clientName );
+};
+
+#endif
+
+#if defined(__WINDOWS_MM__)
+
+class MidiInWinMM: public MidiInApi
+{
+ public:
+  MidiInWinMM( const std::string clientName, unsigned int queueSizeLimit );
+  ~MidiInWinMM( void );
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::WINDOWS_MM; };
+  void openPort( unsigned int portNumber, const std::string portName );
+  void openVirtualPort( const std::string portName );
+  void closePort( void );
+  unsigned int getPortCount( void );
+  std::string getPortName( unsigned int portNumber );
+
+ protected:
+  void initialize( const std::string& clientName );
+};
+
+class MidiOutWinMM: public MidiOutApi
+{
+ public:
+  MidiOutWinMM( const std::string clientName );
+  ~MidiOutWinMM( void );
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::WINDOWS_MM; };
+  void openPort( unsigned int portNumber, const std::string portName );
+  void openVirtualPort( const std::string portName );
+  void closePort( void );
+  unsigned int getPortCount( void );
+  std::string getPortName( unsigned int portNumber );
+  void sendMessage( std::vector<unsigned char> *message );
+
+ protected:
+  void initialize( const std::string& clientName );
+};
+
+#endif
+
+#if defined(__WINDOWS_KS__)
+
+class MidiInWinKS: public MidiInApi
+{
+ public:
+  MidiInWinKS( const std::string clientName, unsigned int queueSizeLimit );
+  ~MidiInWinKS( void );
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::WINDOWS_KS; };
+  void openPort( unsigned int portNumber, const std::string portName );
+  void openVirtualPort( const std::string portName );
+  void closePort( void );
+  unsigned int getPortCount( void );
+  std::string getPortName( unsigned int portNumber );
+
+ protected:
+  void initialize( const std::string& clientName );
+};
+
+class MidiOutWinKS: public MidiOutApi
+{
+ public:
+  MidiOutWinKS( const std::string clientName );
+  ~MidiOutWinKS( void );
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::WINDOWS_KS; };
+  void openPort( unsigned int portNumber, const std::string portName );
+  void openVirtualPort( const std::string portName );
+  void closePort( void );
+  unsigned int getPortCount( void );
+  std::string getPortName( unsigned int portNumber );
+  void sendMessage( std::vector<unsigned char> *message );
+
+ protected:
+  void initialize( const std::string& clientName );
+};
+
+#endif
+
+#if defined(__RTMIDI_DUMMY__)
+
+class MidiInDummy: public MidiInApi
+{
+ public:
+ MidiInDummy( const std::string clientName, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit ) { errorString_ = "MidiInDummy: This class provides no functionality."; RtMidi::error( RtError::WARNING, errorString_ ); };
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::RTMIDI_DUMMY; };
+  void openPort( unsigned int portNumber, const std::string portName ) {};
+  void openVirtualPort( const std::string portName ) {};
+  void closePort( void ) {};
+  unsigned int getPortCount( void ) { return 0; };
+  std::string getPortName( unsigned int portNumber ) { return ""; };
+
+ protected:
+  void initialize( const std::string& clientName ) {};
+};
+
+class MidiOutDummy: public MidiOutApi
+{
+ public:
+  MidiOutDummy( const std::string clientName ) { errorString_ = "MidiOutDummy: This class provides no functionality."; RtMidi::error( RtError::WARNING, errorString_ ); };
+  RtMidi::Api getCurrentApi( void ) { return RtMidi::RTMIDI_DUMMY; };
+  void openPort( unsigned int portNumber, const std::string portName ) {};
+  void openVirtualPort( const std::string portName ) {};
+  void closePort( void ) {};
+  unsigned int getPortCount( void ) { return 0; };
+  std::string getPortName( unsigned int portNumber ) { return ""; };
+  void sendMessage( std::vector<unsigned char> *message ) {};
+
+ protected:
+  void initialize( const std::string& clientName ) {};
+};
+
+#endif
+
+#endif
--- /dev/null
+++ giada-0.7.2/src/rtmidi/RtError.h
@@ -0,0 +1,60 @@
+/************************************************************************/
+/*! \class RtError
+    \brief Exception handling class for RtAudio & RtMidi.
+
+    The RtError class is quite simple but it does allow errors to be
+    "caught" by RtError::Type. See the RtAudio and RtMidi
+    documentation to know which methods can throw an RtError.
+
+*/
+/************************************************************************/
+
+#ifndef RTERROR_H
+#define RTERROR_H
+
+#include <exception>
+#include <iostream>
+#include <string>
+
+class RtError : public std::exception
+{
+ public:
+  //! Defined RtError types.
+  enum Type {
+    WARNING,           /*!< A non-critical error. */
+    DEBUG_WARNING,     /*!< A non-critical error which might be useful for debugging. */
+    UNSPECIFIED,       /*!< The default, unspecified error type. */
+    NO_DEVICES_FOUND,  /*!< No devices found on system. */
+    INVALID_DEVICE,    /*!< An invalid device ID was specified. */
+    MEMORY_ERROR,      /*!< An error occured during memory allocation. */
+    INVALID_PARAMETER, /*!< An invalid parameter was specified to a function. */
+    INVALID_USE,       /*!< The function was called incorrectly. */
+    DRIVER_ERROR,      /*!< A system driver error occured. */
+    SYSTEM_ERROR,      /*!< A system error occured. */
+    THREAD_ERROR       /*!< A thread error occured. */
+  };
+
+  //! The constructor.
+  RtError( const std::string& message, Type type = RtError::UNSPECIFIED ) throw() : message_(message), type_(type) {}
+ 
+  //! The destructor.
+  virtual ~RtError( void ) throw() {}
+
+  //! Prints thrown error message to stderr.
+  virtual void printMessage( void ) const throw() { std::cerr << '\n' << message_ << "\n\n"; }
+
+  //! Returns the thrown error message type.
+  virtual const Type& getType(void) const throw() { return type_; }
+
+  //! Returns the thrown error message string.
+  virtual const std::string& getMessage(void) const throw() { return message_; }
+
+  //! Returns the thrown error message as a c-style string.
+  virtual const char* what( void ) const throw() { return message_.c_str(); }
+
+ protected:
+  std::string message_;
+  Type type_;
+};
+
+#endif
--- /dev/null
+++ giada-0.7.2/src/rtmidi/rtmidi.pc.in
@@ -0,0 +1,14 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: rtmidi
+Description: Library for realtime MIDI input/output
+Version: @VERSION@
+URL: http://www.music.mcgill.ca/~gary/rtmidi/index.html
+Requires: @pc_requires@
+Conflicts:
+Libs: -L${libdir} -l@SONAME@
+Libs.private:
+Cflags: @api@
--- /dev/null
+++ giada-0.7.2/src/rtmidi/RtMidi.cpp
@@ -0,0 +1,3747 @@
+/**********************************************************************/
+/*! \class RtMidi
+    \brief An abstract base class for realtime MIDI input/output.
+
+    This class implements some common functionality for the realtime
+    MIDI input/output subclasses RtMidiIn and RtMidiOut.
+
+    RtMidi WWW site: http://music.mcgill.ca/~gary/rtmidi/
+
+    RtMidi: realtime MIDI i/o C++ classes
+    Copyright (c) 2003-2012 Gary P. Scavone
+
+    Permission is hereby granted, free of charge, to any person
+    obtaining a copy of this software and associated documentation files
+    (the "Software"), to deal in the Software without restriction,
+    including without limitation the rights to use, copy, modify, merge,
+    publish, distribute, sublicense, and/or sell copies of the Software,
+    and to permit persons to whom the Software is furnished to do so,
+    subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be
+    included in all copies or substantial portions of the Software.
+
+    Any person wishing to distribute modifications to the Software is
+    asked to send the modifications to the original developer so that
+    they can be incorporated into the canonical version.  This is,
+    however, not a binding provision of this license.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+/**********************************************************************/
+
+// RtMidi: Version 2.0.1
+
+#include "RtMidi.h"
+#include <sstream>
+
+//*********************************************************************//
+//  RtMidi Definitions
+//*********************************************************************//
+
+void RtMidi :: getCompiledApi( std::vector<RtMidi::Api> &apis ) throw()
+{
+  apis.clear();
+
+  // The order here will control the order of RtMidi's API search in
+  // the constructor.
+#if defined(__MACOSX_CORE__)
+  apis.push_back( MACOSX_CORE );
+#endif
+#if defined(__LINUX_ALSA__)
+  apis.push_back( LINUX_ALSA );
+#endif
+#if defined(__UNIX_JACK__)
+  apis.push_back( UNIX_JACK );
+#endif
+#if defined(__WINDOWS_MM__)
+  apis.push_back( WINDOWS_MM );
+#endif
+#if defined(__WINDOWS_KS__)
+  apis.push_back( WINDOWS_KS );
+#endif
+#if defined(__RTMIDI_DUMMY__)
+  apis.push_back( RTMIDI_DUMMY );
+#endif
+}
+
+void RtMidi :: error( RtError::Type type, std::string errorString )
+{
+  if (type == RtError::WARNING) {
+    std::cerr << '\n' << errorString << "\n\n";
+  }
+  else if (type == RtError::DEBUG_WARNING) {
+#if defined(__RTMIDI_DEBUG__)
+    std::cerr << '\n' << errorString << "\n\n";
+#endif
+  }
+  else {
+    std::cerr << '\n' << errorString << "\n\n";
+    throw RtError( errorString, type );
+  }
+}
+
+//*********************************************************************//
+//  RtMidiIn Definitions
+//*********************************************************************//
+
+void RtMidiIn :: openMidiApi( RtMidi::Api api, const std::string clientName, unsigned int queueSizeLimit )
+{
+  if ( rtapi_ )
+    delete rtapi_;
+  rtapi_ = 0;
+
+#if defined(__UNIX_JACK__)
+  if ( api == UNIX_JACK )
+    rtapi_ = new MidiInJack( clientName, queueSizeLimit );
+#endif
+#if defined(__LINUX_ALSA__)
+  if ( api == LINUX_ALSA )
+    rtapi_ = new MidiInAlsa( clientName, queueSizeLimit );
+#endif
+#if defined(__WINDOWS_MM__)
+  if ( api == WINDOWS_MM )
+    rtapi_ = new MidiInWinMM( clientName, queueSizeLimit );
+#endif
+#if defined(__WINDOWS_KS__)
+  if ( api == WINDOWS_KS )
+    rtapi_ = new MidiInWinKS( clientName, queueSizeLimit );
+#endif
+#if defined(__MACOSX_CORE__)
+  if ( api == MACOSX_CORE )
+    rtapi_ = new MidiInCore( clientName, queueSizeLimit );
+#endif
+#if defined(__RTMIDI_DUMMY__)
+  if ( api == RTMIDI_DUMMY )
+    rtapi_ = new MidiInDummy( clientName, queueSizeLimit );
+#endif
+}
+
+extern RTMIDI_DLL_PUBLIC RtMidiIn :: RtMidiIn( RtMidi::Api api, const std::string clientName, unsigned int queueSizeLimit )
+{
+  rtapi_ = 0;
+
+  if ( api != UNSPECIFIED ) {
+    // Attempt to open the specified API.
+    openMidiApi( api, clientName, queueSizeLimit );
+    if ( rtapi_ ) return;
+
+    // No compiled support for specified API value.  Issue a debug
+    // warning and continue as if no API was specified.
+    RtMidi::error( RtError::WARNING, "RtMidiIn: no compiled support for specified API argument!" );
+  }
+
+  // Iterate through the compiled APIs and return as soon as we find
+  // one with at least one port or we reach the end of the list.
+  std::vector< RtMidi::Api > apis;
+  getCompiledApi( apis );
+  for ( unsigned int i=0; i<apis.size(); i++ ) {
+    openMidiApi( apis[i], clientName, queueSizeLimit );
+    if ( rtapi_->getPortCount() ) break;
+  }
+
+  if ( rtapi_ ) return;
+
+  // It should not be possible to get here because the preprocessor
+  // definition __RTMIDI_DUMMY__ is automatically defined if no
+  // API-specific definitions are passed to the compiler. But just in
+  // case something weird happens, we'll print out an error message.
+  RtMidi::error( RtError::WARNING, "RtMidiIn: no compiled API support found ... critical error!!" );
+}
+
+RtMidiIn :: ~RtMidiIn() throw()
+{
+  delete rtapi_;
+}
+
+
+//*********************************************************************//
+//  RtMidiOut Definitions
+//*********************************************************************//
+
+void RtMidiOut :: openMidiApi( RtMidi::Api api, const std::string clientName )
+{
+  if ( rtapi_ )
+    delete rtapi_;
+  rtapi_ = 0;
+
+#if defined(__UNIX_JACK__)
+  if ( api == UNIX_JACK )
+    rtapi_ = new MidiOutJack( clientName );
+#endif
+#if defined(__LINUX_ALSA__)
+  if ( api == LINUX_ALSA )
+    rtapi_ = new MidiOutAlsa( clientName );
+#endif
+#if defined(__WINDOWS_MM__)
+  if ( api == WINDOWS_MM )
+    rtapi_ = new MidiOutWinMM( clientName );
+#endif
+#if defined(__WINDOWS_KS__)
+  if ( api == WINDOWS_KS )
+    rtapi_ = new MidiOutWinKS( clientName );
+#endif
+#if defined(__MACOSX_CORE__)
+  if ( api == MACOSX_CORE )
+    rtapi_ = new MidiOutCore( clientName );
+#endif
+#if defined(__RTMIDI_DUMMY__)
+  if ( api == RTMIDI_DUMMY )
+    rtapi_ = new MidiOutDummy( clientName );
+#endif
+}
+
+extern RTMIDI_DLL_PUBLIC RtMidiOut :: RtMidiOut( RtMidi::Api api, const std::string clientName )
+{
+  rtapi_ = 0;
+
+  if ( api != UNSPECIFIED ) {
+    // Attempt to open the specified API.
+    openMidiApi( api, clientName );
+    if ( rtapi_ ) return;
+
+    // No compiled support for specified API value.  Issue a debug
+    // warning and continue as if no API was specified.
+    RtMidi::error( RtError::WARNING, "RtMidiOut: no compiled support for specified API argument!" );
+  }
+
+  // Iterate through the compiled APIs and return as soon as we find
+  // one with at least one port or we reach the end of the list.
+  std::vector< RtMidi::Api > apis;
+  getCompiledApi( apis );
+  for ( unsigned int i=0; i<apis.size(); i++ ) {
+    openMidiApi( apis[i], clientName );
+    if ( rtapi_->getPortCount() ) break;
+  }
+
+  if ( rtapi_ ) return;
+
+  // It should not be possible to get here because the preprocessor
+  // definition __RTMIDI_DUMMY__ is automatically defined if no
+  // API-specific definitions are passed to the compiler. But just in
+  // case something weird happens, we'll print out an error message.
+  RtMidi::error( RtError::WARNING, "RtMidiOut: no compiled API support found ... critical error!!" );
+}
+
+RtMidiOut :: ~RtMidiOut() throw()
+{
+  delete rtapi_;
+}
+
+//*********************************************************************//
+//  Common MidiInApi Definitions
+//*********************************************************************//
+
+MidiInApi :: MidiInApi( unsigned int queueSizeLimit )
+  : apiData_( 0 ), connected_( false )
+{
+  // Allocate the MIDI queue.
+  inputData_.queue.ringSize = queueSizeLimit;
+  if ( inputData_.queue.ringSize > 0 )
+    inputData_.queue.ring = new MidiMessage[ inputData_.queue.ringSize ];
+}
+
+MidiInApi :: ~MidiInApi( void )
+{
+  // Delete the MIDI queue.
+  if ( inputData_.queue.ringSize > 0 ) delete [] inputData_.queue.ring;
+}
+
+void MidiInApi :: setCallback( RtMidiIn::RtMidiCallback callback, void *userData )
+{
+  if ( inputData_.usingCallback ) {
+    errorString_ = "MidiInApi::setCallback: a callback function is already set!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  if ( !callback ) {
+    errorString_ = "RtMidiIn::setCallback: callback function value is invalid!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  inputData_.userCallback = (void *) callback;
+  inputData_.userData = userData;
+  inputData_.usingCallback = true;
+}
+
+void MidiInApi :: cancelCallback()
+{
+  if ( !inputData_.usingCallback ) {
+    errorString_ = "RtMidiIn::cancelCallback: no callback function was set!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  inputData_.userCallback = 0;
+  inputData_.userData = 0;
+  inputData_.usingCallback = false;
+}
+
+void MidiInApi :: ignoreTypes( bool midiSysex, bool midiTime, bool midiSense )
+{
+  inputData_.ignoreFlags = 0;
+  if ( midiSysex ) inputData_.ignoreFlags = 0x01;
+  if ( midiTime ) inputData_.ignoreFlags |= 0x02;
+  if ( midiSense ) inputData_.ignoreFlags |= 0x04;
+}
+
+double MidiInApi :: getMessage( std::vector<unsigned char> *message )
+{
+  message->clear();
+
+  if ( inputData_.usingCallback ) {
+    errorString_ = "RtMidiIn::getNextMessage: a user callback is currently set for this port.";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return 0.0;
+  }
+
+  if ( inputData_.queue.size == 0 ) return 0.0;
+
+  // Copy queued message to the vector pointer argument and then "pop" it.
+  std::vector<unsigned char> *bytes = &(inputData_.queue.ring[inputData_.queue.front].bytes);
+  message->assign( bytes->begin(), bytes->end() );
+  double deltaTime = inputData_.queue.ring[inputData_.queue.front].timeStamp;
+  inputData_.queue.size--;
+  inputData_.queue.front++;
+  if ( inputData_.queue.front == inputData_.queue.ringSize )
+    inputData_.queue.front = 0;
+
+  return deltaTime;
+}
+
+//*********************************************************************//
+//  Common MidiOutApi Definitions
+//*********************************************************************//
+
+MidiOutApi :: MidiOutApi( void )
+  : apiData_( 0 ), connected_( false )
+{
+}
+
+MidiOutApi :: ~MidiOutApi( void )
+{
+}
+
+// *************************************************** //
+//
+// OS/API-specific methods.
+//
+// *************************************************** //
+
+#if defined(__MACOSX_CORE__)
+
+// The CoreMIDI API is based on the use of a callback function for
+// MIDI input.  We convert the system specific time stamps to delta
+// time values.
+
+// OS-X CoreMIDI header files.
+#include <CoreMIDI/CoreMIDI.h>
+#include <CoreAudio/HostTime.h>
+#include <CoreServices/CoreServices.h>
+
+// A structure to hold variables related to the CoreMIDI API
+// implementation.
+struct CoreMidiData {
+  MIDIClientRef client;
+  MIDIPortRef port;
+  MIDIEndpointRef endpoint;
+  MIDIEndpointRef destinationId;
+  unsigned long long lastTime;
+  MIDISysexSendRequest sysexreq;
+};
+
+//*********************************************************************//
+//  API: OS-X
+//  Class Definitions: MidiInCore
+//*********************************************************************//
+
+void midiInputCallback( const MIDIPacketList *list, void *procRef, void *srcRef )
+{
+  MidiInApi::RtMidiInData *data = static_cast<MidiInApi::RtMidiInData *> (procRef);
+  CoreMidiData *apiData = static_cast<CoreMidiData *> (data->apiData);
+
+  unsigned char status;
+  unsigned short nBytes, iByte, size;
+  unsigned long long time;
+
+  bool& continueSysex = data->continueSysex;
+  MidiInApi::MidiMessage& message = data->message;
+
+  const MIDIPacket *packet = &list->packet[0];
+  for ( unsigned int i=0; i<list->numPackets; ++i ) {
+
+    // My interpretation of the CoreMIDI documentation: all message
+    // types, except sysex, are complete within a packet and there may
+    // be several of them in a single packet.  Sysex messages can be
+    // broken across multiple packets and PacketLists but are bundled
+    // alone within each packet (these packets do not contain other
+    // message types).  If sysex messages are split across multiple
+    // MIDIPacketLists, they must be handled by multiple calls to this
+    // function.
+
+    nBytes = packet->length;
+    if ( nBytes == 0 ) continue;
+
+    // Calculate time stamp.
+
+    if ( data->firstMessage ) {
+      message.timeStamp = 0.0;
+      data->firstMessage = false;
+    }
+    else {
+      time = packet->timeStamp;
+      if ( time == 0 ) { // this happens when receiving asynchronous sysex messages
+        time = AudioGetCurrentHostTime();
+      }
+      time -= apiData->lastTime;
+      time = AudioConvertHostTimeToNanos( time );
+      if ( !continueSysex )
+        message.timeStamp = time * 0.000000001;
+    }
+    apiData->lastTime = packet->timeStamp;
+    if ( apiData->lastTime == 0 ) { // this happens when receiving asynchronous sysex messages
+      apiData->lastTime = AudioGetCurrentHostTime();
+    }
+    //std::cout << "TimeStamp = " << packet->timeStamp << std::endl;
+
+    iByte = 0;
+    if ( continueSysex ) {
+      // We have a continuing, segmented sysex message.
+      if ( !( data->ignoreFlags & 0x01 ) ) {
+        // If we're not ignoring sysex messages, copy the entire packet.
+        for ( unsigned int j=0; j<nBytes; ++j )
+          message.bytes.push_back( packet->data[j] );
+      }
+      continueSysex = packet->data[nBytes-1] != 0xF7;
+
+      if ( !continueSysex ) {
+        // If not a continuing sysex message, invoke the user callback function or queue the message.
+        if ( data->usingCallback ) {
+          RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
+          callback( message.timeStamp, &message.bytes, data->userData );
+        }
+        else {
+          // As long as we haven't reached our queue size limit, push the message.
+          if ( data->queue.size < data->queue.ringSize ) {
+            data->queue.ring[data->queue.back++] = message;
+            if ( data->queue.back == data->queue.ringSize )
+              data->queue.back = 0;
+            data->queue.size++;
+          }
+          else
+            std::cerr << "\nMidiInCore: message queue limit reached!!\n\n";
+        }
+        message.bytes.clear();
+      }
+    }
+    else {
+      while ( iByte < nBytes ) {
+        size = 0;
+        // We are expecting that the next byte in the packet is a status byte.
+        status = packet->data[iByte];
+        if ( !(status & 0x80) ) break;
+        // Determine the number of bytes in the MIDI message.
+        if ( status < 0xC0 ) size = 3;
+        else if ( status < 0xE0 ) size = 2;
+        else if ( status < 0xF0 ) size = 3;
+        else if ( status == 0xF0 ) {
+          // A MIDI sysex
+          if ( data->ignoreFlags & 0x01 ) {
+            size = 0;
+            iByte = nBytes;
+          }
+          else size = nBytes - iByte;
+          continueSysex = packet->data[nBytes-1] != 0xF7;
+        }
+        else if ( status == 0xF1 ) {
+            // A MIDI time code message
+           if ( data->ignoreFlags & 0x02 ) {
+            size = 0;
+            iByte += 2;
+           }
+           else size = 2;
+        }
+        else if ( status == 0xF2 ) size = 3;
+        else if ( status == 0xF3 ) size = 2;
+        else if ( status == 0xF8 && ( data->ignoreFlags & 0x02 ) ) {
+          // A MIDI timing tick message and we're ignoring it.
+          size = 0;
+          iByte += 1;
+        }
+        else if ( status == 0xFE && ( data->ignoreFlags & 0x04 ) ) {
+          // A MIDI active sensing message and we're ignoring it.
+          size = 0;
+          iByte += 1;
+        }
+        else size = 1;
+
+        // Copy the MIDI data to our vector.
+        if ( size ) {
+          message.bytes.assign( &packet->data[iByte], &packet->data[iByte+size] );
+          if ( !continueSysex ) {
+            // If not a continuing sysex message, invoke the user callback function or queue the message.
+            if ( data->usingCallback ) {
+              RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
+              callback( message.timeStamp, &message.bytes, data->userData );
+            }
+            else {
+              // As long as we haven't reached our queue size limit, push the message.
+              if ( data->queue.size < data->queue.ringSize ) {
+                data->queue.ring[data->queue.back++] = message;
+                if ( data->queue.back == data->queue.ringSize )
+                  data->queue.back = 0;
+                data->queue.size++;
+              }
+              else
+                std::cerr << "\nMidiInCore: message queue limit reached!!\n\n";
+            }
+            message.bytes.clear();
+          }
+          iByte += size;
+        }
+      }
+    }
+    packet = MIDIPacketNext(packet);
+  }
+}
+
+MidiInCore :: MidiInCore( const std::string clientName, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit )
+{
+  initialize( clientName );
+}
+
+MidiInCore :: ~MidiInCore( void )
+{
+  // Close a connection if it exists.
+  closePort();
+
+  // Cleanup.
+  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
+  MIDIClientDispose( data->client );
+  if ( data->endpoint ) MIDIEndpointDispose( data->endpoint );
+  delete data;
+}
+
+void MidiInCore :: initialize( const std::string& clientName )
+{
+  // Set up our client.
+  MIDIClientRef client;
+  OSStatus result = MIDIClientCreate( CFStringCreateWithCString( NULL, clientName.c_str(), kCFStringEncodingASCII ), NULL, NULL, &client );
+  if ( result != noErr ) {
+    errorString_ = "MidiInCore::initialize: error creating OS-X MIDI client object.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Save our api-specific connection information.
+  CoreMidiData *data = (CoreMidiData *) new CoreMidiData;
+  data->client = client;
+  data->endpoint = 0;
+  apiData_ = (void *) data;
+  inputData_.apiData = (void *) data;
+}
+
+void MidiInCore :: openPort( unsigned int portNumber, const std::string portName )
+{
+  if ( connected_ ) {
+    errorString_ = "MidiInCore::openPort: a valid connection already exists!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  unsigned int nSrc = MIDIGetNumberOfSources();
+  if (nSrc < 1) {
+    errorString_ = "MidiInCore::openPort: no MIDI input sources found!";
+    RtMidi::error( RtError::NO_DEVICES_FOUND, errorString_ );
+  }
+
+  std::ostringstream ost;
+  if ( portNumber >= nSrc ) {
+    ost << "MidiInCore::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+  }
+
+  MIDIPortRef port;
+  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
+  OSStatus result = MIDIInputPortCreate( data->client, 
+                                         CFStringCreateWithCString( NULL, portName.c_str(), kCFStringEncodingASCII ),
+                                         midiInputCallback, (void *)&inputData_, &port );
+  if ( result != noErr ) {
+    MIDIClientDispose( data->client );
+    errorString_ = "MidiInCore::openPort: error creating OS-X MIDI input port.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Get the desired input source identifier.
+  MIDIEndpointRef endpoint = MIDIGetSource( portNumber );
+  if ( endpoint == 0 ) {
+    MIDIPortDispose( port );
+    MIDIClientDispose( data->client );
+    errorString_ = "MidiInCore::openPort: error getting MIDI input source reference.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Make the connection.
+  result = MIDIPortConnectSource( port, endpoint, NULL );
+  if ( result != noErr ) {
+    MIDIPortDispose( port );
+    MIDIClientDispose( data->client );
+    errorString_ = "MidiInCore::openPort: error connecting OS-X MIDI input port.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Save our api-specific port information.
+  data->port = port;
+
+  connected_ = true;
+}
+
+void MidiInCore :: openVirtualPort( const std::string portName )
+{
+  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
+
+  // Create a virtual MIDI input destination.
+  MIDIEndpointRef endpoint;
+  OSStatus result = MIDIDestinationCreate( data->client,
+                                           CFStringCreateWithCString( NULL, portName.c_str(), kCFStringEncodingASCII ),
+                                           midiInputCallback, (void *)&inputData_, &endpoint );
+  if ( result != noErr ) {
+    errorString_ = "MidiInCore::openVirtualPort: error creating virtual OS-X MIDI destination.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Save our api-specific connection information.
+  data->endpoint = endpoint;
+}
+
+void MidiInCore :: closePort( void )
+{
+  if ( connected_ ) {
+    CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
+    MIDIPortDispose( data->port );
+    connected_ = false;
+  }
+}
+
+unsigned int MidiInCore :: getPortCount()
+{
+  return MIDIGetNumberOfSources();
+}
+
+// This function was submitted by Douglas Casey Tucker and apparently
+// derived largely from PortMidi.
+CFStringRef EndpointName( MIDIEndpointRef endpoint, bool isExternal )
+{
+  CFMutableStringRef result = CFStringCreateMutable( NULL, 0 );
+  CFStringRef str;
+
+  // Begin with the endpoint's name.
+  str = NULL;
+  MIDIObjectGetStringProperty( endpoint, kMIDIPropertyName, &str );
+  if ( str != NULL ) {
+    CFStringAppend( result, str );
+    CFRelease( str );
+  }
+
+  MIDIEntityRef entity = NULL;
+  MIDIEndpointGetEntity( endpoint, &entity );
+  if ( entity == 0 )
+    // probably virtual
+    return result;
+
+  if ( CFStringGetLength( result ) == 0 ) {
+    // endpoint name has zero length -- try the entity
+    str = NULL;
+    MIDIObjectGetStringProperty( entity, kMIDIPropertyName, &str );
+    if ( str != NULL ) {
+      CFStringAppend( result, str );
+      CFRelease( str );
+    }
+  }
+  // now consider the device's name
+  MIDIDeviceRef device = 0;
+  MIDIEntityGetDevice( entity, &device );
+  if ( device == 0 )
+    return result;
+
+  str = NULL;
+  MIDIObjectGetStringProperty( device, kMIDIPropertyName, &str );
+  if ( CFStringGetLength( result ) == 0 ) {
+      CFRelease( result );
+      return str;
+  }
+  if ( str != NULL ) {
+    // if an external device has only one entity, throw away
+    // the endpoint name and just use the device name
+    if ( isExternal && MIDIDeviceGetNumberOfEntities( device ) < 2 ) {
+      CFRelease( result );
+      return str;
+    } else {
+      if ( CFStringGetLength( str ) == 0 ) {
+        CFRelease( str );
+        return result;
+      }
+      // does the entity name already start with the device name?
+      // (some drivers do this though they shouldn't)
+      // if so, do not prepend
+        if ( CFStringCompareWithOptions( result, /* endpoint name */
+             str /* device name */,
+             CFRangeMake(0, CFStringGetLength( str ) ), 0 ) != kCFCompareEqualTo ) {
+        // prepend the device name to the entity name
+        if ( CFStringGetLength( result ) > 0 )
+          CFStringInsert( result, 0, CFSTR(" ") );
+        CFStringInsert( result, 0, str );
+      }
+      CFRelease( str );
+    }
+  }
+  return result;
+}
+
+// This function was submitted by Douglas Casey Tucker and apparently
+// derived largely from PortMidi.
+static CFStringRef ConnectedEndpointName( MIDIEndpointRef endpoint )
+{
+  CFMutableStringRef result = CFStringCreateMutable( NULL, 0 );
+  CFStringRef str;
+  OSStatus err;
+  int i;
+
+  // Does the endpoint have connections?
+  CFDataRef connections = NULL;
+  int nConnected = 0;
+  bool anyStrings = false;
+  err = MIDIObjectGetDataProperty( endpoint, kMIDIPropertyConnectionUniqueID, &connections );
+  if ( connections != NULL ) {
+    // It has connections, follow them
+    // Concatenate the names of all connected devices
+    nConnected = CFDataGetLength( connections ) / sizeof(MIDIUniqueID);
+    if ( nConnected ) {
+      const SInt32 *pid = (const SInt32 *)(CFDataGetBytePtr(connections));
+      for ( i=0; i<nConnected; ++i, ++pid ) {
+        MIDIUniqueID id = EndianS32_BtoN( *pid );
+        MIDIObjectRef connObject;
+        MIDIObjectType connObjectType;
+        err = MIDIObjectFindByUniqueID( id, &connObject, &connObjectType );
+        if ( err == noErr ) {
+          if ( connObjectType == kMIDIObjectType_ExternalSource  ||
+              connObjectType == kMIDIObjectType_ExternalDestination ) {
+            // Connected to an external device's endpoint (10.3 and later).
+            str = EndpointName( (MIDIEndpointRef)(connObject), true );
+          } else {
+            // Connected to an external device (10.2) (or something else, catch-
+            str = NULL;
+            MIDIObjectGetStringProperty( connObject, kMIDIPropertyName, &str );
+          }
+          if ( str != NULL ) {
+            if ( anyStrings )
+              CFStringAppend( result, CFSTR(", ") );
+            else anyStrings = true;
+            CFStringAppend( result, str );
+            CFRelease( str );
+          }
+        }
+      }
+    }
+    CFRelease( connections );
+  }
+  if ( anyStrings )
+    return result;
+
+  // Here, either the endpoint had no connections, or we failed to obtain names 
+  return EndpointName( endpoint, false );
+}
+
+std::string MidiInCore :: getPortName( unsigned int portNumber )
+{
+  CFStringRef nameRef;
+  MIDIEndpointRef portRef;
+  std::ostringstream ost;
+  char name[128];
+
+  std::string stringName;
+  if ( portNumber >= MIDIGetNumberOfSources() ) {
+    ost << "MidiInCore::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+    //RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+    return stringName;
+  }
+
+  portRef = MIDIGetSource( portNumber );
+  nameRef = ConnectedEndpointName(portRef);
+  CFStringGetCString( nameRef, name, sizeof(name), 0);
+  CFRelease( nameRef );
+
+  return stringName = name;
+}
+
+//*********************************************************************//
+//  API: OS-X
+//  Class Definitions: MidiOutCore
+//*********************************************************************//
+
+MidiOutCore :: MidiOutCore( const std::string clientName ) : MidiOutApi()
+{
+  initialize( clientName );
+}
+
+MidiOutCore :: ~MidiOutCore( void )
+{
+  // Close a connection if it exists.
+  closePort();
+
+  // Cleanup.
+  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
+  MIDIClientDispose( data->client );
+  if ( data->endpoint ) MIDIEndpointDispose( data->endpoint );
+  delete data;
+}
+
+void MidiOutCore :: initialize( const std::string& clientName )
+{
+  // Set up our client.
+  MIDIClientRef client;
+  OSStatus result = MIDIClientCreate( CFStringCreateWithCString( NULL, clientName.c_str(), kCFStringEncodingASCII ), NULL, NULL, &client );
+  if ( result != noErr ) {
+    errorString_ = "MidiOutCore::initialize: error creating OS-X MIDI client object.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Save our api-specific connection information.
+  CoreMidiData *data = (CoreMidiData *) new CoreMidiData;
+  data->client = client;
+  data->endpoint = 0;
+  apiData_ = (void *) data;
+}
+
+unsigned int MidiOutCore :: getPortCount()
+{
+  return MIDIGetNumberOfDestinations();
+}
+
+std::string MidiOutCore :: getPortName( unsigned int portNumber )
+{
+  CFStringRef nameRef;
+  MIDIEndpointRef portRef;
+  std::ostringstream ost;
+  char name[128];
+
+  std::string stringName;
+  if ( portNumber >= MIDIGetNumberOfDestinations() ) {
+    ost << "MidiOutCore::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return stringName;
+    //RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+  }
+
+  portRef = MIDIGetDestination( portNumber );
+  nameRef = ConnectedEndpointName(portRef);
+  CFStringGetCString( nameRef, name, sizeof(name), 0);
+  CFRelease( nameRef );
+  
+  return stringName = name;
+}
+
+void MidiOutCore :: openPort( unsigned int portNumber, const std::string portName )
+{
+  if ( connected_ ) {
+    errorString_ = "MidiOutCore::openPort: a valid connection already exists!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  unsigned int nDest = MIDIGetNumberOfDestinations();
+  if (nDest < 1) {
+    errorString_ = "MidiOutCore::openPort: no MIDI output destinations found!";
+    RtMidi::error( RtError::NO_DEVICES_FOUND, errorString_ );
+  }
+
+  std::ostringstream ost;
+  if ( portNumber >= nDest ) {
+    ost << "MidiOutCore::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+  }
+
+  MIDIPortRef port;
+  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
+  OSStatus result = MIDIOutputPortCreate( data->client, 
+                                          CFStringCreateWithCString( NULL, portName.c_str(), kCFStringEncodingASCII ),
+                                          &port );
+  if ( result != noErr ) {
+    MIDIClientDispose( data->client );
+    errorString_ = "MidiOutCore::openPort: error creating OS-X MIDI output port.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Get the desired output port identifier.
+  MIDIEndpointRef destination = MIDIGetDestination( portNumber );
+  if ( destination == 0 ) {
+    MIDIPortDispose( port );
+    MIDIClientDispose( data->client );
+    errorString_ = "MidiOutCore::openPort: error getting MIDI output destination reference.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Save our api-specific connection information.
+  data->port = port;
+  data->destinationId = destination;
+  connected_ = true;
+}
+
+void MidiOutCore :: closePort( void )
+{
+  if ( connected_ ) {
+    CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
+    MIDIPortDispose( data->port );
+    connected_ = false;
+  }
+}
+
+void MidiOutCore :: openVirtualPort( std::string portName )
+{
+  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
+
+  if ( data->endpoint ) {
+    errorString_ = "MidiOutCore::openVirtualPort: a virtual output port already exists!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  // Create a virtual MIDI output source.
+  MIDIEndpointRef endpoint;
+  OSStatus result = MIDISourceCreate( data->client,
+                                      CFStringCreateWithCString( NULL, portName.c_str(), kCFStringEncodingASCII ),
+                                      &endpoint );
+  if ( result != noErr ) {
+    errorString_ = "MidiOutCore::initialize: error creating OS-X virtual MIDI source.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Save our api-specific connection information.
+  data->endpoint = endpoint;
+}
+
+char *sysexBuffer = 0;
+
+void sysexCompletionProc( MIDISysexSendRequest * sreq )
+{
+  //std::cout << "Completed SysEx send\n";
+ delete sysexBuffer;
+ sysexBuffer = 0;
+}
+
+void MidiOutCore :: sendMessage( std::vector<unsigned char> *message )
+{
+  // We use the MIDISendSysex() function to asynchronously send sysex
+  // messages.  Otherwise, we use a single CoreMidi MIDIPacket.
+  unsigned int nBytes = message->size();
+  if ( nBytes == 0 ) {
+    errorString_ = "MidiOutCore::sendMessage: no data in message argument!";      
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  //  unsigned int packetBytes, bytesLeft = nBytes;
+  //  unsigned int messageIndex = 0;
+  MIDITimeStamp timeStamp = AudioGetCurrentHostTime();
+  CoreMidiData *data = static_cast<CoreMidiData *> (apiData_);
+  OSStatus result;
+
+  if ( message->at(0) == 0xF0 ) {
+
+    while ( sysexBuffer != 0 ) usleep( 1000 ); // sleep 1 ms
+
+   sysexBuffer = new char[nBytes];
+   if ( sysexBuffer == NULL ) {
+     errorString_ = "MidiOutCore::sendMessage: error allocating sysex message memory!";
+     RtMidi::error( RtError::MEMORY_ERROR, errorString_ );
+   }
+
+   // Copy data to buffer.
+   for ( unsigned int i=0; i<nBytes; ++i ) sysexBuffer[i] = message->at(i);
+
+   data->sysexreq.destination = data->destinationId;
+   data->sysexreq.data = (Byte *)sysexBuffer;
+   data->sysexreq.bytesToSend = nBytes;
+   data->sysexreq.complete = 0;
+   data->sysexreq.completionProc = sysexCompletionProc;
+   data->sysexreq.completionRefCon = &(data->sysexreq);
+
+   result = MIDISendSysex( &(data->sysexreq) );
+   if ( result != noErr ) {
+     errorString_ = "MidiOutCore::sendMessage: error sending MIDI to virtual destinations.";
+     RtMidi::error( RtError::WARNING, errorString_ );
+   }
+   return;
+  }
+  else if ( nBytes > 3 ) {
+   errorString_ = "MidiOutCore::sendMessage: message format problem ... not sysex but > 3 bytes?";
+   RtMidi::error( RtError::WARNING, errorString_ );
+   return;
+  }
+
+  MIDIPacketList packetList;
+  MIDIPacket *packet = MIDIPacketListInit( &packetList );
+  packet = MIDIPacketListAdd( &packetList, sizeof(packetList), packet, timeStamp, nBytes, (const Byte *) &message->at( 0 ) );
+  if ( !packet ) {
+    errorString_ = "MidiOutCore::sendMessage: could not allocate packet list";      
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Send to any destinations that may have connected to us.
+  if ( data->endpoint ) {
+    result = MIDIReceived( data->endpoint, &packetList );
+    if ( result != noErr ) {
+      errorString_ = "MidiOutCore::sendMessage: error sending MIDI to virtual destinations.";
+      RtMidi::error( RtError::WARNING, errorString_ );
+    }
+  }
+
+  // And send to an explicit destination port if we're connected.
+  if ( connected_ ) {
+    result = MIDISend( data->port, data->destinationId, &packetList );
+    if ( result != noErr ) {
+      errorString_ = "MidiOutCore::sendMessage: error sending MIDI message to port.";
+      RtMidi::error( RtError::WARNING, errorString_ );
+    }
+  }
+
+}
+
+#endif  // __MACOSX_CORE__
+
+
+//*********************************************************************//
+//  API: LINUX ALSA SEQUENCER
+//*********************************************************************//
+
+// API information found at:
+//   - http://www.alsa-project.org/documentation.php#Library
+
+#if defined(__LINUX_ALSA__)
+
+// The ALSA Sequencer API is based on the use of a callback function for
+// MIDI input.
+//
+// Thanks to Pedro Lopez-Cabanillas for help with the ALSA sequencer
+// time stamps and other assorted fixes!!!
+
+// If you don't need timestamping for incoming MIDI events, define the
+// preprocessor definition AVOID_TIMESTAMPING to save resources
+// associated with the ALSA sequencer queues.
+
+#include <pthread.h>
+#include <sys/time.h>
+
+// ALSA header file.
+#include <alsa/asoundlib.h>
+
+// Global sequencer instance created when first In/Out object is
+// created, then destroyed when last In/Out is deleted.
+static snd_seq_t *s_seq = NULL;
+
+// Variable to keep track of how many ports are open.
+static unsigned int s_numPorts = 0;
+
+// The client name to use when creating the sequencer, which is
+// currently set on the first call to createSequencer.
+static std::string s_clientName = "RtMidi Client";
+
+// A structure to hold variables related to the ALSA API
+// implementation.
+struct AlsaMidiData {
+  snd_seq_t *seq;
+  unsigned int portNum;
+  int vport;
+  snd_seq_port_subscribe_t *subscription;
+  snd_midi_event_t *coder;
+  unsigned int bufferSize;
+  unsigned char *buffer;
+  pthread_t thread;
+  pthread_t dummy_thread_id;
+  unsigned long long lastTime;
+  int queue_id; // an input queue is needed to get timestamped events
+  int trigger_fds[2];
+};
+
+#define PORT_TYPE( pinfo, bits ) ((snd_seq_port_info_get_capability(pinfo) & (bits)) == (bits))
+
+snd_seq_t* createSequencer( const std::string& clientName )
+{
+  // Set up the ALSA sequencer client.
+  if ( s_seq == NULL ) {
+    int result = snd_seq_open(&s_seq, "default", SND_SEQ_OPEN_DUPLEX, SND_SEQ_NONBLOCK);
+    if ( result < 0 ) {
+      s_seq = NULL;
+    }
+    else {
+      // Set client name, use current name if given string is empty.
+      if ( clientName != "" ) {
+        s_clientName = clientName;
+      }
+      snd_seq_set_client_name( s_seq, s_clientName.c_str() );
+    }
+  }
+
+  // Increment port count.
+  s_numPorts++;
+
+  return s_seq;
+}
+
+void freeSequencer ( void )
+{
+  s_numPorts--;
+  if ( s_numPorts == 0 && s_seq != NULL ) {
+    snd_seq_close( s_seq );
+    s_seq = NULL;
+  }
+}
+
+//*********************************************************************//
+//  API: LINUX ALSA
+//  Class Definitions: MidiInAlsa
+//*********************************************************************//
+
+extern "C" void *alsaMidiHandler( void *ptr )
+{
+  MidiInApi::RtMidiInData *data = static_cast<MidiInApi::RtMidiInData *> (ptr);
+  AlsaMidiData *apiData = static_cast<AlsaMidiData *> (data->apiData);
+
+  long nBytes;
+  unsigned long long time, lastTime;
+  bool continueSysex = false;
+  bool doDecode = false;
+  MidiInApi::MidiMessage message;
+  int poll_fd_count;
+  struct pollfd *poll_fds;
+
+  snd_seq_event_t *ev;
+  int result;
+  apiData->bufferSize = 32;
+  result = snd_midi_event_new( 0, &apiData->coder );
+  if ( result < 0 ) {
+    data->doInput = false;
+    std::cerr << "\nMidiInAlsa::alsaMidiHandler: error initializing MIDI event parser!\n\n";
+    return 0;
+  }
+  unsigned char *buffer = (unsigned char *) malloc( apiData->bufferSize );
+  if ( buffer == NULL ) {
+    data->doInput = false;
+    snd_midi_event_free( apiData->coder );
+    apiData->coder = 0;
+    std::cerr << "\nMidiInAlsa::alsaMidiHandler: error initializing buffer memory!\n\n";
+    return 0;
+  }
+  snd_midi_event_init( apiData->coder );
+  snd_midi_event_no_status( apiData->coder, 1 ); // suppress running status messages
+
+  poll_fd_count = snd_seq_poll_descriptors_count( apiData->seq, POLLIN ) + 1;
+  poll_fds = (struct pollfd*)alloca( poll_fd_count * sizeof( struct pollfd ));
+  snd_seq_poll_descriptors( apiData->seq, poll_fds + 1, poll_fd_count - 1, POLLIN );
+  poll_fds[0].fd = apiData->trigger_fds[0];
+  poll_fds[0].events = POLLIN;
+
+  while ( data->doInput ) {
+
+    if ( snd_seq_event_input_pending( apiData->seq, 1 ) == 0 ) {
+      // No data pending
+      if ( poll( poll_fds, poll_fd_count, -1) >= 0 ) {
+        if ( poll_fds[0].revents & POLLIN ) {
+          bool dummy;
+          int res = read( poll_fds[0].fd, &dummy, sizeof(dummy) );
+          (void) res;
+        }
+      }
+      continue;
+    }
+
+    // If here, there should be data.
+    result = snd_seq_event_input( apiData->seq, &ev );
+    if ( result == -ENOSPC ) {
+      std::cerr << "\nMidiInAlsa::alsaMidiHandler: MIDI input buffer overrun!\n\n";
+      continue;
+    }
+    else if ( result <= 0 ) {
+      std::cerr << "MidiInAlsa::alsaMidiHandler: unknown MIDI input error!\n";
+      continue;
+    }
+
+    // This is a bit weird, but we now have to decode an ALSA MIDI
+    // event (back) into MIDI bytes.  We'll ignore non-MIDI types.
+    if ( !continueSysex ) message.bytes.clear();
+
+    doDecode = false;
+    switch ( ev->type ) {
+
+		case SND_SEQ_EVENT_PORT_SUBSCRIBED:
+#if defined(__RTMIDI_DEBUG__)
+      std::cout << "MidiInAlsa::alsaMidiHandler: port connection made!\n";
+#endif
+      break;
+
+		case SND_SEQ_EVENT_PORT_UNSUBSCRIBED:
+#if defined(__RTMIDI_DEBUG__)
+      std::cerr << "MidiInAlsa::alsaMidiHandler: port connection has closed!\n";
+      std::cout << "sender = " << (int) ev->data.connect.sender.client << ":"
+                << (int) ev->data.connect.sender.port
+                << ", dest = " << (int) ev->data.connect.dest.client << ":"
+                << (int) ev->data.connect.dest.port
+                << std::endl;
+#endif
+      break;
+
+    case SND_SEQ_EVENT_QFRAME: // MIDI time code
+      if ( !( data->ignoreFlags & 0x02 ) ) doDecode = true;
+      break;
+
+    case SND_SEQ_EVENT_TICK: // MIDI timing tick
+      if ( !( data->ignoreFlags & 0x02 ) ) doDecode = true;
+      break;
+
+    case SND_SEQ_EVENT_SENSING: // Active sensing
+      if ( !( data->ignoreFlags & 0x04 ) ) doDecode = true;
+      break;
+
+		case SND_SEQ_EVENT_SYSEX:
+      if ( (data->ignoreFlags & 0x01) ) break;
+      if ( ev->data.ext.len > apiData->bufferSize ) {
+        apiData->bufferSize = ev->data.ext.len;
+        free( buffer );
+        buffer = (unsigned char *) malloc( apiData->bufferSize );
+        if ( buffer == NULL ) {
+          data->doInput = false;
+          std::cerr << "\nMidiInAlsa::alsaMidiHandler: error resizing buffer memory!\n\n";
+          break;
+        }
+      }
+
+    default:
+      doDecode = true;
+    }
+
+    if ( doDecode ) {
+
+      nBytes = snd_midi_event_decode( apiData->coder, buffer, apiData->bufferSize, ev );
+      if ( nBytes > 0 ) {
+        // The ALSA sequencer has a maximum buffer size for MIDI sysex
+        // events of 256 bytes.  If a device sends sysex messages larger
+        // than this, they are segmented into 256 byte chunks.  So,
+        // we'll watch for this and concatenate sysex chunks into a
+        // single sysex message if necessary.
+        if ( !continueSysex )
+          message.bytes.assign( buffer, &buffer[nBytes] );
+        else
+          message.bytes.insert( message.bytes.end(), buffer, &buffer[nBytes] );
+
+        continueSysex = ( ( ev->type == SND_SEQ_EVENT_SYSEX ) && ( message.bytes.back() != 0xF7 ) );
+        if ( !continueSysex ) {
+
+          // Calculate the time stamp:
+          message.timeStamp = 0.0;
+
+          // Method 1: Use the system time.
+          //(void)gettimeofday(&tv, (struct timezone *)NULL);
+          //time = (tv.tv_sec * 1000000) + tv.tv_usec;
+
+          // Method 2: Use the ALSA sequencer event time data.
+          // (thanks to Pedro Lopez-Cabanillas!).
+          time = ( ev->time.time.tv_sec * 1000000 ) + ( ev->time.time.tv_nsec/1000 );
+          lastTime = time;
+          time -= apiData->lastTime;
+          apiData->lastTime = lastTime;
+          if ( data->firstMessage == true )
+            data->firstMessage = false;
+          else
+            message.timeStamp = time * 0.000001;
+        }
+        else {
+#if defined(__RTMIDI_DEBUG__)
+          std::cerr << "\nMidiInAlsa::alsaMidiHandler: event parsing error or not a MIDI event!\n\n";
+#endif
+        }
+      }
+    }
+
+    snd_seq_free_event( ev );
+    if ( message.bytes.size() == 0 || continueSysex ) continue;
+
+    if ( data->usingCallback ) {
+      RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
+      callback( message.timeStamp, &message.bytes, data->userData );
+    }
+    else {
+      // As long as we haven't reached our queue size limit, push the message.
+      if ( data->queue.size < data->queue.ringSize ) {
+        data->queue.ring[data->queue.back++] = message;
+        if ( data->queue.back == data->queue.ringSize )
+          data->queue.back = 0;
+        data->queue.size++;
+      }
+      else
+        std::cerr << "\nMidiInAlsa: message queue limit reached!!\n\n";
+    }
+  }
+
+  if ( buffer ) free( buffer );
+  snd_midi_event_free( apiData->coder );
+  apiData->coder = 0;
+  apiData->thread = apiData->dummy_thread_id;
+  return 0;
+}
+
+MidiInAlsa :: MidiInAlsa( const std::string clientName, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit )
+{
+  initialize( clientName );
+}
+
+MidiInAlsa :: ~MidiInAlsa()
+{
+  // Close a connection if it exists.
+  closePort();
+
+  // Shutdown the input thread.
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  if ( inputData_.doInput ) {
+    inputData_.doInput = false;
+    int res = write( data->trigger_fds[1], &inputData_.doInput, sizeof(inputData_.doInput) );
+    (void) res;
+    if ( !pthread_equal(data->thread, data->dummy_thread_id) )
+      pthread_join( data->thread, NULL );
+  }
+
+  // Cleanup.
+  close ( data->trigger_fds[0] );
+  close ( data->trigger_fds[1] );
+  if ( data->vport >= 0 ) snd_seq_delete_port( data->seq, data->vport );
+#ifndef AVOID_TIMESTAMPING
+  snd_seq_free_queue( data->seq, data->queue_id );
+#endif
+  freeSequencer();
+  delete data;
+}
+
+void MidiInAlsa :: initialize( const std::string& clientName )
+{
+  snd_seq_t* seq = createSequencer( clientName );
+  if ( seq == NULL ) {
+    s_seq = NULL;
+    errorString_ = "MidiInAlsa::initialize: error creating ALSA sequencer client object.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Save our api-specific connection information.
+  AlsaMidiData *data = (AlsaMidiData *) new AlsaMidiData;
+  data->seq = seq;
+  data->portNum = -1;
+  data->vport = -1;
+  data->subscription = 0;
+  data->dummy_thread_id = pthread_self();
+  data->thread = data->dummy_thread_id;
+  data->trigger_fds[0] = -1;
+  data->trigger_fds[1] = -1;
+  apiData_ = (void *) data;
+  inputData_.apiData = (void *) data;
+
+   if ( pipe(data->trigger_fds) == -1 ) {
+    errorString_ = "MidiInAlsa::initialize: error creating pipe objects.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Create the input queue
+#ifndef AVOID_TIMESTAMPING
+  data->queue_id = snd_seq_alloc_named_queue(s_seq, "RtMidi Queue");
+  // Set arbitrary tempo (mm=100) and resolution (240)
+  snd_seq_queue_tempo_t *qtempo;
+  snd_seq_queue_tempo_alloca(&qtempo);
+  snd_seq_queue_tempo_set_tempo(qtempo, 600000);
+  snd_seq_queue_tempo_set_ppq(qtempo, 240);
+  snd_seq_set_queue_tempo(data->seq, data->queue_id, qtempo);
+  snd_seq_drain_output(data->seq);
+#endif
+}
+
+// This function is used to count or get the pinfo structure for a given port number.
+unsigned int portInfo( snd_seq_t *seq, snd_seq_port_info_t *pinfo, unsigned int type, int portNumber )
+{
+  snd_seq_client_info_t *cinfo;
+  int client;
+  int count = 0;
+  snd_seq_client_info_alloca( &cinfo );
+
+  snd_seq_client_info_set_client( cinfo, -1 );
+  while ( snd_seq_query_next_client( seq, cinfo ) >= 0 ) {
+    client = snd_seq_client_info_get_client( cinfo );
+    if ( client == 0 ) continue;
+    // Reset query info
+    snd_seq_port_info_set_client( pinfo, client );
+    snd_seq_port_info_set_port( pinfo, -1 );
+    while ( snd_seq_query_next_port( seq, pinfo ) >= 0 ) {
+      unsigned int atyp = snd_seq_port_info_get_type( pinfo );
+      if ( ( atyp & SND_SEQ_PORT_TYPE_MIDI_GENERIC ) == 0 ) continue;
+      unsigned int caps = snd_seq_port_info_get_capability( pinfo );
+      if ( ( caps & type ) != type ) continue;
+      if ( count == portNumber ) return 1;
+      ++count;
+    }
+  }
+
+  // If a negative portNumber was used, return the port count.
+  if ( portNumber < 0 ) return count;
+  return 0;
+}
+
+unsigned int MidiInAlsa :: getPortCount()
+{
+  snd_seq_port_info_t *pinfo;
+  snd_seq_port_info_alloca( &pinfo );
+
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  return portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ, -1 );
+}
+
+std::string MidiInAlsa :: getPortName( unsigned int portNumber )
+{
+  snd_seq_client_info_t *cinfo;
+  snd_seq_port_info_t *pinfo;
+  snd_seq_client_info_alloca( &cinfo );
+  snd_seq_port_info_alloca( &pinfo );
+
+  std::string stringName;
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  if ( portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ, (int) portNumber ) ) {
+    int cnum = snd_seq_port_info_get_client( pinfo );
+    snd_seq_get_any_client_info( data->seq, cnum, cinfo );
+    std::ostringstream os;
+    os << snd_seq_client_info_get_name( cinfo );
+    os << " ";                                    // GO: These lines added to make sure devices are listed
+    os << snd_seq_port_info_get_client( pinfo );  // GO: with full portnames added to ensure individual device names
+    os << ":";
+    os << snd_seq_port_info_get_port( pinfo );
+    stringName = os.str();
+    return stringName;
+  }
+
+  // If we get here, we didn't find a match.
+  errorString_ = "MidiInAlsa::getPortName: error looking for port name!";
+  RtMidi::error( RtError::WARNING, errorString_ );
+  return stringName;
+  //RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+}
+
+void MidiInAlsa :: openPort( unsigned int portNumber, const std::string portName )
+{
+  if ( connected_ ) {
+    errorString_ = "MidiInAlsa::openPort: a valid connection already exists!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  unsigned int nSrc = this->getPortCount();
+  if (nSrc < 1) {
+    errorString_ = "MidiInAlsa::openPort: no MIDI input sources found!";
+    RtMidi::error( RtError::NO_DEVICES_FOUND, errorString_ );
+  }
+
+  snd_seq_port_info_t *pinfo;
+  snd_seq_port_info_alloca( &pinfo );
+  std::ostringstream ost;
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  if ( portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ, (int) portNumber ) == 0 ) {
+    ost << "MidiInAlsa::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+  }
+
+
+  snd_seq_addr_t sender, receiver;
+  sender.client = snd_seq_port_info_get_client( pinfo );
+  sender.port = snd_seq_port_info_get_port( pinfo );
+  receiver.client = snd_seq_client_id( data->seq );
+  if ( data->vport < 0 ) {
+    snd_seq_port_info_set_client( pinfo, 0 );
+    snd_seq_port_info_set_port( pinfo, 0 );
+    snd_seq_port_info_set_capability( pinfo,
+                                      SND_SEQ_PORT_CAP_WRITE |
+                                      SND_SEQ_PORT_CAP_SUBS_WRITE );
+    snd_seq_port_info_set_type( pinfo,
+                                SND_SEQ_PORT_TYPE_MIDI_GENERIC |
+                                SND_SEQ_PORT_TYPE_APPLICATION );
+    snd_seq_port_info_set_midi_channels(pinfo, 16);
+#ifndef AVOID_TIMESTAMPING
+    snd_seq_port_info_set_timestamping(pinfo, 1);
+    snd_seq_port_info_set_timestamp_real(pinfo, 1);    
+    snd_seq_port_info_set_timestamp_queue(pinfo, data->queue_id);
+#endif
+    snd_seq_port_info_set_name(pinfo,  portName.c_str() );
+    data->vport = snd_seq_create_port(data->seq, pinfo);
+  
+    if ( data->vport < 0 ) {
+      errorString_ = "MidiInAlsa::openPort: ALSA error creating input port.";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+  }
+
+  receiver.port = data->vport;
+
+  if ( !data->subscription ) {
+    // Make subscription
+    if (snd_seq_port_subscribe_malloc( &data->subscription ) < 0) {
+      errorString_ = "MidiInAlsa::openPort: ALSA error allocation port subscription.";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+    snd_seq_port_subscribe_set_sender(data->subscription, &sender);
+    snd_seq_port_subscribe_set_dest(data->subscription, &receiver);
+    if ( snd_seq_subscribe_port(data->seq, data->subscription) ) {
+      snd_seq_port_subscribe_free( data->subscription );
+      data->subscription = 0;
+      errorString_ = "MidiInAlsa::openPort: ALSA error making port connection.";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+  }
+
+  if ( inputData_.doInput == false ) {
+    // Start the input queue
+#ifndef AVOID_TIMESTAMPING
+    snd_seq_start_queue( data->seq, data->queue_id, NULL );
+    snd_seq_drain_output( data->seq );
+#endif
+    // Start our MIDI input thread.
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+    pthread_attr_setschedpolicy(&attr, SCHED_OTHER);
+
+    inputData_.doInput = true;
+    int err = pthread_create(&data->thread, &attr, alsaMidiHandler, &inputData_);
+    pthread_attr_destroy(&attr);
+    if ( err ) {
+      snd_seq_unsubscribe_port( data->seq, data->subscription );
+      snd_seq_port_subscribe_free( data->subscription );
+      data->subscription = 0;
+      inputData_.doInput = false;
+      errorString_ = "MidiInAlsa::openPort: error starting MIDI input thread!";
+      RtMidi::error( RtError::THREAD_ERROR, errorString_ );
+    }
+  }
+
+  connected_ = true;
+}
+
+void MidiInAlsa :: openVirtualPort( std::string portName )
+{
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  if ( data->vport < 0 ) {
+    snd_seq_port_info_t *pinfo;
+    snd_seq_port_info_alloca( &pinfo );
+    snd_seq_port_info_set_capability( pinfo,
+				      SND_SEQ_PORT_CAP_WRITE |
+				      SND_SEQ_PORT_CAP_SUBS_WRITE );
+    snd_seq_port_info_set_type( pinfo,
+				SND_SEQ_PORT_TYPE_MIDI_GENERIC |
+				SND_SEQ_PORT_TYPE_APPLICATION );
+    snd_seq_port_info_set_midi_channels(pinfo, 16);
+#ifndef AVOID_TIMESTAMPING
+    snd_seq_port_info_set_timestamping(pinfo, 1);
+    snd_seq_port_info_set_timestamp_real(pinfo, 1);    
+    snd_seq_port_info_set_timestamp_queue(pinfo, data->queue_id);
+#endif
+    snd_seq_port_info_set_name(pinfo, portName.c_str());
+    data->vport = snd_seq_create_port(data->seq, pinfo);
+
+    if ( data->vport < 0 ) {
+      errorString_ = "MidiInAlsa::openVirtualPort: ALSA error creating virtual port.";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+  }
+
+  if ( inputData_.doInput == false ) {
+    // Wait for old thread to stop, if still running
+    if ( !pthread_equal(data->thread, data->dummy_thread_id) )
+      pthread_join( data->thread, NULL );
+
+    // Start the input queue
+#ifndef AVOID_TIMESTAMPING
+    snd_seq_start_queue( data->seq, data->queue_id, NULL );
+    snd_seq_drain_output( data->seq );
+#endif
+    // Start our MIDI input thread.
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+    pthread_attr_setschedpolicy(&attr, SCHED_OTHER);
+
+    inputData_.doInput = true;
+    int err = pthread_create(&data->thread, &attr, alsaMidiHandler, &inputData_);
+    pthread_attr_destroy(&attr);
+    if ( err ) {
+      if ( data->subscription ) {
+        snd_seq_unsubscribe_port( data->seq, data->subscription );
+        snd_seq_port_subscribe_free( data->subscription );
+        data->subscription = 0;
+      }
+      inputData_.doInput = false;
+      errorString_ = "MidiInAlsa::openPort: error starting MIDI input thread!";
+      RtMidi::error( RtError::THREAD_ERROR, errorString_ );
+    }
+  }
+}
+
+void MidiInAlsa :: closePort( void )
+{
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+
+  if ( connected_ ) {
+    if ( data->subscription ) {
+      snd_seq_unsubscribe_port( data->seq, data->subscription );
+      snd_seq_port_subscribe_free( data->subscription );
+      data->subscription = 0;
+    }
+    // Stop the input queue
+#ifndef AVOID_TIMESTAMPING
+    snd_seq_stop_queue( data->seq, data->queue_id, NULL );
+    snd_seq_drain_output( data->seq );
+#endif
+    connected_ = false;
+  }
+
+  // Stop thread to avoid triggering the callback, while the port is intended to be closed
+  if ( inputData_.doInput ) {
+    inputData_.doInput = false;
+    int res = write( data->trigger_fds[1], &inputData_.doInput, sizeof(inputData_.doInput) );
+    (void) res;
+    if ( !pthread_equal(data->thread, data->dummy_thread_id) )
+      pthread_join( data->thread, NULL );
+  }
+}
+
+//*********************************************************************//
+//  API: LINUX ALSA
+//  Class Definitions: MidiOutAlsa
+//*********************************************************************//
+
+MidiOutAlsa :: MidiOutAlsa( const std::string clientName ) : MidiOutApi()
+{
+  initialize( clientName );
+}
+
+MidiOutAlsa :: ~MidiOutAlsa()
+{
+  // Close a connection if it exists.
+  closePort();
+
+  // Cleanup.
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  if ( data->vport >= 0 ) snd_seq_delete_port( data->seq, data->vport );
+  if ( data->coder ) snd_midi_event_free( data->coder );
+  if ( data->buffer ) free( data->buffer );
+  freeSequencer();
+  delete data;
+}
+
+void MidiOutAlsa :: initialize( const std::string& clientName )
+{
+  snd_seq_t* seq = createSequencer( clientName );
+  if ( seq == NULL ) {
+    s_seq = NULL;
+    errorString_ = "MidiOutAlsa::initialize: error creating ALSA sequencer client object.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+	}
+
+  // Save our api-specific connection information.
+  AlsaMidiData *data = (AlsaMidiData *) new AlsaMidiData;
+  data->seq = seq;
+  data->portNum = -1;
+  data->vport = -1;
+  data->bufferSize = 32;
+  data->coder = 0;
+  data->buffer = 0;
+  int result = snd_midi_event_new( data->bufferSize, &data->coder );
+  if ( result < 0 ) {
+    delete data;
+    errorString_ = "MidiOutAlsa::initialize: error initializing MIDI event parser!\n\n";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+  data->buffer = (unsigned char *) malloc( data->bufferSize );
+  if ( data->buffer == NULL ) {
+    delete data;
+    errorString_ = "MidiOutAlsa::initialize: error allocating buffer memory!\n\n";
+    RtMidi::error( RtError::MEMORY_ERROR, errorString_ );
+  }
+  snd_midi_event_init( data->coder );
+  apiData_ = (void *) data;
+}
+
+unsigned int MidiOutAlsa :: getPortCount()
+{
+	snd_seq_port_info_t *pinfo;
+	snd_seq_port_info_alloca( &pinfo );
+
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  return portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_WRITE|SND_SEQ_PORT_CAP_SUBS_WRITE, -1 );
+}
+
+std::string MidiOutAlsa :: getPortName( unsigned int portNumber )
+{
+  snd_seq_client_info_t *cinfo;
+  snd_seq_port_info_t *pinfo;
+  snd_seq_client_info_alloca( &cinfo );
+  snd_seq_port_info_alloca( &pinfo );
+
+  std::string stringName;
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  if ( portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_WRITE|SND_SEQ_PORT_CAP_SUBS_WRITE, (int) portNumber ) ) {
+    int cnum = snd_seq_port_info_get_client(pinfo);
+    snd_seq_get_any_client_info( data->seq, cnum, cinfo );
+    std::ostringstream os;
+    os << snd_seq_client_info_get_name(cinfo);
+    os << ":";
+    os << snd_seq_port_info_get_port(pinfo);
+    stringName = os.str();
+    return stringName;
+  }
+
+  // If we get here, we didn't find a match.
+  errorString_ = "MidiOutAlsa::getPortName: error looking for port name!";
+  //RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+  RtMidi::error( RtError::WARNING, errorString_ );
+  return stringName;
+}
+
+void MidiOutAlsa :: openPort( unsigned int portNumber, const std::string portName )
+{
+  if ( connected_ ) {
+    errorString_ = "MidiOutAlsa::openPort: a valid connection already exists!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  unsigned int nSrc = this->getPortCount();
+  if (nSrc < 1) {
+    errorString_ = "MidiOutAlsa::openPort: no MIDI output sources found!";
+    RtMidi::error( RtError::NO_DEVICES_FOUND, errorString_ );
+  }
+
+	snd_seq_port_info_t *pinfo;
+	snd_seq_port_info_alloca( &pinfo );
+  std::ostringstream ost;
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  if ( portInfo( data->seq, pinfo, SND_SEQ_PORT_CAP_WRITE|SND_SEQ_PORT_CAP_SUBS_WRITE, (int) portNumber ) == 0 ) {
+    ost << "MidiOutAlsa::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+  }
+
+  snd_seq_addr_t sender, receiver;
+  receiver.client = snd_seq_port_info_get_client( pinfo );
+  receiver.port = snd_seq_port_info_get_port( pinfo );
+  sender.client = snd_seq_client_id( data->seq );
+
+  if ( data->vport < 0 ) {
+    data->vport = snd_seq_create_simple_port( data->seq, portName.c_str(),
+                                              SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ,
+                                              SND_SEQ_PORT_TYPE_MIDI_GENERIC|SND_SEQ_PORT_TYPE_APPLICATION );
+    if ( data->vport < 0 ) {
+      errorString_ = "MidiOutAlsa::openPort: ALSA error creating output port.";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+  }
+
+  sender.port = data->vport;
+
+  // Make subscription
+  if (snd_seq_port_subscribe_malloc( &data->subscription ) < 0) {
+    snd_seq_port_subscribe_free( data->subscription );
+    errorString_ = "MidiOutAlsa::openPort: error allocation port subscribtion.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+  snd_seq_port_subscribe_set_sender(data->subscription, &sender);
+  snd_seq_port_subscribe_set_dest(data->subscription, &receiver);
+  snd_seq_port_subscribe_set_time_update(data->subscription, 1);
+  snd_seq_port_subscribe_set_time_real(data->subscription, 1);
+  if ( snd_seq_subscribe_port(data->seq, data->subscription) ) {
+    snd_seq_port_subscribe_free( data->subscription );
+    errorString_ = "MidiOutAlsa::openPort: ALSA error making port connection.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  connected_ = true;
+}
+
+void MidiOutAlsa :: closePort( void )
+{
+  if ( connected_ ) {
+    AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+    snd_seq_unsubscribe_port( data->seq, data->subscription );
+    snd_seq_port_subscribe_free( data->subscription );
+    connected_ = false;
+  }
+}
+
+void MidiOutAlsa :: openVirtualPort( std::string portName )
+{
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  if ( data->vport < 0 ) {
+    data->vport = snd_seq_create_simple_port( data->seq, portName.c_str(),
+                                              SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ,
+                                              SND_SEQ_PORT_TYPE_MIDI_GENERIC|SND_SEQ_PORT_TYPE_APPLICATION );
+
+    if ( data->vport < 0 ) {
+      errorString_ = "MidiOutAlsa::openVirtualPort: ALSA error creating virtual port.";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+  }
+}
+
+void MidiOutAlsa :: sendMessage( std::vector<unsigned char> *message )
+{
+  int result;
+  AlsaMidiData *data = static_cast<AlsaMidiData *> (apiData_);
+  unsigned int nBytes = message->size();
+  if ( nBytes > data->bufferSize ) {
+    data->bufferSize = nBytes;
+    result = snd_midi_event_resize_buffer ( data->coder, nBytes);
+    if ( result != 0 ) {
+      errorString_ = "MidiOutAlsa::sendMessage: ALSA error resizing MIDI event buffer.";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+    free (data->buffer);
+    data->buffer = (unsigned char *) malloc( data->bufferSize );
+    if ( data->buffer == NULL ) {
+    errorString_ = "MidiOutAlsa::initialize: error allocating buffer memory!\n\n";
+    RtMidi::error( RtError::MEMORY_ERROR, errorString_ );
+    }
+  }
+
+  snd_seq_event_t ev;
+  snd_seq_ev_clear(&ev);
+  snd_seq_ev_set_source(&ev, data->vport);
+  snd_seq_ev_set_subs(&ev);
+  snd_seq_ev_set_direct(&ev);
+  for ( unsigned int i=0; i<nBytes; ++i ) data->buffer[i] = message->at(i);
+  result = snd_midi_event_encode( data->coder, data->buffer, (long)nBytes, &ev );
+  if ( result < (int)nBytes ) {
+    errorString_ = "MidiOutAlsa::sendMessage: event parsing error!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  // Send the event.
+  result = snd_seq_event_output(data->seq, &ev);
+  if ( result < 0 ) {
+    errorString_ = "MidiOutAlsa::sendMessage: error sending MIDI message to port.";
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+  snd_seq_drain_output(data->seq);
+}
+
+#endif // __LINUX_ALSA__
+
+
+//*********************************************************************//
+//  API: Windows Multimedia Library (MM)
+//*********************************************************************//
+
+// API information deciphered from:
+//  - http://msdn.microsoft.com/library/default.asp?url=/library/en-us/multimed/htm/_win32_midi_reference.asp
+
+// Thanks to Jean-Baptiste Berruchon for the sysex code.
+
+#if defined(__WINDOWS_MM__)
+
+// The Windows MM API is based on the use of a callback function for
+// MIDI input.  We convert the system specific time stamps to delta
+// time values.
+
+// Windows MM MIDI header files.
+#include <windows.h>
+#include <mmsystem.h>
+
+#define  RT_SYSEX_BUFFER_SIZE 1024
+#define  RT_SYSEX_BUFFER_COUNT 4
+
+// A structure to hold variables related to the CoreMIDI API
+// implementation.
+struct WinMidiData {
+  HMIDIIN inHandle;    // Handle to Midi Input Device
+  HMIDIOUT outHandle;  // Handle to Midi Output Device
+  DWORD lastTime;
+  MidiInApi::MidiMessage message;
+  LPMIDIHDR sysexBuffer[RT_SYSEX_BUFFER_COUNT];
+};
+
+//*********************************************************************//
+//  API: Windows MM
+//  Class Definitions: MidiInWinMM
+//*********************************************************************//
+
+static void CALLBACK midiInputCallback( HMIDIIN hmin,
+                                        UINT inputStatus, 
+                                        DWORD_PTR instancePtr,
+                                        DWORD_PTR midiMessage,
+                                        DWORD timestamp )
+{
+  if ( inputStatus != MIM_DATA && inputStatus != MIM_LONGDATA && inputStatus != MIM_LONGERROR ) return;
+
+  //MidiInApi::RtMidiInData *data = static_cast<MidiInApi::RtMidiInData *> (instancePtr);
+  MidiInApi::RtMidiInData *data = (MidiInApi::RtMidiInData *)instancePtr;
+  WinMidiData *apiData = static_cast<WinMidiData *> (data->apiData);
+
+  // Calculate time stamp.
+  if ( data->firstMessage == true ) {
+    apiData->message.timeStamp = 0.0;
+    data->firstMessage = false;
+  }
+  else apiData->message.timeStamp = (double) ( timestamp - apiData->lastTime ) * 0.001;
+  apiData->lastTime = timestamp;
+
+  if ( inputStatus == MIM_DATA ) { // Channel or system message
+
+    // Make sure the first byte is a status byte.
+    unsigned char status = (unsigned char) (midiMessage & 0x000000FF);
+    if ( !(status & 0x80) ) return;
+
+    // Determine the number of bytes in the MIDI message.
+    unsigned short nBytes = 1;
+    if ( status < 0xC0 ) nBytes = 3;
+    else if ( status < 0xE0 ) nBytes = 2;
+    else if ( status < 0xF0 ) nBytes = 3;
+    else if ( status == 0xF1 ) {
+      if ( data->ignoreFlags & 0x02 ) return;
+      else nBytes = 2;
+    }
+    else if ( status == 0xF2 ) nBytes = 3;
+    else if ( status == 0xF3 ) nBytes = 2;
+    else if ( status == 0xF8 && (data->ignoreFlags & 0x02) ) {
+      // A MIDI timing tick message and we're ignoring it.
+      return;
+    }
+    else if ( status == 0xFE && (data->ignoreFlags & 0x04) ) {
+      // A MIDI active sensing message and we're ignoring it.
+      return;
+    }
+
+    // Copy bytes to our MIDI message.
+    unsigned char *ptr = (unsigned char *) &midiMessage;
+    for ( int i=0; i<nBytes; ++i ) apiData->message.bytes.push_back( *ptr++ );
+  }
+  else { // Sysex message ( MIM_LONGDATA or MIM_LONGERROR )
+    MIDIHDR *sysex = ( MIDIHDR *) midiMessage; 
+    if ( !( data->ignoreFlags & 0x01 ) && inputStatus != MIM_LONGERROR ) {  
+      // Sysex message and we're not ignoring it
+      for ( int i=0; i<(int)sysex->dwBytesRecorded; ++i )
+        apiData->message.bytes.push_back( sysex->lpData[i] );
+    }
+
+    // The WinMM API requires that the sysex buffer be requeued after
+    // input of each sysex message.  Even if we are ignoring sysex
+    // messages, we still need to requeue the buffer in case the user
+    // decides to not ignore sysex messages in the future.  However,
+    // it seems that WinMM calls this function with an empty sysex
+    // buffer when an application closes and in this case, we should
+    // avoid requeueing it, else the computer suddenly reboots after
+    // one or two minutes.
+	if ( apiData->sysexBuffer[sysex->dwUser]->dwBytesRecorded > 0 ) {
+    //if ( sysex->dwBytesRecorded > 0 ) {
+      MMRESULT result = midiInAddBuffer( apiData->inHandle, apiData->sysexBuffer[sysex->dwUser], sizeof(MIDIHDR) );
+      if ( result != MMSYSERR_NOERROR )
+        std::cerr << "\nRtMidiIn::midiInputCallback: error sending sysex to Midi device!!\n\n";
+
+      if ( data->ignoreFlags & 0x01 ) return;
+    }
+    else return;
+  }
+
+  if ( data->usingCallback ) {
+    RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) data->userCallback;
+    callback( apiData->message.timeStamp, &apiData->message.bytes, data->userData );
+  }
+  else {
+    // As long as we haven't reached our queue size limit, push the message.
+    if ( data->queue.size < data->queue.ringSize ) {
+      data->queue.ring[data->queue.back++] = apiData->message;
+      if ( data->queue.back == data->queue.ringSize )
+        data->queue.back = 0;
+      data->queue.size++;
+    }
+    else
+      std::cerr << "\nRtMidiIn: message queue limit reached!!\n\n";
+  }
+
+  // Clear the vector for the next input message.
+  apiData->message.bytes.clear();
+}
+
+MidiInWinMM :: MidiInWinMM( const std::string clientName, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit )
+{
+  initialize( clientName );
+}
+
+MidiInWinMM :: ~MidiInWinMM()
+{
+  // Close a connection if it exists.
+  closePort();
+
+  // Cleanup.
+  WinMidiData *data = static_cast<WinMidiData *> (apiData_);
+  delete data;
+}
+
+void MidiInWinMM :: initialize( const std::string& /*clientName*/ )
+{
+  // We'll issue a warning here if no devices are available but not
+  // throw an error since the user can plugin something later.
+  unsigned int nDevices = midiInGetNumDevs();
+  if ( nDevices == 0 ) {
+    errorString_ = "MidiInWinMM::initialize: no MIDI input devices currently available.";
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  // Save our api-specific connection information.
+  WinMidiData *data = (WinMidiData *) new WinMidiData;
+  apiData_ = (void *) data;
+  inputData_.apiData = (void *) data;
+  data->message.bytes.clear();  // needs to be empty for first input message
+}
+
+void MidiInWinMM :: openPort( unsigned int portNumber, const std::string /*portName*/ )
+{
+  if ( connected_ ) {
+    errorString_ = "MidiInWinMM::openPort: a valid connection already exists!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  unsigned int nDevices = midiInGetNumDevs();
+  if (nDevices == 0) {
+    errorString_ = "MidiInWinMM::openPort: no MIDI input sources found!";
+    RtMidi::error( RtError::NO_DEVICES_FOUND, errorString_ );
+  }
+
+  std::ostringstream ost;
+  if ( portNumber >= nDevices ) {
+    ost << "MidiInWinMM::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+  }
+
+  WinMidiData *data = static_cast<WinMidiData *> (apiData_);
+  MMRESULT result = midiInOpen( &data->inHandle,
+                                portNumber,
+                                (DWORD_PTR)&midiInputCallback,
+                                (DWORD_PTR)&inputData_,
+                                CALLBACK_FUNCTION );
+  if ( result != MMSYSERR_NOERROR ) {
+    errorString_ = "MidiInWinMM::openPort: error creating Windows MM MIDI input port.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Allocate and init the sysex buffers.
+  for ( int i=0; i<RT_SYSEX_BUFFER_COUNT; ++i ) {
+    data->sysexBuffer[i] = (MIDIHDR*) new char[ sizeof(MIDIHDR) ];
+    data->sysexBuffer[i]->lpData = new char[ RT_SYSEX_BUFFER_SIZE ];
+    data->sysexBuffer[i]->dwBufferLength = RT_SYSEX_BUFFER_SIZE;
+    data->sysexBuffer[i]->dwUser = i; // We use the dwUser parameter as buffer indicator
+    data->sysexBuffer[i]->dwFlags = 0;
+
+    result = midiInPrepareHeader( data->inHandle, data->sysexBuffer[i], sizeof(MIDIHDR) );
+    if ( result != MMSYSERR_NOERROR ) {
+      midiInClose( data->inHandle );
+      errorString_ = "MidiInWinMM::openPort: error starting Windows MM MIDI input port (PrepareHeader).";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+
+    // Register the buffer.
+    result = midiInAddBuffer( data->inHandle, data->sysexBuffer[i], sizeof(MIDIHDR) );
+    if ( result != MMSYSERR_NOERROR ) {
+      midiInClose( data->inHandle );
+      errorString_ = "MidiInWinMM::openPort: error starting Windows MM MIDI input port (AddBuffer).";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+  }
+
+  result = midiInStart( data->inHandle );
+  if ( result != MMSYSERR_NOERROR ) {
+    midiInClose( data->inHandle );
+    errorString_ = "MidiInWinMM::openPort: error starting Windows MM MIDI input port.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  connected_ = true;
+}
+
+void MidiInWinMM :: openVirtualPort( std::string portName )
+{
+  // This function cannot be implemented for the Windows MM MIDI API.
+  errorString_ = "MidiInWinMM::openVirtualPort: cannot be implemented in Windows MM MIDI API!";
+  RtMidi::error( RtError::WARNING, errorString_ );
+}
+
+void MidiInWinMM :: closePort( void )
+{
+  if ( connected_ ) {
+    WinMidiData *data = static_cast<WinMidiData *> (apiData_);
+    midiInReset( data->inHandle );
+    midiInStop( data->inHandle );
+
+    for ( int i=0; i<RT_SYSEX_BUFFER_COUNT; ++i ) {
+      int result = midiInUnprepareHeader(data->inHandle, data->sysexBuffer[i], sizeof(MIDIHDR));
+      delete [] data->sysexBuffer[i]->lpData;
+      delete [] data->sysexBuffer[i];
+      if ( result != MMSYSERR_NOERROR ) {
+        midiInClose( data->inHandle );
+        errorString_ = "MidiInWinMM::openPort: error closing Windows MM MIDI input port (midiInUnprepareHeader).";
+        RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+      }
+    }
+
+    midiInClose( data->inHandle );
+    connected_ = false;
+  }
+}
+
+unsigned int MidiInWinMM :: getPortCount()
+{
+  return midiInGetNumDevs();
+}
+
+std::string MidiInWinMM :: getPortName( unsigned int portNumber )
+{
+  std::string stringName;
+  unsigned int nDevices = midiInGetNumDevs();
+  if ( portNumber >= nDevices ) {
+    std::ostringstream ost;
+    ost << "MidiInWinMM::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    //RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return stringName;
+  }
+
+  MIDIINCAPS deviceCaps;
+  midiInGetDevCaps( portNumber, &deviceCaps, sizeof(MIDIINCAPS));
+
+#if defined( UNICODE ) || defined( _UNICODE )
+  int length = WideCharToMultiByte(CP_UTF8, 0, deviceCaps.szPname, -1, NULL, 0, NULL, NULL);
+  stringName.assign( length, 0 );
+  length = WideCharToMultiByte(CP_UTF8, 0, deviceCaps.szPname, wcslen(deviceCaps.szPname), &stringName[0], length, NULL, NULL);
+#else
+  stringName = std::string( deviceCaps.szPname );
+#endif
+
+  // Next lines added to add the portNumber to the name so that 
+  // the device's names are sure to be listed with individual names
+  // even when they have the same brand name
+  std::ostringstream os;
+  os << " ";
+  os << portNumber;
+  stringName += os.str();
+
+  return stringName;
+}
+
+//*********************************************************************//
+//  API: Windows MM
+//  Class Definitions: MidiOutWinMM
+//*********************************************************************//
+
+MidiOutWinMM :: MidiOutWinMM( const std::string clientName ) : MidiOutApi()
+{
+  initialize( clientName );
+}
+
+MidiOutWinMM :: ~MidiOutWinMM()
+{
+  // Close a connection if it exists.
+  closePort();
+
+  // Cleanup.
+  WinMidiData *data = static_cast<WinMidiData *> (apiData_);
+  delete data;
+}
+
+void MidiOutWinMM :: initialize( const std::string& /*clientName*/ )
+{
+  // We'll issue a warning here if no devices are available but not
+  // throw an error since the user can plug something in later.
+  unsigned int nDevices = midiOutGetNumDevs();
+  if ( nDevices == 0 ) {
+    errorString_ = "MidiOutWinMM::initialize: no MIDI output devices currently available.";
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  // Save our api-specific connection information.
+  WinMidiData *data = (WinMidiData *) new WinMidiData;
+  apiData_ = (void *) data;
+}
+
+unsigned int MidiOutWinMM :: getPortCount()
+{
+  return midiOutGetNumDevs();
+}
+
+std::string MidiOutWinMM :: getPortName( unsigned int portNumber )
+{
+  std::string stringName;
+  unsigned int nDevices = midiOutGetNumDevs();
+  if ( portNumber >= nDevices ) {
+    std::ostringstream ost;
+    ost << "MidiOutWinMM::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    //RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return stringName;
+  }
+
+  MIDIOUTCAPS deviceCaps;
+  midiOutGetDevCaps( portNumber, &deviceCaps, sizeof(MIDIOUTCAPS));
+
+#if defined( UNICODE ) || defined( _UNICODE )
+  int length = WideCharToMultiByte(CP_UTF8, 0, deviceCaps.szPname, -1, NULL, 0, NULL, NULL);
+  stringName.assign( length, 0 );
+  length = WideCharToMultiByte(CP_UTF8, 0, deviceCaps.szPname, wcslen(deviceCaps.szPname), &stringName[0], length, NULL, NULL);
+#else
+  stringName = std::string( deviceCaps.szPname );
+#endif
+
+  return stringName;
+}
+
+void MidiOutWinMM :: openPort( unsigned int portNumber, const std::string /*portName*/ )
+{
+  if ( connected_ ) {
+    errorString_ = "MidiOutWinMM::openPort: a valid connection already exists!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  unsigned int nDevices = midiOutGetNumDevs();
+  if (nDevices < 1) {
+    errorString_ = "MidiOutWinMM::openPort: no MIDI output destinations found!";
+    RtMidi::error( RtError::NO_DEVICES_FOUND, errorString_ );
+  }
+
+  std::ostringstream ost;
+  if ( portNumber >= nDevices ) {
+    ost << "MidiOutWinMM::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::INVALID_PARAMETER, errorString_ );
+  }
+
+  WinMidiData *data = static_cast<WinMidiData *> (apiData_);
+  MMRESULT result = midiOutOpen( &data->outHandle,
+                                 portNumber,
+                                 (DWORD)NULL,
+                                 (DWORD)NULL,
+                                 CALLBACK_NULL );
+  if ( result != MMSYSERR_NOERROR ) {
+    errorString_ = "MidiOutWinMM::openPort: error creating Windows MM MIDI output port.";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  connected_ = true;
+}
+
+void MidiOutWinMM :: closePort( void )
+{
+  if ( connected_ ) {
+    WinMidiData *data = static_cast<WinMidiData *> (apiData_);
+    midiOutReset( data->outHandle );
+    midiOutClose( data->outHandle );
+    connected_ = false;
+  }
+}
+
+void MidiOutWinMM :: openVirtualPort( std::string portName )
+{
+  // This function cannot be implemented for the Windows MM MIDI API.
+  errorString_ = "MidiOutWinMM::openVirtualPort: cannot be implemented in Windows MM MIDI API!";
+  RtMidi::error( RtError::WARNING, errorString_ );
+}
+
+void MidiOutWinMM :: sendMessage( std::vector<unsigned char> *message )
+{
+  unsigned int nBytes = static_cast<unsigned int>(message->size());
+  if ( nBytes == 0 ) {
+    errorString_ = "MidiOutWinMM::sendMessage: message argument is empty!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return;
+  }
+
+  MMRESULT result;
+  WinMidiData *data = static_cast<WinMidiData *> (apiData_);
+  if ( message->at(0) == 0xF0 ) { // Sysex message
+
+    // Allocate buffer for sysex data.
+    char *buffer = (char *) malloc( nBytes );
+    if ( buffer == NULL ) {
+      errorString_ = "MidiOutWinMM::sendMessage: error allocating sysex message memory!";
+      RtMidi::error( RtError::MEMORY_ERROR, errorString_ );
+    }
+
+    // Copy data to buffer.
+    for ( unsigned int i=0; i<nBytes; ++i ) buffer[i] = message->at(i);
+
+    // Create and prepare MIDIHDR structure.
+    MIDIHDR sysex;
+    sysex.lpData = (LPSTR) buffer;
+    sysex.dwBufferLength = nBytes;
+    sysex.dwFlags = 0;
+    result = midiOutPrepareHeader( data->outHandle,  &sysex, sizeof(MIDIHDR) ); 
+    if ( result != MMSYSERR_NOERROR ) {
+      free( buffer );
+      errorString_ = "MidiOutWinMM::sendMessage: error preparing sysex header.";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+
+    // Send the message.
+    result = midiOutLongMsg( data->outHandle, &sysex, sizeof(MIDIHDR) );
+    if ( result != MMSYSERR_NOERROR ) {
+      free( buffer );
+      errorString_ = "MidiOutWinMM::sendMessage: error sending sysex message.";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+
+    // Unprepare the buffer and MIDIHDR.
+    while ( MIDIERR_STILLPLAYING == midiOutUnprepareHeader( data->outHandle, &sysex, sizeof (MIDIHDR) ) ) Sleep( 1 );
+    free( buffer );
+
+  }
+  else { // Channel or system message.
+
+    // Make sure the message size isn't too big.
+    if ( nBytes > 3 ) {
+      errorString_ = "MidiOutWinMM::sendMessage: message size is greater than 3 bytes (and not sysex)!";
+      RtMidi::error( RtError::WARNING, errorString_ );
+      return;
+    }
+
+    // Pack MIDI bytes into double word.
+    DWORD packet;
+    unsigned char *ptr = (unsigned char *) &packet;
+    for ( unsigned int i=0; i<nBytes; ++i ) {
+      *ptr = message->at(i);
+      ++ptr;
+    }
+
+    // Send the message immediately.
+    result = midiOutShortMsg( data->outHandle, packet );
+    if ( result != MMSYSERR_NOERROR ) {
+      errorString_ = "MidiOutWinMM::sendMessage: error sending MIDI message.";
+      RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    }
+  }
+}
+
+#endif  // __WINDOWS_MM__
+
+// *********************************************************************//
+// API: WINDOWS Kernel Streaming
+//
+// Written by Sebastien Alaiwan, 2012.
+//
+// NOTE BY GARY: much of the KS-specific code below probably should go in a separate file.
+//
+// *********************************************************************//
+
+#if defined(__WINDOWS_KS__)
+
+#include <string>
+#include <vector>
+#include <memory>
+#include <stdexcept>
+#include <sstream>
+#include <windows.h>
+#include <setupapi.h>
+#include <mmsystem.h>
+
+#include "ks.h"
+#include "ksmedia.h"
+
+#define INSTANTIATE_GUID(a) GUID const a = { STATIC_ ## a }
+
+INSTANTIATE_GUID(GUID_NULL);
+INSTANTIATE_GUID(KSPROPSETID_Pin);
+INSTANTIATE_GUID(KSPROPSETID_Connection);
+INSTANTIATE_GUID(KSPROPSETID_Topology);
+INSTANTIATE_GUID(KSINTERFACESETID_Standard);
+INSTANTIATE_GUID(KSMEDIUMSETID_Standard);
+INSTANTIATE_GUID(KSDATAFORMAT_TYPE_MUSIC);
+INSTANTIATE_GUID(KSDATAFORMAT_SUBTYPE_MIDI);
+INSTANTIATE_GUID(KSDATAFORMAT_SPECIFIER_NONE);
+
+#undef INSTANTIATE_GUID
+
+typedef std::basic_string<TCHAR> tstring;
+
+inline bool IsValid(HANDLE handle)
+{
+  return handle != NULL && handle != INVALID_HANDLE_VALUE;
+}
+
+class ComException : public std::runtime_error
+{
+private:
+  static std::string MakeString(std::string const& s, HRESULT hr)
+  {
+    std::stringstream ss;
+    ss << "(error 0x" << std::hex << hr << ")";
+    return s + ss.str();
+  }
+
+public:
+  ComException(std::string const& s, HRESULT hr) :
+    std::runtime_error(MakeString(s, hr))
+  {
+  }
+};
+
+template<typename TFilterType>
+class CKsEnumFilters
+{
+public:
+  ~CKsEnumFilters()
+  {
+    DestroyLists();
+  }
+
+  void EnumFilters(GUID const* categories, size_t numCategories)
+  {
+    DestroyLists();
+
+    if (categories == 0)
+      throw std::runtime_error("CKsEnumFilters: invalid argument");
+
+    // Get a handle to the device set specified by the guid
+    HDEVINFO hDevInfo = ::SetupDiGetClassDevs(&categories[0], NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
+    if (!IsValid(hDevInfo))
+      throw std::runtime_error("CKsEnumFilters: no devices found");
+
+    // Loop through members of the set and get details for each
+    for (int iClassMember=0;;iClassMember++) {
+      try {
+        SP_DEVICE_INTERFACE_DATA DID;
+        DID.cbSize = sizeof(DID);
+        DID.Reserved = 0;
+
+        bool fRes = ::SetupDiEnumDeviceInterfaces(hDevInfo, NULL, &categories[0], iClassMember, &DID);
+        if (!fRes)
+          break;
+
+        // Get filter friendly name
+        HKEY hRegKey = ::SetupDiOpenDeviceInterfaceRegKey(hDevInfo, &DID, 0, KEY_READ);
+        if (hRegKey == INVALID_HANDLE_VALUE)
+          throw std::runtime_error("CKsEnumFilters: interface has no registry");
+
+        char friendlyName[256];
+        DWORD dwSize = sizeof friendlyName;
+        LONG lval = ::RegQueryValueEx(hRegKey, TEXT("FriendlyName"), NULL, NULL, (LPBYTE)friendlyName, &dwSize);
+        ::RegCloseKey(hRegKey);
+        if (lval != ERROR_SUCCESS)
+          throw std::runtime_error("CKsEnumFilters: interface has no friendly name");
+
+        // Get details for the device registered in this class
+        DWORD const cbItfDetails = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + MAX_PATH * sizeof(WCHAR);
+        std::vector<BYTE> buffer(cbItfDetails);
+
+        SP_DEVICE_INTERFACE_DETAIL_DATA* pDevInterfaceDetails = reinterpret_cast<SP_DEVICE_INTERFACE_DETAIL_DATA*>(&buffer[0]);
+        pDevInterfaceDetails->cbSize = sizeof(*pDevInterfaceDetails);
+
+        SP_DEVINFO_DATA DevInfoData;
+        DevInfoData.cbSize = sizeof(DevInfoData);
+        DevInfoData.Reserved = 0;
+
+        fRes = ::SetupDiGetDeviceInterfaceDetail(hDevInfo, &DID, pDevInterfaceDetails, cbItfDetails, NULL, &DevInfoData);
+        if (!fRes)
+          throw std::runtime_error("CKsEnumFilters: could not get interface details");
+
+        // check additional category guids which may (or may not) have been supplied
+        for (size_t i=1; i < numCategories; ++i) {
+          SP_DEVICE_INTERFACE_DATA DIDAlias;
+          DIDAlias.cbSize = sizeof(DIDAlias);
+          DIDAlias.Reserved = 0;
+
+          fRes = ::SetupDiGetDeviceInterfaceAlias(hDevInfo, &DID, &categories[i], &DIDAlias);
+          if (!fRes)
+            throw std::runtime_error("CKsEnumFilters: could not get interface alias");
+
+          // Check if the this interface alias is enabled.
+          if (!DIDAlias.Flags || (DIDAlias.Flags & SPINT_REMOVED))
+            throw std::runtime_error("CKsEnumFilters: interface alias is not enabled");
+        }
+
+        std::auto_ptr<TFilterType> pFilter(new TFilterType(pDevInterfaceDetails->DevicePath, friendlyName));
+
+        pFilter->Instantiate();
+        pFilter->FindMidiPins();
+        pFilter->Validate();
+
+        m_Filters.push_back(pFilter.release());
+      }
+      catch (std::runtime_error const& e) {
+      }
+    }
+
+    ::SetupDiDestroyDeviceInfoList(hDevInfo);
+  }
+
+private:
+  void DestroyLists()
+  {
+    for (size_t i=0;i < m_Filters.size();++i)
+      delete m_Filters[i];
+    m_Filters.clear();
+  }
+
+public:
+  // TODO: make this private.
+  std::vector<TFilterType*> m_Filters;
+};
+
+class CKsObject
+{
+public:
+  CKsObject(HANDLE handle) : m_handle(handle)
+  {
+  }
+
+protected:
+  HANDLE m_handle;
+
+  void SetProperty(REFGUID guidPropertySet, ULONG nProperty, void* pvValue, ULONG cbValue)
+  {
+    KSPROPERTY ksProperty;
+    memset(&ksProperty, 0, sizeof ksProperty);
+    ksProperty.Set = guidPropertySet;
+    ksProperty.Id = nProperty;
+    ksProperty.Flags = KSPROPERTY_TYPE_SET;
+
+    HRESULT hr = DeviceIoControlKsProperty(ksProperty, pvValue, cbValue);
+    if (FAILED(hr))
+      throw ComException("CKsObject::SetProperty: could not set property", hr);
+  }
+
+private:
+
+  HRESULT DeviceIoControlKsProperty(KSPROPERTY& ksProperty, void* pvValue, ULONG cbValue)
+  {
+    ULONG ulReturned;
+    return ::DeviceIoControl(
+             m_handle,
+             IOCTL_KS_PROPERTY,
+             &ksProperty,
+             sizeof(ksProperty),
+             pvValue,
+             cbValue,
+             &ulReturned,
+             NULL);
+  }
+};
+
+class CKsPin;
+
+class CKsFilter : public CKsObject
+{
+  friend class CKsPin;
+
+public:
+  CKsFilter(tstring const& name, std::string const& sFriendlyName);
+  virtual ~CKsFilter();
+
+  virtual void Instantiate();
+
+  template<typename T>
+  T GetPinProperty(ULONG nPinId, ULONG nProperty)
+  {
+    ULONG ulReturned = 0;
+    T value;
+
+    KSP_PIN ksPProp;
+    ksPProp.Property.Set = KSPROPSETID_Pin;
+    ksPProp.Property.Id = nProperty;
+    ksPProp.Property.Flags = KSPROPERTY_TYPE_GET;
+    ksPProp.PinId = nPinId;
+    ksPProp.Reserved = 0;
+
+    HRESULT hr = ::DeviceIoControl(
+      m_handle,
+      IOCTL_KS_PROPERTY,
+      &ksPProp,
+      sizeof(KSP_PIN),
+      &value,
+      sizeof(value),
+      &ulReturned,
+      NULL);
+    if (FAILED(hr))
+      throw ComException("CKsFilter::GetPinProperty: failed to retrieve property", hr);
+
+    return value;
+  }
+
+  void GetPinPropertyMulti(ULONG nPinId, REFGUID guidPropertySet, ULONG nProperty, PKSMULTIPLE_ITEM* ppKsMultipleItem)
+  {
+    HRESULT hr;
+
+    KSP_PIN ksPProp;
+    ksPProp.Property.Set = guidPropertySet;
+    ksPProp.Property.Id = nProperty;
+    ksPProp.Property.Flags = KSPROPERTY_TYPE_GET;
+    ksPProp.PinId = nPinId;
+    ksPProp.Reserved = 0;
+
+    ULONG cbMultipleItem = 0;
+    hr = ::DeviceIoControl(m_handle,
+        IOCTL_KS_PROPERTY,
+        &ksPProp.Property,
+        sizeof(KSP_PIN),
+        NULL,
+        0,
+        &cbMultipleItem,
+        NULL);
+    if (FAILED(hr))
+      throw ComException("CKsFilter::GetPinPropertyMulti: cannot get property", hr);
+
+    *ppKsMultipleItem = (PKSMULTIPLE_ITEM) new BYTE[cbMultipleItem];
+
+    ULONG ulReturned = 0;
+    hr = ::DeviceIoControl(
+        m_handle,
+        IOCTL_KS_PROPERTY,
+        &ksPProp,
+        sizeof(KSP_PIN),
+        (PVOID)*ppKsMultipleItem,
+        cbMultipleItem,
+        &ulReturned,
+        NULL);
+    if (FAILED(hr))
+      throw ComException("CKsFilter::GetPinPropertyMulti: cannot get property", hr);
+  }
+
+  std::string const& GetFriendlyName() const
+  {
+    return m_sFriendlyName;
+  }
+
+protected:
+
+  std::vector<CKsPin*> m_Pins; // this list owns the pins.
+
+  std::vector<CKsPin*> m_RenderPins;
+  std::vector<CKsPin*> m_CapturePins;
+
+private:
+  std::string const m_sFriendlyName; // friendly name eg "Virus TI Synth"
+  tstring const m_sName; // Filter path, eg "\\?\usb#vid_133e&pid_0815...\vtimidi02"
+};
+
+class CKsPin : public CKsObject
+{
+public:
+  CKsPin(CKsFilter* pFilter, ULONG nId);
+  virtual ~CKsPin();
+
+  virtual void Instantiate();
+
+  void ClosePin();
+
+  void SetState(KSSTATE ksState);
+
+  void WriteData(KSSTREAM_HEADER* pKSSTREAM_HEADER, OVERLAPPED* pOVERLAPPED);
+  void ReadData(KSSTREAM_HEADER* pKSSTREAM_HEADER, OVERLAPPED* pOVERLAPPED);
+
+  KSPIN_DATAFLOW GetDataFlow() const
+  {
+    return m_DataFlow;
+  }
+
+  bool IsSink() const
+  {
+    return m_Communication == KSPIN_COMMUNICATION_SINK
+      || m_Communication == KSPIN_COMMUNICATION_BOTH;
+  }
+
+
+protected:
+  PKSPIN_CONNECT m_pKsPinConnect;    // creation parameters of pin
+  CKsFilter* const m_pFilter;
+
+  ULONG m_cInterfaces;
+  PKSIDENTIFIER m_pInterfaces;
+  PKSMULTIPLE_ITEM m_pmiInterfaces;
+
+  ULONG m_cMediums;
+  PKSIDENTIFIER m_pMediums;
+  PKSMULTIPLE_ITEM m_pmiMediums;
+
+  ULONG m_cDataRanges;
+  PKSDATARANGE m_pDataRanges;
+  PKSMULTIPLE_ITEM m_pmiDataRanges;
+
+  KSPIN_DATAFLOW m_DataFlow;
+  KSPIN_COMMUNICATION m_Communication;
+};
+
+CKsFilter::CKsFilter(tstring const& sName, std::string const& sFriendlyName) :
+  CKsObject(INVALID_HANDLE_VALUE),
+  m_sFriendlyName(sFriendlyName),
+  m_sName(sName)
+{
+  if (sName.empty())
+    throw std::runtime_error("CKsFilter::CKsFilter: name can't be empty");
+}
+
+CKsFilter::~CKsFilter()
+{
+  for (size_t i=0;i < m_Pins.size();++i)
+    delete m_Pins[i];
+
+  if (IsValid(m_handle))
+    ::CloseHandle(m_handle);
+}
+
+void CKsFilter::Instantiate()
+{
+  m_handle = CreateFile(
+    m_sName.c_str(),
+    GENERIC_READ | GENERIC_WRITE,
+    0,
+    NULL,
+    OPEN_EXISTING,
+    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
+    NULL);
+
+  if (!IsValid(m_handle))
+  {
+    DWORD const dwError = GetLastError();
+    throw ComException("CKsFilter::Instantiate: can't open driver", HRESULT_FROM_WIN32(dwError));
+  }
+}
+
+CKsPin::CKsPin(CKsFilter* pFilter, ULONG PinId) :
+  CKsObject(INVALID_HANDLE_VALUE),
+  m_pKsPinConnect(NULL),
+  m_pFilter(pFilter)
+{
+  m_Communication = m_pFilter->GetPinProperty<KSPIN_COMMUNICATION>(PinId, KSPROPERTY_PIN_COMMUNICATION);
+  m_DataFlow = m_pFilter->GetPinProperty<KSPIN_DATAFLOW>(PinId, KSPROPERTY_PIN_DATAFLOW);
+
+  // Interfaces
+  m_pFilter->GetPinPropertyMulti(
+      PinId,
+      KSPROPSETID_Pin,
+      KSPROPERTY_PIN_INTERFACES,
+      &m_pmiInterfaces);
+
+  m_cInterfaces = m_pmiInterfaces->Count;
+  m_pInterfaces = (PKSPIN_INTERFACE)(m_pmiInterfaces + 1);
+
+  // Mediums
+  m_pFilter->GetPinPropertyMulti(
+      PinId,
+      KSPROPSETID_Pin,
+      KSPROPERTY_PIN_MEDIUMS,
+      &m_pmiMediums);
+
+  m_cMediums = m_pmiMediums->Count;
+  m_pMediums = (PKSPIN_MEDIUM)(m_pmiMediums + 1);
+
+  // Data ranges
+  m_pFilter->GetPinPropertyMulti(
+      PinId,
+      KSPROPSETID_Pin,
+      KSPROPERTY_PIN_DATARANGES,
+      &m_pmiDataRanges);
+
+  m_cDataRanges = m_pmiDataRanges->Count;
+  m_pDataRanges = (PKSDATARANGE)(m_pmiDataRanges + 1);
+}
+
+CKsPin::~CKsPin()
+{
+  ClosePin();
+
+  delete[] (BYTE*)m_pKsPinConnect;
+  delete[] (BYTE*)m_pmiDataRanges;
+  delete[] (BYTE*)m_pmiInterfaces;
+  delete[] (BYTE*)m_pmiMediums;
+}
+
+void CKsPin::ClosePin()
+{
+  if (IsValid(m_handle)) {
+    SetState(KSSTATE_STOP);
+    ::CloseHandle(m_handle);
+  }
+  m_handle = INVALID_HANDLE_VALUE;
+}
+
+void CKsPin::SetState(KSSTATE ksState)
+{
+  SetProperty(KSPROPSETID_Connection, KSPROPERTY_CONNECTION_STATE, &ksState, sizeof(ksState));
+}
+
+void CKsPin::Instantiate()
+{
+  if (!m_pKsPinConnect)
+    throw std::runtime_error("CKsPin::Instanciate: abstract pin");
+
+  DWORD const dwResult = KsCreatePin(m_pFilter->m_handle, m_pKsPinConnect, GENERIC_WRITE | GENERIC_READ, &m_handle);
+  if (dwResult != ERROR_SUCCESS)
+    throw ComException("CKsMidiCapFilter::CreateRenderPin: Pin instanciation failed", HRESULT_FROM_WIN32(dwResult));
+}
+
+void CKsPin::WriteData(KSSTREAM_HEADER* pKSSTREAM_HEADER, OVERLAPPED* pOVERLAPPED)
+{
+  DWORD cbWritten;
+  BOOL fRes = ::DeviceIoControl(
+    m_handle,
+    IOCTL_KS_WRITE_STREAM,
+    NULL,
+    0,
+    pKSSTREAM_HEADER,
+    pKSSTREAM_HEADER->Size,
+    &cbWritten,
+    pOVERLAPPED);
+  if (!fRes) {
+    DWORD const dwError = GetLastError();
+    if (dwError != ERROR_IO_PENDING)
+      throw ComException("CKsPin::WriteData: DeviceIoControl failed", HRESULT_FROM_WIN32(dwError));
+  }
+}
+
+void CKsPin::ReadData(KSSTREAM_HEADER* pKSSTREAM_HEADER, OVERLAPPED* pOVERLAPPED)
+{
+  DWORD cbReturned;
+  BOOL fRes = ::DeviceIoControl(
+    m_handle,
+    IOCTL_KS_READ_STREAM,
+    NULL,
+    0,
+    pKSSTREAM_HEADER,
+    pKSSTREAM_HEADER->Size,
+    &cbReturned,
+    pOVERLAPPED);
+  if (!fRes) {
+    DWORD const dwError = GetLastError();
+    if (dwError != ERROR_IO_PENDING)
+      throw ComException("CKsPin::ReadData: DeviceIoControl failed", HRESULT_FROM_WIN32(dwError));
+  }
+}
+
+class CKsMidiFilter : public CKsFilter
+{
+public:
+  void FindMidiPins();
+
+protected:
+  CKsMidiFilter(tstring const& sPath, std::string const& sFriendlyName);
+};
+
+class CKsMidiPin : public CKsPin
+{
+public:
+  CKsMidiPin(CKsFilter* pFilter, ULONG nId);
+};
+
+class CKsMidiRenFilter : public CKsMidiFilter
+{
+public:
+  CKsMidiRenFilter(tstring const& sPath, std::string const& sFriendlyName);
+  CKsMidiPin* CreateRenderPin();
+
+  void Validate()
+  {
+    if (m_RenderPins.empty())
+      throw std::runtime_error("Could not find a MIDI render pin");
+  }
+};
+
+class CKsMidiCapFilter : public CKsMidiFilter
+{
+public:
+  CKsMidiCapFilter(tstring const& sPath, std::string const& sFriendlyName);
+  CKsMidiPin* CreateCapturePin();
+
+  void Validate()
+  {
+    if (m_CapturePins.empty())
+      throw std::runtime_error("Could not find a MIDI capture pin");
+  }
+};
+
+CKsMidiFilter::CKsMidiFilter(tstring const& sPath, std::string const& sFriendlyName) :
+  CKsFilter(sPath, sFriendlyName)
+{
+}
+
+void CKsMidiFilter::FindMidiPins()
+{
+  ULONG numPins = GetPinProperty<ULONG>(0, KSPROPERTY_PIN_CTYPES);
+
+  for (ULONG iPin = 0; iPin < numPins; ++iPin) {
+    try {
+      KSPIN_COMMUNICATION com = GetPinProperty<KSPIN_COMMUNICATION>(iPin, KSPROPERTY_PIN_COMMUNICATION);
+      if (com != KSPIN_COMMUNICATION_SINK && com != KSPIN_COMMUNICATION_BOTH)
+        throw std::runtime_error("Unknown pin communication value");
+
+      m_Pins.push_back(new CKsMidiPin(this, iPin));
+    }
+    catch (std::runtime_error const&) {
+      // pin instanciation has failed, continue to the next pin.
+    }
+  }
+
+  m_RenderPins.clear();
+  m_CapturePins.clear();
+
+  for (size_t i = 0; i < m_Pins.size(); ++i) {
+    CKsPin* const pPin = m_Pins[i];
+
+    if (pPin->IsSink()) {
+      if (pPin->GetDataFlow() == KSPIN_DATAFLOW_IN)
+        m_RenderPins.push_back(pPin);
+      else
+        m_CapturePins.push_back(pPin);
+    }
+  }
+
+  if (m_RenderPins.empty() && m_CapturePins.empty())
+    throw std::runtime_error("No valid pins found on the filter.");
+}
+
+CKsMidiRenFilter::CKsMidiRenFilter(tstring const& sPath, std::string const& sFriendlyName) :
+  CKsMidiFilter(sPath, sFriendlyName)
+{
+}
+
+CKsMidiPin* CKsMidiRenFilter::CreateRenderPin()
+{
+  if (m_RenderPins.empty())
+    throw std::runtime_error("Could not find a MIDI render pin");
+
+  CKsMidiPin* pPin = (CKsMidiPin*)m_RenderPins[0];
+  pPin->Instantiate();
+  return pPin;
+}
+
+CKsMidiCapFilter::CKsMidiCapFilter(tstring const& sPath, std::string const& sFriendlyName) :
+  CKsMidiFilter(sPath, sFriendlyName)
+{
+}
+
+CKsMidiPin* CKsMidiCapFilter::CreateCapturePin()
+{
+  if (m_CapturePins.empty())
+    throw std::runtime_error("Could not find a MIDI capture pin");
+
+  CKsMidiPin* pPin = (CKsMidiPin*)m_CapturePins[0];
+  pPin->Instantiate();
+  return pPin;
+}
+
+CKsMidiPin::CKsMidiPin(CKsFilter* pFilter, ULONG nId) :
+  CKsPin(pFilter, nId)
+{
+  DWORD const cbPinCreateSize = sizeof(KSPIN_CONNECT) + sizeof(KSDATAFORMAT);
+  m_pKsPinConnect = (PKSPIN_CONNECT) new BYTE[cbPinCreateSize];
+
+  m_pKsPinConnect->Interface.Set = KSINTERFACESETID_Standard;
+  m_pKsPinConnect->Interface.Id = KSINTERFACE_STANDARD_STREAMING;
+  m_pKsPinConnect->Interface.Flags = 0;
+  m_pKsPinConnect->Medium.Set = KSMEDIUMSETID_Standard;
+  m_pKsPinConnect->Medium.Id = KSMEDIUM_TYPE_ANYINSTANCE;
+  m_pKsPinConnect->Medium.Flags = 0;
+  m_pKsPinConnect->PinId = nId;
+  m_pKsPinConnect->PinToHandle = NULL;
+  m_pKsPinConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
+  m_pKsPinConnect->Priority.PrioritySubClass = 1;
+
+  // point m_pDataFormat to just after the pConnect struct
+  KSDATAFORMAT* m_pDataFormat = (KSDATAFORMAT*)(m_pKsPinConnect + 1);
+  m_pDataFormat->FormatSize = sizeof(KSDATAFORMAT);
+  m_pDataFormat->Flags = 0;
+  m_pDataFormat->SampleSize = 0;
+  m_pDataFormat->Reserved = 0;
+  m_pDataFormat->MajorFormat = GUID(KSDATAFORMAT_TYPE_MUSIC);
+  m_pDataFormat->SubFormat = GUID(KSDATAFORMAT_SUBTYPE_MIDI);
+  m_pDataFormat->Specifier = GUID(KSDATAFORMAT_SPECIFIER_NONE);
+
+  bool hasStdStreamingInterface = false;
+  bool hasStdStreamingMedium = false;
+
+  for ( ULONG i = 0; i < m_cInterfaces; i++ ) {
+    if (m_pInterfaces[i].Set == KSINTERFACESETID_Standard
+        && m_pInterfaces[i].Id == KSINTERFACE_STANDARD_STREAMING)
+      hasStdStreamingInterface = true;
+  }
+
+  for (ULONG i = 0; i < m_cMediums; i++) {
+    if (m_pMediums[i].Set == KSMEDIUMSETID_Standard
+        && m_pMediums[i].Id == KSMEDIUM_STANDARD_DEVIO)
+      hasStdStreamingMedium = true;
+  }
+
+  if (!hasStdStreamingInterface) // No standard streaming interfaces on the pin
+    throw std::runtime_error("CKsMidiPin::CKsMidiPin: no standard streaming interface");
+
+  if (!hasStdStreamingMedium) // No standard streaming mediums on the pin
+    throw std::runtime_error("CKsMidiPin::CKsMidiPin: no standard streaming medium");
+
+  bool hasMidiDataRange = false;
+
+  BYTE const* pDataRangePtr = reinterpret_cast<BYTE const*>(m_pDataRanges);
+
+  for (ULONG i = 0; i < m_cDataRanges; ++i) {
+    KSDATARANGE const* pDataRange = reinterpret_cast<KSDATARANGE const*>(pDataRangePtr);
+
+    if (pDataRange->SubFormat == KSDATAFORMAT_SUBTYPE_MIDI) {
+      hasMidiDataRange = true;
+      break;
+    }
+
+    pDataRangePtr += pDataRange->FormatSize;
+  }
+
+  if (!hasMidiDataRange) // No MIDI dataranges on the pin
+    throw std::runtime_error("CKsMidiPin::CKsMidiPin: no MIDI datarange");
+}
+
+
+struct WindowsKsData
+{
+  WindowsKsData() : m_pPin(NULL), m_Buffer(1024), m_hInputThread(NULL)
+  {
+    memset(&overlapped, 0, sizeof(OVERLAPPED));
+    m_hExitEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
+    overlapped.hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
+    m_hInputThread = NULL;
+  }
+
+  ~WindowsKsData()
+  {
+    ::CloseHandle(overlapped.hEvent);
+    ::CloseHandle(m_hExitEvent);
+  }
+
+  OVERLAPPED overlapped;
+  CKsPin* m_pPin;
+  std::vector<unsigned char> m_Buffer;
+  std::auto_ptr<CKsEnumFilters<CKsMidiCapFilter> > m_pCaptureEnum;
+  std::auto_ptr<CKsEnumFilters<CKsMidiRenFilter> > m_pRenderEnum;
+  HANDLE m_hInputThread;
+  HANDLE m_hExitEvent;
+};
+
+// *********************************************************************//
+// API: WINDOWS Kernel Streaming
+// Class Definitions: MidiInWinKS
+// *********************************************************************//
+
+DWORD WINAPI midiKsInputThread(VOID* pUser)
+{
+  MidiInApi::RtMidiInData* data = static_cast<MidiInApi::RtMidiInData*>(pUser);
+  WindowsKsData* apiData = static_cast<WindowsKsData*>(data->apiData);
+
+  HANDLE hEvents[] = { apiData->overlapped.hEvent, apiData->m_hExitEvent };
+
+  while ( true ) {
+    KSSTREAM_HEADER packet;
+    memset(&packet, 0, sizeof packet);
+    packet.Size = sizeof(KSSTREAM_HEADER);
+    packet.PresentationTime.Time = 0;
+    packet.PresentationTime.Numerator = 1;
+    packet.PresentationTime.Denominator = 1;
+    packet.Data = &apiData->m_Buffer[0];
+    packet.DataUsed = 0;
+    packet.FrameExtent = apiData->m_Buffer.size();
+    apiData->m_pPin->ReadData(&packet, &apiData->overlapped);
+
+    DWORD dwRet = ::WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);
+
+    if ( dwRet == WAIT_OBJECT_0 ) {
+      // parse packet
+      unsigned char* pData = (unsigned char*)packet.Data;
+      unsigned int iOffset = 0;
+
+      while ( iOffset < packet.DataUsed ) {
+        KSMUSICFORMAT* pMusic = (KSMUSICFORMAT*)&pData[iOffset];
+        iOffset += sizeof(KSMUSICFORMAT);
+
+        MidiInApi::MidiMessage message;
+        message.timeStamp = 0;
+        for(size_t i=0;i < pMusic->ByteCount;++i)
+          message.bytes.push_back(pData[iOffset+i]);
+
+        if ( data->usingCallback ) {
+          RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback)data->userCallback;
+          callback(message.timeStamp, &message.bytes, data->userData);
+        }
+        else {
+          // As long as we haven't reached our queue size limit, push the message.
+          if ( data->queue.size < data->queue.ringSize ) {
+            data->queue.ring[data->queue.back++] = message;
+            if(data->queue.back == data->queue.ringSize)
+              data->queue.back = 0;
+            data->queue.size++;
+          }
+          else
+            std::cerr << "\nRtMidiIn: message queue limit reached!!\n\n";
+        }
+
+        iOffset += pMusic->ByteCount;
+
+        // re-align on 32 bits
+        if ( iOffset % 4 != 0 )
+          iOffset += (4 - iOffset % 4);
+      }
+    }
+    else
+      break;
+  }
+  return 0;
+}
+
+MidiInWinKS :: MidiInWinKS( const std::string clientName, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit )
+{
+  initialize( clientName );
+}
+
+void MidiInWinKS :: initialize( const std::string& clientName )
+{
+  WindowsKsData* data = new WindowsKsData;
+  apiData_ = (void*)data;
+  inputData_.apiData = data;
+
+  GUID const aguidEnumCats[] =
+  {
+    { STATIC_KSCATEGORY_AUDIO }, { STATIC_KSCATEGORY_CAPTURE }
+  };
+  data->m_pCaptureEnum.reset(new CKsEnumFilters<CKsMidiCapFilter> );
+  data->m_pCaptureEnum->EnumFilters(aguidEnumCats, 2);
+}
+
+MidiInWinKS :: ~MidiInWinKS()
+{
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+  try {
+    if ( data->m_pPin )
+      closePort();
+  }
+  catch(...) {
+  }
+
+  delete data;
+}
+
+void MidiInWinKS :: openPort( unsigned int portNumber, const std::string portName )
+{
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+
+  if ( portNumber < 0 || portNumber >= data->m_pCaptureEnum->m_Filters.size() ) {
+    std::stringstream ost;
+    ost << "MidiInWinKS::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  CKsMidiCapFilter* pFilter = data->m_pCaptureEnum->m_Filters[portNumber];
+  data->m_pPin = pFilter->CreateCapturePin();
+
+  if ( data->m_pPin == NULL ) {
+    std::stringstream ost;
+    ost << "MidiInWinKS::openPort: KS error opening port (could not create pin)";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  data->m_pPin->SetState(KSSTATE_RUN);
+
+  DWORD threadId;
+  data->m_hInputThread = ::CreateThread(NULL, 0, &midiKsInputThread, &inputData_, 0, &threadId);
+  if ( data->m_hInputThread == NULL ) {
+    std::stringstream ost;
+    ost << "MidiInWinKS::initialize: Could not create input thread : Windows error " << GetLastError() << std::endl;;
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  connected_ = true;
+}
+
+void MidiInWinKS :: openVirtualPort( const std::string portName )
+{
+  // This function cannot be implemented for the Windows KS MIDI API.
+  errorString_ = "MidiInWinKS::openVirtualPort: cannot be implemented in Windows KS MIDI API!";
+  RtMidi::error( RtError::WARNING, errorString_ );
+}
+
+unsigned int MidiInWinKS :: getPortCount()
+{
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+  return (unsigned int)data->m_pCaptureEnum->m_Filters.size();
+}
+
+std::string MidiInWinKS :: getPortName(unsigned int portNumber)
+{
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+
+  if(portNumber < 0 || portNumber >= data->m_pCaptureEnum->m_Filters.size()) {
+    std::stringstream ost;
+    ost << "MidiInWinKS::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  CKsMidiCapFilter* pFilter = data->m_pCaptureEnum->m_Filters[portNumber];
+  return pFilter->GetFriendlyName();
+}
+
+void MidiInWinKS :: closePort()
+{
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+  connected_ = false;
+
+  if(data->m_hInputThread) {
+    ::SignalObjectAndWait(data->m_hExitEvent, data->m_hInputThread, INFINITE, FALSE);
+    ::CloseHandle(data->m_hInputThread);
+  }
+
+  if(data->m_pPin) {
+    data->m_pPin->SetState(KSSTATE_PAUSE);
+    data->m_pPin->SetState(KSSTATE_STOP);
+    data->m_pPin->ClosePin();
+    data->m_pPin = NULL;
+  }
+}
+
+// *********************************************************************//
+// API: WINDOWS Kernel Streaming
+// Class Definitions: MidiOutWinKS
+// *********************************************************************//
+
+MidiOutWinKS :: MidiOutWinKS( const std::string clientName ) : MidiOutApi()
+{
+  initialize( clientName );
+}
+
+void MidiOutWinKS :: initialize( const std::string& clientName )
+{
+  WindowsKsData* data = new WindowsKsData;
+
+  data->m_pPin = NULL;
+  data->m_pRenderEnum.reset(new CKsEnumFilters<CKsMidiRenFilter> );
+  GUID const aguidEnumCats[] =
+  {
+    { STATIC_KSCATEGORY_AUDIO }, { STATIC_KSCATEGORY_RENDER }
+  };
+  data->m_pRenderEnum->EnumFilters(aguidEnumCats, 2);
+
+  apiData_ = (void*)data;
+}
+
+MidiOutWinKS :: ~MidiOutWinKS()
+{
+  // Close a connection if it exists.
+  closePort();
+
+  // Cleanup.
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+  delete data;
+}
+
+void MidiOutWinKS :: openPort( unsigned int portNumber, const std::string portName )
+{
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+
+  if(portNumber < 0 || portNumber >= data->m_pRenderEnum->m_Filters.size()) {
+    std::stringstream ost;
+    ost << "MidiOutWinKS::openPort: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  CKsMidiRenFilter* pFilter = data->m_pRenderEnum->m_Filters[portNumber];
+  data->m_pPin = pFilter->CreateRenderPin();
+
+  if(data->m_pPin == NULL) {
+    std::stringstream ost;
+    ost << "MidiOutWinKS::openPort: KS error opening port (could not create pin)";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  data->m_pPin->SetState(KSSTATE_RUN);
+  connected_ = true;
+}
+
+void MidiOutWinKS :: openVirtualPort( const std::string portName )
+{
+  // This function cannot be implemented for the Windows KS MIDI API.
+  errorString_ = "MidiOutWinKS::openVirtualPort: cannot be implemented in Windows KS MIDI API!";
+  RtMidi::error( RtError::WARNING, errorString_ );
+}
+
+unsigned int MidiOutWinKS :: getPortCount()
+{
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+
+  return (unsigned int)data->m_pRenderEnum->m_Filters.size();
+}
+
+std::string MidiOutWinKS :: getPortName( unsigned int portNumber )
+{
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+
+  if ( portNumber < 0 || portNumber >= data->m_pRenderEnum->m_Filters.size() ) {
+    std::stringstream ost;
+    ost << "MidiOutWinKS::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  CKsMidiRenFilter* pFilter = data->m_pRenderEnum->m_Filters[portNumber];
+  return pFilter->GetFriendlyName();
+}
+
+void MidiOutWinKS :: closePort()
+{
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+  connected_ = false;
+
+  if ( data->m_pPin ) {
+    data->m_pPin->SetState(KSSTATE_PAUSE);
+    data->m_pPin->SetState(KSSTATE_STOP);
+    data->m_pPin->ClosePin();
+    data->m_pPin = NULL;
+  }
+}
+
+void MidiOutWinKS :: sendMessage(std::vector<unsigned char>* pMessage)
+{
+  std::vector<unsigned char> const& msg = *pMessage;
+  WindowsKsData* data = static_cast<WindowsKsData*>(apiData_);
+  size_t iNumMidiBytes = msg.size();
+  size_t pos = 0;
+
+  // write header
+  KSMUSICFORMAT* pKsMusicFormat = reinterpret_cast<KSMUSICFORMAT*>(&data->m_Buffer[pos]);
+  pKsMusicFormat->TimeDeltaMs = 0;
+  pKsMusicFormat->ByteCount = iNumMidiBytes;
+  pos += sizeof(KSMUSICFORMAT);
+
+  // write MIDI bytes
+  if ( pos + iNumMidiBytes > data->m_Buffer.size() ) {
+    std::stringstream ost;
+    ost << "KsMidiInput::Write: MIDI buffer too small. Required " << pos + iNumMidiBytes << " bytes, only has " << data->m_Buffer.size();
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  if ( data->m_pPin == NULL ) {
+    std::stringstream ost;
+    ost << "MidiOutWinKS::sendMessage: port is not open";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+
+  memcpy(&data->m_Buffer[pos], &msg[0], iNumMidiBytes);
+  pos += iNumMidiBytes;
+
+  KSSTREAM_HEADER packet;
+  memset(&packet, 0, sizeof packet);
+  packet.Size = sizeof(packet);
+  packet.PresentationTime.Time = 0;
+  packet.PresentationTime.Numerator = 1;
+  packet.PresentationTime.Denominator = 1;
+  packet.Data = const_cast<unsigned char*>(&data->m_Buffer[0]);
+  packet.DataUsed = ((pos+3)/4)*4;
+  packet.FrameExtent = data->m_Buffer.size();
+
+  data->m_pPin->WriteData(&packet, NULL);
+}
+
+#endif  // __WINDOWS_KS__
+
+//*********************************************************************//
+//  API: UNIX JACK
+//
+//  Written primarily by Alexander Svetalkin, with updates for delta
+//  time by Gary Scavone, April 2011.
+//
+//  *********************************************************************//
+
+#if defined(__UNIX_JACK__)
+
+// JACK header files
+#include <jack/jack.h>
+#include <jack/midiport.h>
+#include <jack/ringbuffer.h>
+
+#define JACK_RINGBUFFER_SIZE 16384 // Default size for ringbuffer
+
+struct JackMidiData {
+  jack_client_t *client;
+  jack_port_t *port;
+  jack_ringbuffer_t *buffSize;
+  jack_ringbuffer_t *buffMessage;
+  jack_time_t lastTime;
+  MidiInApi :: RtMidiInData *rtMidiIn;
+  };
+
+//*********************************************************************//
+//  API: JACK
+//  Class Definitions: MidiInJack
+//*********************************************************************//
+
+int jackProcessIn( jack_nframes_t nframes, void *arg )
+{
+  JackMidiData *jData = (JackMidiData *) arg;
+  MidiInApi :: RtMidiInData *rtData = jData->rtMidiIn;
+  jack_midi_event_t event;
+  jack_time_t long long time;
+
+  // Is port created?
+  if ( jData->port == NULL ) return 0;
+  void *buff = jack_port_get_buffer( jData->port, nframes );
+
+  // We have midi events in buffer
+  int evCount = jack_midi_get_event_count( buff );
+  if ( evCount > 0 ) {
+    MidiInApi::MidiMessage message;
+    message.bytes.clear();
+
+    jack_midi_event_get( &event, buff, 0 );
+
+    for (unsigned int i = 0; i < event.size; i++ )
+      message.bytes.push_back( event.buffer[i] );
+
+    // Compute the delta time.
+    time = jack_get_time();
+    if ( rtData->firstMessage == true )
+      rtData->firstMessage = false;
+    else
+      message.timeStamp = ( time - jData->lastTime ) * 0.000001;
+
+    jData->lastTime = time;
+
+    if ( !rtData->continueSysex ) {
+      if ( rtData->usingCallback ) {
+        RtMidiIn::RtMidiCallback callback = (RtMidiIn::RtMidiCallback) rtData->userCallback;
+        callback( message.timeStamp, &message.bytes, rtData->userData );
+      }
+      else {
+        // As long as we haven't reached our queue size limit, push the message.
+        if ( rtData->queue.size < rtData->queue.ringSize ) {
+          rtData->queue.ring[rtData->queue.back++] = message;
+          if ( rtData->queue.back == rtData->queue.ringSize )
+            rtData->queue.back = 0;
+          rtData->queue.size++;
+        }
+        else
+          std::cerr << "\nMidiInJack: message queue limit reached!!\n\n";
+      }
+    }
+  }
+
+  return 0;
+}
+
+MidiInJack :: MidiInJack( const std::string clientName, unsigned int queueSizeLimit ) : MidiInApi( queueSizeLimit )
+{
+  initialize( clientName );
+}
+
+void MidiInJack :: initialize( const std::string& clientName )
+{
+  JackMidiData *data = new JackMidiData;
+  apiData_ = (void *) data;
+
+  // Initialize JACK client
+  if (( data->client = jack_client_open( clientName.c_str(), JackNullOption, NULL )) == 0) {
+    errorString_ = "MidiInJack::initialize: JACK server not running?";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    return;
+  }
+
+  data->rtMidiIn = &inputData_;
+  data->port = NULL;
+
+  jack_set_process_callback( data->client, jackProcessIn, data );
+  jack_activate( data->client );
+}
+
+MidiInJack :: ~MidiInJack()
+{
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+  closePort();
+
+  jack_client_close( data->client );
+}
+
+void MidiInJack :: openPort( unsigned int portNumber, const std::string portName )
+{
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+
+  // Creating new port
+  if ( data->port == NULL)
+    data->port = jack_port_register( data->client, portName.c_str(),
+                                     JACK_DEFAULT_MIDI_TYPE, JackPortIsInput, 0 );
+
+  if ( data->port == NULL) {
+    errorString_ = "MidiInJack::openVirtualPort: JACK error creating virtual port";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Connecting to the output
+  std::string name = getPortName( portNumber );
+  jack_connect( data->client, name.c_str(), jack_port_name( data->port ) );
+}
+
+void MidiInJack :: openVirtualPort( const std::string portName )
+{
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+
+  if ( data->port == NULL )
+    data->port = jack_port_register( data->client, portName.c_str(),
+                                     JACK_DEFAULT_MIDI_TYPE, JackPortIsInput, 0 );
+
+  if ( data->port == NULL ) {
+    errorString_ = "MidiInJack::openVirtualPort: JACK error creating virtual port";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+}
+
+unsigned int MidiInJack :: getPortCount()
+{
+  int count = 0;
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+
+  // List of available ports
+  const char **ports = jack_get_ports( data->client, NULL, JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput );
+
+  if ( ports == NULL ) return 0;
+  while ( ports[count] != NULL )
+    count++;
+
+  free( ports );
+
+  return count;
+}
+
+std::string MidiInJack :: getPortName( unsigned int portNumber )
+{
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+  std::ostringstream ost;
+  std::string retStr("");
+
+  // List of available ports
+  const char **ports = jack_get_ports( data->client, NULL,
+                                       JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput );
+
+  // Check port validity
+  if ( ports == NULL ) {
+    errorString_ = "MidiInJack::getPortName: no ports available!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return retStr;
+  }
+
+  if ( ports[portNumber] == NULL ) {
+    ost << "MidiInJack::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+  else retStr.assign( ports[portNumber] );
+
+  free( ports );
+
+  return retStr;
+}
+
+void MidiInJack :: closePort()
+{
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+
+  if ( data->port == NULL ) return;
+  jack_port_unregister( data->client, data->port );
+  data->port = NULL;
+}
+
+//*********************************************************************//
+//  API: JACK
+//  Class Definitions: MidiOutJack
+//*********************************************************************//
+
+// Jack process callback
+int jackProcessOut( jack_nframes_t nframes, void *arg )
+{
+  JackMidiData *data = (JackMidiData *) arg;
+  jack_midi_data_t *midiData;
+  int space;
+
+  // Is port created?
+  if ( data->port == NULL ) return 0;
+
+  void *buff = jack_port_get_buffer( data->port, nframes );
+  jack_midi_clear_buffer( buff );
+
+  while ( jack_ringbuffer_read_space( data->buffSize ) > 0 ) {
+    jack_ringbuffer_read( data->buffSize, (char *) &space, (size_t) sizeof(space) );
+    midiData = jack_midi_event_reserve( buff, 0, space );
+
+    jack_ringbuffer_read( data->buffMessage, (char *) midiData, (size_t) space );
+  }
+
+  return 0;
+}
+
+MidiOutJack :: MidiOutJack( const std::string clientName ) : MidiOutApi()
+{
+  initialize( clientName );
+}
+
+void MidiOutJack :: initialize( const std::string& clientName )
+{
+  JackMidiData *data = new JackMidiData;
+
+  data->port = NULL;
+
+  // Initialize JACK client
+  if (( data->client = jack_client_open( clientName.c_str(), JackNullOption, NULL )) == 0) {
+    errorString_ = "MidiOutJack::initialize: JACK server not running?";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+    return;
+  }
+
+  jack_set_process_callback( data->client, jackProcessOut, data );
+  data->buffSize = jack_ringbuffer_create( JACK_RINGBUFFER_SIZE );
+  data->buffMessage = jack_ringbuffer_create( JACK_RINGBUFFER_SIZE );
+  jack_activate( data->client );
+
+  apiData_ = (void *) data;
+}
+
+MidiOutJack :: ~MidiOutJack()
+{
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+  closePort();
+
+  // Cleanup
+  jack_client_close( data->client );
+  jack_ringbuffer_free( data->buffSize );
+  jack_ringbuffer_free( data->buffMessage );
+
+  delete data;
+}
+
+void MidiOutJack :: openPort( unsigned int portNumber, const std::string portName )
+{
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+
+  // Creating new port
+  if ( data->port == NULL )
+    data->port = jack_port_register( data->client, portName.c_str(),
+      JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput, 0 );
+
+  if ( data->port == NULL ) {
+    errorString_ = "MidiOutJack::openVirtualPort: JACK error creating virtual port";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+
+  // Connecting to the output
+  std::string name = getPortName( portNumber );
+  jack_connect( data->client, jack_port_name( data->port ), name.c_str() );
+}
+
+void MidiOutJack :: openVirtualPort( const std::string portName )
+{
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+
+  if ( data->port == NULL )
+    data->port = jack_port_register( data->client, portName.c_str(),
+      JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput, 0 );
+
+  if ( data->port == NULL ) {
+    errorString_ = "MidiOutJack::openVirtualPort: JACK error creating virtual port";
+    RtMidi::error( RtError::DRIVER_ERROR, errorString_ );
+  }
+}
+
+unsigned int MidiOutJack :: getPortCount()
+{
+  int count = 0;
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+
+  // List of available ports
+  const char **ports = jack_get_ports( data->client, NULL,
+    JACK_DEFAULT_MIDI_TYPE, JackPortIsInput );
+
+  if ( ports == NULL ) return 0;
+  while ( ports[count] != NULL )
+    count++;
+
+  free( ports );
+
+  return count;
+}
+
+std::string MidiOutJack :: getPortName( unsigned int portNumber )
+{
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+  std::ostringstream ost;
+  std::string retStr("");
+
+  // List of available ports
+  const char **ports = jack_get_ports( data->client, NULL,
+    JACK_DEFAULT_MIDI_TYPE, JackPortIsInput );
+
+  // Check port validity
+  if ( ports == NULL) {
+    errorString_ = "MidiOutJack::getPortName: no ports available!";
+    RtMidi::error( RtError::WARNING, errorString_ );
+    return retStr;
+  }
+
+  if ( ports[portNumber] == NULL) {
+    ost << "MidiOutJack::getPortName: the 'portNumber' argument (" << portNumber << ") is invalid.";
+    errorString_ = ost.str();
+    RtMidi::error( RtError::WARNING, errorString_ );
+  }
+  else retStr.assign( ports[portNumber] );
+
+  free( ports );
+
+  return retStr;
+}
+
+void MidiOutJack :: closePort()
+{
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+
+  if ( data->port == NULL ) return;
+  jack_port_unregister( data->client, data->port );
+  data->port = NULL;
+}
+
+void MidiOutJack :: sendMessage( std::vector<unsigned char> *message )
+{
+  int nBytes = message->size();
+  JackMidiData *data = static_cast<JackMidiData *> (apiData_);
+
+  // Write full message to buffer
+  jack_ringbuffer_write( data->buffMessage, ( const char * ) &( *message )[0],
+                         message->size() );
+  jack_ringbuffer_write( data->buffSize, ( char * ) &nBytes, sizeof( nBytes ) );
+}
+
+#endif  // __UNIX_JACK__
--- /dev/null
+++ giada-0.7.2/src/rtmidi/configure.ac
@@ -0,0 +1,146 @@
+# Process this file with autoconf to produce a configure script.
+AC_INIT(RtMidi, 2.0, gary@music.mcgill.ca, rtmidi)
+AC_SUBST(VERSION, [2.0.1])
+AC_CONFIG_AUX_DIR(config)
+AC_CONFIG_SRCDIR(RtMidi.cpp)
+AC_CONFIG_FILES(rtmidi-config Makefile tests/Makefile)
+
+# Fill GXX with something before test.
+AC_SUBST( GXX, ["no"] )
+
+# Checks for programs.
+AC_PROG_CXX(g++ CC c++ cxx)
+AC_PROG_RANLIB
+AC_PATH_PROG(AR, ar, no)
+if [[ $AR = "no" ]] ; then
+    AC_MSG_ERROR("Could not find ar - needed to create a library");
+fi
+
+# Checks for header files.
+AC_HEADER_STDC
+#AC_CHECK_HEADERS(sys/ioctl.h unistd.h)
+
+# Check for debug
+AC_MSG_CHECKING(whether to compile debug version)
+AC_ARG_ENABLE(debug,
+  [  --enable-debug = enable various debug output],
+  [AC_SUBST( cppflag, [-D__RTMIDI_DEBUG__] ) AC_SUBST( cxxflag, [-g] ) AC_SUBST( object_path, [Debug] ) AC_MSG_RESULT(yes)],
+  [AC_SUBST( cppflag, [] ) AC_SUBST( cxxflag, [-O3] ) AC_SUBST( object_path, [Release] ) AC_MSG_RESULT(no)])
+
+# For -I and -D flags
+CPPFLAGS="$CPPFLAGS $cppflag"
+
+# For debugging and optimization ... overwrite default because it has both -g and -O2
+#CXXFLAGS="$CXXFLAGS $cxxflag"
+CXXFLAGS="$cxxflag"
+
+# Check compiler and use -Wall if gnu.
+if [test $GXX = "yes" ;] then
+  AC_SUBST( cxxflag, [-Wall] )
+fi
+
+CXXFLAGS="$CXXFLAGS $cxxflag"
+
+# Checks for package options and external software
+AC_CANONICAL_HOST
+
+AC_SUBST( sharedlib, ["librtmidi.so"] )
+AC_SUBST( sharedname, ["librtmidi.so.\$(MAJOR)"] )
+AC_SUBST( libflags, ["-shared -Wl,-soname,\$(SHARED).\$(MAJOR) -o \$(SHARED).\$(MAJOR).\$(RELEASE)"] )
+case $host in
+  *-apple*)
+  AC_SUBST( sharedlib, ["librtmidi.dylib"] )
+  AC_SUBST( sharedname, ["librtmidi.\$(RELEASE).dylib"] )
+  AC_SUBST( libflags, ["-dynamiclib -o librtmidi.\$(RELEASE).dylib"] )
+esac
+
+AC_SUBST( api, [""] )
+AC_SUBST( pc_requires, [""] )
+AC_MSG_CHECKING(for MIDI API)
+case $host in
+  *-*-linux*)
+  AC_ARG_WITH(jack, [  --with-jack = choose JACK server support (mac and linux only)], [
+  api="$api -D__UNIX_JACK__"
+  pc_requires="$pc_requires"
+  AC_MSG_RESULT(using JACK)
+  AC_CHECK_LIB(jack, jack_client_open, , AC_MSG_ERROR(JACK support requires the jack library!))
+  AC_SUBST(PC_FILE, [rtmidi.pc])
+  AC_SUBST(pc_requires, [jack])
+  AC_SUBST(SONAME, [rtmidi])
+  AC_CONFIG_FILES($PC_FILE:rtmidi.pc.in)] , )
+
+  # Look for ALSA flag
+  AC_ARG_WITH(alsa, [  --with-alsa = choose native ALSA sequencer API support (linux only)], [
+    api="$api -D__LINUX_ALSA__"
+    AC_MSG_RESULT(using ALSA)
+    AC_CHECK_LIB(asound, snd_seq_open, , AC_MSG_ERROR(ALSA support requires the asound library!))], )
+
+  if [test "$api" == "";] then
+    AC_MSG_RESULT(using ALSA)
+    AC_SUBST( api, [-D__LINUX_ALSA__] )
+    AC_CHECK_LIB(asound, snd_seq_open, , AC_MSG_ERROR(ALSA sequencer support requires the asound library!))
+  fi
+
+  # Checks for pthread library.
+  AC_CHECK_LIB(pthread, pthread_create, , AC_MSG_ERROR(RtMidi requires the pthread library!))
+  ;;
+
+  *-apple*)
+  AC_ARG_WITH(jack, [  --with-jack = choose JACK server support (mac and linux only)], [
+  api="$api -D__UNIX_JACK__"
+  AC_MSG_RESULT(using JACK)
+  AC_CHECK_LIB(jack, jack_client_open, , AC_MSG_ERROR(JACK support requires the jack library!))], )
+
+  # Look for Core flag
+  AC_ARG_WITH(core, [  --with-core = choose CoreMidi API support (mac only)], [
+    api="$api -D__MACOSX_CORE__"
+    AC_MSG_RESULT(using CoreMidi)
+    AC_CHECK_HEADER(CoreMIDI/CoreMIDI.h, [], [AC_MSG_ERROR(CoreMIDI header files not found!)] )
+    LIBS="$LIBS -framework CoreMIDI -framework CoreFoundation -framework CoreAudio" ], )
+
+  # If no api flags specified, use CoreMidi
+  if [test "$api" == ""; ] then
+    AC_SUBST( api, [-D__MACOSX_CORE__] )
+    AC_MSG_RESULT(using CoreMidi)
+    AC_CHECK_HEADER(CoreMIDI/CoreMIDI.h,
+      [],
+      [AC_MSG_ERROR(CoreMIDI header files not found!)] )
+    AC_SUBST( LIBS, ["-framework CoreMIDI -framework CoreFoundation -framework CoreAudio"] )
+  fi
+  ;;
+
+  *-mingw32*)
+  # Look for WinMM flag
+  AC_ARG_WITH(winmm, [  --with-winmm = choose Windows MultiMedia (MM) API support (windoze only)], [
+    api="$api -D__WINDOWS_MM__"
+    AC_MSG_RESULT(using WinMM)
+    AC_SUBST( LIBS, [-lwinmm] )], )
+
+  AC_ARG_WITH(winks, [  --with-winks = choose kernel streaming support (windoze only)], [
+    api="$api -D__WINDOWS_KS__"
+    AC_SUBST( LIBS, ["-lsetupapi -lksuser"] )
+    AC_MSG_RESULT(using kernel streaming) ], )
+
+  # I can't get the following check to work so just manually add the library
+	# or could try the following?  AC_LIB_WINMM([midiOutGetNumDevs])
+  # AC_CHECK_LIB(winmm, midiInGetNumDevs, , AC_MSG_ERROR(Windows MIDI support requires the winmm library!) )],)
+
+  # If no api flags specified, use WinMM
+  if [test "$api" == "";] then
+    AC_SUBST( api, [-D__WINDOWS_MM__] )
+    AC_MSG_RESULT(using WinMM)
+    AC_SUBST( LIBS, [-lwinmm] )
+  fi
+  ;;
+
+  *)
+  # Default case for unknown realtime systems.
+  AC_MSG_ERROR(Unknown system type for MIDI support!)
+  ;;
+esac
+
+CPPFLAGS="$CPPFLAGS $api"
+
+AC_OUTPUT
+
+chmod oug+x rtmidi-config
--- /dev/null
+++ giada-0.7.2/src/rtmidi/readme
@@ -0,0 +1,57 @@
+RtMidi - a set of C++ classes that provide a common API for realtime MIDI input/output across Linux (ALSA & Jack), Macintosh OS X (CoreMidi) and Windows (Multimedia & Kernel Streaming).
+
+By Gary P. Scavone, 2003-2012.
+
+This distribution of RtMidi contains the following:
+
+doc:      RtMidi documentation (see doc/html/index.html)
+tests:    example RtMidi programs
+
+On unix systems, type "./configure" in the top level directory, then "make" in the tests/ directory to compile the test programs.  In Windows, open the Visual C++ workspace file located in the tests/ directory.
+
+OVERVIEW:
+
+RtMidi is a set of C++ classes (RtMidiIn, RtMidiOut, and API specific classes) that provide a common API (Application Programming Interface) for realtime MIDI input/output across Linux (ALSA, Jack), Macintosh OS X (CoreMidi, Jack), SGI, and Windows (Multimedia Library, Kernel Streming) operating systems.  RtMidi significantly simplifies the process of interacting with computer MIDI hardware and software.  It was designed with the following goals:
+
+  - object oriented C++ design
+  - simple, common API across all supported platforms
+  - only two header files and one source file for easy inclusion in programming projects
+  - MIDI device enumeration
+
+MIDI input and output functionality are separated into two classes, RtMidiIn and RtMidiOut.  Each class instance supports only a single MIDI connection.  RtMidi does not provide timing functionality (i.e., output messages are sent immediately).  Input messages are timestamped with delta times in seconds (via a double floating point type).  MIDI data is passed to the user as raw bytes using an std::vector<unsigned char>.
+
+FURTHER READING:
+
+For complete documentation on RtMidi, see the doc directory of the distribution or surf to http://music.mcgill.ca/~gary/rtmidi/.
+
+
+LEGAL AND ETHICAL:
+
+The RtMidi license is similar to the the MIT License, with the added "feature" that modifications be sent to the developer.
+
+    RtMidi: realtime MIDI i/o C++ classes
+    Copyright (c) 2003-2012 Gary P. Scavone
+
+    Permission is hereby granted, free of charge, to any person
+    obtaining a copy of this software and associated documentation files
+    (the "Software"), to deal in the Software without restriction,
+    including without limitation the rights to use, copy, modify, merge,
+    publish, distribute, sublicense, and/or sell copies of the Software,
+    and to permit persons to whom the Software is furnished to do so,
+    subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be
+    included in all copies or substantial portions of the Software.
+
+    Any person wishing to distribute modifications to the Software is
+    asked to send the modifications to the original developer so that
+    they can be incorporated into the canonical version.  This is,
+    however, not a binding provision of this license.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--- /dev/null
+++ giada-0.7.2/src/rtmidi/rtmidi-config.in
@@ -0,0 +1,19 @@
+#! /bin/sh
+if (test "x$#" != "x1") ; then
+  echo "Usage: $0 [--libs | --cxxflags | --cppflags]"
+  exit;
+fi
+
+LIBRARY="@LIBS@"
+CXXFLAGS="@CXXFLAGS@"
+CPPFLAGS="@CPPFLAGS@"
+
+if (test "x$1" == "x--libs") ; then
+  echo "$LIBRARY"
+elif (test "x$1" == "x--cxxflags") ; then
+  echo "$CXXFLAGS"
+elif (test "x$1" == "x--cppflags") ; then
+  echo "$CPPFLAGS"
+else
+  echo "Unknown option: $1"
+fi
--- /dev/null
+++ giada-0.7.2/src/rtmidi/doc/release.txt
@@ -0,0 +1,87 @@
+RtMidi - a set of C++ classes that provides a common API for realtime MIDI input/output across Linux (ALSA & Jack), Macintosh OS X (CoreMidi & Jack), and Windows (Multimedia).
+
+By Gary P. Scavone, 2003-2012.
+
+v2.0.1: (26 July 2012)
+- small fixes for problems reported by Chris Arndt (scoping, preprocessor, and include)
+
+v2.0.0: (18 June 2012)
+- revised structure to support multiple simultaneous compiled APIs
+- revised ALSA client hierarchy so subsequent instances share same client (thanks to Dan Wilcox)
+- added beta Windows kernel streaming support (thanks to Sebastien Alaiwan)
+- updates to compile as a shared library or dll
+- updated license
+- various memory-leak fixes (thanks to Sebastien Alaiwan and Martin Koegler
+- fix for continue sysex problem (thanks to Luc Deschenaux)
+- removed SGI (IRIX) support
+
+v1.0.15: (11 August 2011)
+- updates for wide character support in Windows
+- stopped using std::queue and implemented internal MIDI ring buffer (for thread safety ... thanks to Michael Behrman)
+- removal of the setQueueSizeLimit() function ... queue size limit now an optional arguement to constructor
+
+v1.0.14: (17 April 2011)
+- bug fix to Jack MIDI support (thanks to Alexander Svetalkin and Pedro Lopez-Cabanillas)
+
+v1.0.13: (7 April 2011)
+- updated RtError.h to the same version as in RtAudio
+- new Jack MIDI support in Linux (thanks to Alexander Svetalkin)
+
+v1.0.12: (17 February 2011)
+- Windows 64-bit pointer fixes (thanks to Ward Kockelkorn)
+- removed possible exceptions from getPortName() functions
+- changed sysex sends in OS-X to use MIDISendSysex() function (thanks to Casey Tucker)
+- bug fixes to time code parsing in OS-X and ALSA (thanks to Greg)
+- added MSW project file to build as library (into lib/ directory ... thanks to Jason Champion)
+
+v1.0.11: (29 January 2010)
+- added CoreServices/CoreServices.h include for OS-X 10.6 and gcc4.2 compile (thanks to Jon McCormack)
+- various increment optimizations (thanks to Paul Dean)
+- fixed incorrectly located snd_seq_close() function in ALSA API (thanks to Pedro Lopez-Cabanillas)
+- updates to Windows sysex code to better deal with possible delivery problems (thanks to Bastiaan Verreijt)
+
+v1.0.10: (3 June 2009)
+- fix adding timestamp to OS-X sendMessage() function (thanks to John Dey)
+
+v1.0.9: (30 April 2009)
+- added #ifdef AVOID_TIMESTAMPING to conditionally compile support for event timestamping of ALSA sequencer events. This is useful for programs not needing timestamps, saving valuable system resources.
+- updated functionality in OSX_CORE for getting driver name (thanks to Casey Tucker)
+
+v1.0.8: (29 January 2009)
+- bug fixes for concatenating segmented sysex messages in ALSA (thanks to Christoph Eckert)
+- update to ALSA sequencer port enumeration (thanks to Pedro Lopez-Cabonillas)
+- bug fixes for concatenating segmented sysex messages in OS-X (thanks to Emmanuel Litzroth)
+- added functionality for naming clients (thanks to Pedro Lopez-Cabonillas and Axel Schmidt)
+- bug fix in Windows when receiving sysex messages if the ignore flag was set (thanks to Pedro Lopez-Cabonillas)
+
+v1.0.7: (7 December 2007)
+- configure and Makefile changes for MinGW
+- renamed midiinfo.cpp to midiprobe.cpp and updated VC++ project/workspace
+
+v1.0.6: (9 March 2006)
+- bug fix for timestamp problem in ALSA  (thanks to Pedro Lopez-Cabanillas)
+
+v1.0.5: (18 November 2005)
+- added optional port name to openVirtualPort() functions
+- fixed UNICODE problem in Windows getting device names (thanks Eduardo Coutinho!).
+- fixed bug in Windows with respect to getting Sysex data (thanks Jean-Baptiste Berruchon!)
+
+v1.0.4: (14 October 2005)
+- added check for status byte == 0xF8 if ignoring timing messages
+- changed pthread attribute to SCHED_OTHER (from SCHED_RR) to avoid thread problem when realtime cababilities are not enabled.
+- now using ALSA sequencer time stamp information (thanks to Pedro Lopez-Cabanillas)
+- fixed memory leak in ALSA implementation
+- now concatenate segmented sysex messages in ALSA
+
+v1.0.3: (22 November 2004)
+- added common pure virtual functions to RtMidi abstract base class
+
+v1.0.2: (21 September 2004)
+- added warning messages to openVirtualPort() functions in Windows and Irix (where it can't be implemented)
+
+v1.0.1: (20 September 2004)
+- changed ALSA preprocessor definition to __LINUX_ALSASEQ__
+
+v1.0.0: (17 September 2004)
+- first release of new independent class with both input and output functionality
+
--- /dev/null
+++ giada-0.7.2/src/rtmidi/doc/doxygen/header.html
@@ -0,0 +1,9 @@
+<HTML>
+<HEAD>
+<TITLE>The RtMidi Tutorial</TITLE>
+<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
+</HEAD>
+<BODY BGCOLOR="#FFFFFF">
+<CENTER>
+<a class="qindex" href="index.html">Tutorial</a> &nbsp; <a class="qindex" href="annotated.html">Class/Enum List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </CENTER>
+<HR>
--- /dev/null
+++ giada-0.7.2/src/rtmidi/doc/doxygen/footer.html
@@ -0,0 +1,9 @@
+<HR>
+
+<table><tr><td><img src="../images/mcgill.gif" width=165></td>
+  <td>&copy;2003-2012 Gary P. Scavone, McGill University. All Rights Reserved.<br>
+  Maintained by Gary P. Scavone, gary at music.mcgill.ca</td></tr>
+</table>
+
+</BODY>
+</HTML>
--- /dev/null
+++ giada-0.7.2/src/rtmidi/doc/doxygen/tutorial.txt
@@ -0,0 +1,476 @@
+/*! \mainpage The RtMidi Tutorial
+
+<CENTER>\ref intro &nbsp;&nbsp; \ref download &nbsp;&nbsp; \ref start &nbsp;&nbsp; \ref error &nbsp;&nbsp; \ref probing &nbsp;&nbsp; \ref output &nbsp;&nbsp; \ref input &nbsp;&nbsp; \ref virtual &nbsp;&nbsp; \ref compiling &nbsp;&nbsp; \ref debug &nbsp;&nbsp; \ref multi &nbsp;&nbsp; \ref apinotes &nbsp;&nbsp; \ref acknowledge &nbsp;&nbsp; \ref license</CENTER>
+
+\section intro Introduction
+
+RtMidi is a set of C++ classes (RtMidiIn, RtMidiOut and API-specific classes) that provides a common API (Application Programming Interface) for realtime MIDI input/output across Linux (ALSA & Jack), Macintosh OS X (CoreMidi & Jack), and Windows (Multimedia Library & Kernel Streaming) operating systems.  RtMidi significantly simplifies the process of interacting with computer MIDI hardware and software.  It was designed with the following goals:
+
+<UL>
+  <LI>object oriented C++ design</LI>
+  <LI>simple, common API across all supported platforms</LI>
+  <LI>only two header files and one source file for easy inclusion in programming projects</LI>
+  <LI>MIDI device enumeration</LI>
+</UL>
+
+Where applicable, multiple API support can be compiled and a particular API specified when creating an RtAudio instance.
+
+MIDI input and output functionality are separated into two classes, RtMidiIn and RtMidiOut.  Each class instance supports only a single MIDI connection.  RtMidi does not provide timing functionality (i.e., output messages are sent immediately).  Input messages are timestamped with delta times in seconds (via a \c double floating point type).  MIDI data is passed to the user as raw bytes using an std::vector<unsigned char>.
+
+\section whatsnew What's New (Version 2.0)
+
+No incompatable API changes were made in version 2.0, however, support for multiple compiled APIs (where available) was added (see \ref multi).  Other changes include: 1. Added Windows Kernel Streaming support (thanks to Sebastien Alaiwan), though not tested in Visual Studio (and timestamping is not implemented); and 2. Support for the IRIX (SGI) operating system was discontinued.
+
+\section download Download
+
+Latest Release (26 July 2012): <A href="http://www.music.mcgill.ca/~gary/rtmidi/release/rtmidi-2.0.1.tar.gz">Version 2.0.1</A>
+
+\section start Getting Started
+
+The first thing that must be done when using RtMidi is to create an instance of the RtMidiIn or RtMidiOut subclasses.  RtMidi is an abstract base class, which itself cannot be instantiated.  Each default constructor attempts to establish any necessary "connections" with the underlying MIDI system.  RtMidi uses C++ exceptions to report errors, necessitating try/catch blocks around many member functions.  An RtError can be thrown during instantiation in some circumstances.  A warning message may also be reported if no MIDI devices are found during instantiation.  The RtMidi classes have been designed to work with "hot pluggable" or virtual (software) MIDI devices, making it possible to connect to MIDI devices that may not have been present when the classes were instantiated.  The following code example demonstrates default object construction and destruction:
+
+\code
+
+#include "RtMidi.h"
+
+int main()
+{
+  RtMidiIn *midiin = 0;
+
+  // RtMidiIn constructor
+  try {
+    midiin = new RtMidiIn();
+  }
+  catch (RtError &error) {
+    // Handle the exception here
+    error.printMessage();
+  }
+
+  // Clean up
+  delete midiin;
+}
+\endcode
+
+Obviously, this example doesn't demonstrate any of the real functionality of RtMidi.  However, all uses of RtMidi must begin with construction and must end with class destruction.  Further, it is necessary that all class methods that can throw a C++ exception be called within a try/catch block.
+
+
+\section error Error Handling
+
+RtMidi uses a C++ exception handler called RtError, which is declared
+and defined in RtError.h.  The RtError class is quite simple but it
+does allow errors to be "caught" by RtError::Type.  Many RtMidi
+methods can "throw" an RtError, most typically if a driver error
+occurs or an invalid function argument is specified.  There are a
+number of cases within RtMidi where warning messages may be displayed
+but an exception is not thrown.  There is a protected RtMidi method,
+error(), that can be modified to globally control how these messages
+are handled and reported.  By default, error messages are not
+automatically displayed in RtMidi unless the preprocessor definition
+__RTMIDI_DEBUG__ is defined during compilation.  Messages associated
+with caught exceptions can be displayed with, for example, the
+RtError::printMessage() function.
+
+
+\section probing Probing Ports
+
+A programmer may wish to query the available MIDI ports before deciding which to use.  The following example outlines how this can be done.
+
+\code
+// midiprobe.cpp
+
+#include <iostream>
+#include <cstdlib>
+#include "RtMidi.h"
+
+int main()
+{
+  RtMidiIn  *midiin = 0;
+  RtMidiOut *midiout = 0;
+
+  // RtMidiIn constructor
+  try {
+    midiin = new RtMidiIn();
+  }
+  catch ( RtError &error ) {
+    error.printMessage();
+    exit( EXIT_FAILURE );
+  }
+
+  // Check inputs.
+  unsigned int nPorts = midiin->getPortCount();
+  std::cout << "\nThere are " << nPorts << " MIDI input sources available.\n";
+  std::string portName;
+  for ( unsigned int i=0; i<nPorts; i++ ) {
+    try {
+      portName = midiin->getPortName(i);
+    }
+    catch ( RtError &error ) {
+      error.printMessage();
+      goto cleanup;
+    }
+    std::cout << "  Input Port #" << i+1 << ": " << portName << '\n';
+  }
+
+  // RtMidiOut constructor
+  try {
+    midiout = new RtMidiOut();
+  }
+  catch ( RtError &error ) {
+    error.printMessage();
+    exit( EXIT_FAILURE );
+  }
+
+  // Check outputs.
+  nPorts = midiout->getPortCount();
+  std::cout << "\nThere are " << nPorts << " MIDI output ports available.\n";
+  for ( unsigned int i=0; i<nPorts; i++ ) {
+    try {
+      portName = midiout->getPortName(i);
+    }
+    catch (RtError &error) {
+      error.printMessage();
+      goto cleanup;
+    }
+    std::cout << "  Output Port #" << i+1 << ": " << portName << '\n';
+  }
+  std::cout << '\n';
+
+  // Clean up
+ cleanup:
+  delete midiin;
+  delete midiout;
+
+  return 0;
+}
+\endcode
+
+\section output MIDI Output
+
+The RtMidiOut class provides simple functionality to immediately send messages over a MIDI connection.  No timing functionality is provided.
+
+In the following example, we omit necessary error checking and details regarding OS-dependent sleep functions.  For a complete example, see the \c midiout.cpp program in the \c tests directory.
+
+\code
+// midiout.cpp
+
+#include <iostream>
+#include <cstdlib>
+#include "RtMidi.h"
+
+int main()
+{
+  RtMidiOut *midiout = new RtMidiOut();
+  std::vector<unsigned char> message;
+
+  // Check available ports.
+  unsigned int nPorts = midiout->getPortCount();
+  if ( nPorts == 0 ) {
+    std::cout << "No ports available!\n";
+    goto cleanup;
+  }
+
+  // Open first available port.
+  midiout->openPort( 0 );
+
+  // Send out a series of MIDI messages.
+
+  // Program change: 192, 5
+  message.push_back( 192 );
+  message.push_back( 5 );
+  midiout->sendMessage( &message );
+
+  // Control Change: 176, 7, 100 (volume)
+  message[0] = 176;
+  message[1] = 7;
+  message.push_back( 100 );
+  midiout->sendMessage( &message );
+
+  // Note On: 144, 64, 90
+  message[0] = 144;
+  message[1] = 64;
+  message[2] = 90;
+  midiout->sendMessage( &message );
+
+  SLEEP( 500 ); // Platform-dependent ... see example in tests directory.
+
+  // Note Off: 128, 64, 40
+  message[0] = 128;
+  message[1] = 64;
+  message[2] = 40;
+  midiout->sendMessage( &message );
+
+  // Clean up
+ cleanup:
+  delete midiout;
+
+  return 0;
+}
+\endcode
+
+
+\section input MIDI Input
+
+The RtMidiIn class uses an internal callback function or thread to receive incoming MIDI messages from a port or device.  These messages are then either queued and read by the user via calls to the RtMidiIn::getMessage() function or immediately passed to a user-specified callback function (which must be "registered" using the RtMidiIn::setCallback() function).  We'll provide examples of both usages.
+
+The RtMidiIn class provides the RtMidiIn::ignoreTypes() function to specify that certain MIDI message types be ignored.  By default, sysem exclusive, timing, and active sensing messages are ignored.
+
+\subsection qmidiin Queued MIDI Input
+
+The RtMidiIn::getMessage() function does not block.  If a MIDI message is available in the queue, it is copied to the user-provided \c std::vector<unsigned char> container.  When no MIDI message is available, the function returns an empty container.  The default maximum MIDI queue size is 1024 messages.  This value may be modified with the RtMidiIn::setQueueSizeLimit() function.  If the maximum queue size limit is reached, subsequent incoming MIDI messages are discarded until the queue size is reduced.
+
+In the following example, we omit some necessary error checking and details regarding OS-dependent sleep functions.  For a more complete example, see the \c qmidiin.cpp program in the \c tests directory.
+
+\code
+// qmidiin.cpp
+
+#include <iostream>
+#include <cstdlib>
+#include <signal.h>
+#include "RtMidi.h"
+
+bool done;
+static void finish(int ignore){ done = true; }
+
+int main()
+{
+  RtMidiIn *midiin = new RtMidiIn();
+  std::vector<unsigned char> message;
+  int nBytes, i;
+  double stamp;
+
+  // Check available ports.
+  unsigned int nPorts = midiin->getPortCount();
+  if ( nPorts == 0 ) {
+    std::cout << "No ports available!\n";
+    goto cleanup;
+  }
+  midiin->openPort( 0 );
+
+  // Don't ignore sysex, timing, or active sensing messages.
+  midiin->ignoreTypes( false, false, false );
+
+  // Install an interrupt handler function.
+  done = false;
+  (void) signal(SIGINT, finish);
+
+  // Periodically check input queue.
+  std::cout << "Reading MIDI from port ... quit with Ctrl-C.\n";
+  while ( !done ) {
+    stamp = midiin->getMessage( &message );
+    nBytes = message.size();
+    for ( i=0; i<nBytes; i++ )
+      std::cout << "Byte " << i << " = " << (int)message[i] << ", ";
+    if ( nBytes > 0 )
+      std::cout << "stamp = " << stamp << std::endl;
+
+    // Sleep for 10 milliseconds ... platform-dependent.
+    SLEEP( 10 );
+  }
+
+  // Clean up
+ cleanup:
+  delete midiin;
+
+  return 0;
+}
+\endcode
+
+\subsection cmidiin MIDI Input with User Callback
+
+When set, a user-provided callback function will be invoked after the input of a complete MIDI message.  It is possible to provide a pointer to user data that can be accessed in the callback function (not shown here).  It is necessary to set the callback function immediately after opening the port to avoid having incoming messages written to the queue (which is not emptied when a callback function is set).  If you are worried about this happening, you can check the queue using the RtMidi::getMessage() function to verify it is empty (after the callback function is set).
+
+In the following example, we omit some necessary error checking.  For a more complete example, see the \c cmidiin.cpp program in the \c tests directory.
+
+\code
+// cmidiin.cpp
+
+#include <iostream>
+#include <cstdlib>
+#include "RtMidi.h"
+
+void mycallback( double deltatime, std::vector< unsigned char > *message, void *userData )
+{
+  unsigned int nBytes = message->size();
+  for ( unsigned int i=0; i<nBytes; i++ )
+    std::cout << "Byte " << i << " = " << (int)message->at(i) << ", ";
+  if ( nBytes > 0 )
+    std::cout << "stamp = " << deltatime << std::endl;
+}
+
+int main()
+{
+  RtMidiIn *midiin = new RtMidiIn();
+
+  // Check available ports.
+  unsigned int nPorts = midiin->getPortCount();
+  if ( nPorts == 0 ) {
+    std::cout << "No ports available!\n";
+    goto cleanup;
+  }
+
+  midiin->openPort( 0 );
+
+  // Set our callback function.  This should be done immediately after
+  // opening the port to avoid having incoming messages written to the
+  // queue.
+  midiin->setCallback( &mycallback );
+
+  // Don't ignore sysex, timing, or active sensing messages.
+  midiin->ignoreTypes( false, false, false );
+
+  std::cout << "\nReading MIDI input ... press <enter> to quit.\n";
+  char input;
+  std::cin.get(input);
+
+  // Clean up
+ cleanup:
+  delete midiin;
+
+  return 0;
+}
+\endcode
+
+\section virtual Virtual Ports
+
+The Linux ALSA and Macintosh CoreMIDI APIs allow for the establishment of virtual input and output MIDI ports to which other software clients can connect.  RtMidi incorporates this functionality with the RtMidiIn::openVirtualPort() and RtMidiOut::openVirtualPort() functions.  Any messages sent with the RtMidiOut::sendMessage() function will also be transmitted through an open virtual output port.  If a virtual input port is open and a user callback function is set, the callback function will be invoked when messages arrive via that port.  If a callback function is not set, the user must poll the input queue to check whether messages have arrived.  No notification is provided for the establishment of a client connection via a virtual port.
+
+\section compiling Compiling
+
+In order to compile RtMidi for a specific OS and API, it is necessary to supply the appropriate preprocessor definition and library within the compiler statement:
+<P>
+
+<TABLE BORDER=2 COLS=5 WIDTH="100%">
+<TR BGCOLOR="beige">
+  <TD WIDTH="5%"><B>OS:</B></TD>
+  <TD WIDTH="5%"><B>MIDI API:</B></TD>
+  <TD WIDTH="5%"><B>Preprocessor Definition:</B></TD>
+  <TD WIDTH="5%"><B>Library or Framework:</B></TD>
+  <TD><B>Example Compiler Statement:</B></TD>
+</TR>
+<TR>
+  <TD>Linux</TD>
+  <TD>ALSA Sequencer</TD>
+  <TD>__LINUX_ALSA__</TD>
+  <TD><TT>asound, pthread</TT></TD>
+  <TD><TT>g++ -Wall -D__LINUX_ALSA__ -o midiprobe midiprobe.cpp RtMidi.cpp -lasound -lpthread</TT></TD>
+</TR>
+<TR>
+  <TD>Linux or Mac</TD>
+  <TD>Jack MIDI</TD>
+  <TD>__UNIX_JACK__</TD>
+  <TD><TT>jack</TT></TD>
+  <TD><TT>g++ -Wall -D__UNIX_JACK__ -o midiprobe midiprobe.cpp RtMidi.cpp -ljack</TT></TD>
+</TR>
+<TR>
+  <TD>Macintosh OS X</TD>
+  <TD>CoreMidi</TD>
+  <TD>__MACOSX_CORE__</TD>
+  <TD><TT>CoreMidi, CoreAudio, CoreFoundation</TT></TD>
+  <TD><TT>g++ -Wall -D__MACOSX_CORE__ -o midiprobe midiprobe.cpp RtMidi.cpp -framework CoreMIDI -framework CoreAudio -framework CoreFoundation</TT></TD>
+</TR>
+<TR>
+  <TD>Windows</TD>
+  <TD>Multimedia Library</TD>
+  <TD>__WINDOWS_MM__</TD>
+  <TD><TT>winmm.lib, multithreaded</TT></TD>
+  <TD><I>compiler specific</I></TD>
+</TR>
+<TR>
+  <TD>Windows</TD>
+  <TD>Kernel Streaming</TD>
+  <TD>__WINDOWS_KS__</TD>
+  <TD><TT>ks.h, ksmedia.h, setupapi.lib, ksuser.lib, multithreaded</TT></TD>
+  <TD><I>compiler specific</I></TD>
+</TR>
+</TABLE>
+<P>
+
+The example compiler statements above could be used to compile the <TT>midiprobe.cpp</TT> example file, assuming that <TT>midiprobe.cpp</TT>, <TT>RtMidi.h</TT>, <tt>RtError.h</tt>, and <TT>RtMidi.cpp</TT> all exist in the same directory.
+
+\section debug Debugging
+
+If you are having problems getting RtMidi to run on your system, try passing the preprocessor definition <TT>__RTMIDI_DEBUG__</TT> to the compiler (or define it in RtMidi.h).  A variety of warning messages will be displayed that may help in determining the problem.  Also try using the programs included in the <tt>test</tt> directory.  The program <tt>midiprobe</tt> displays the queried capabilities of all MIDI ports found.
+
+\section multi Using Simultaneous Multiple APIs
+
+Support for each MIDI API is encapsulated in specific MidiInApi or MidiOutApi subclasses, making it possible to compile and instantiate multiple API-specific subclasses on a given operating system.  For example, one can compile both the CoreMIDI and Jack support on the OS-X operating system by providing the appropriate preprocessor definitions for each.  In a run-time situation, one might first attempt to determine whether any Jack ports are available.  This can be done by specifying the api argument RtMidi::UNIX_JACK when attempting to create an instance of RtMidiIn or RtMidiOut.  If no available ports are found, then an instance of RtMidi with the api argument RtMidi::MACOSX_CORE can be created.  Alternately, if no api argument is specified, RtMidi will first look for CoreMIDI ports and if none are found, then Jack ports (in linux, the search order is ALSA and then Jack; in windows, the search order is WinMM and then WinKS).  In theory, it should also be possible to have separate instances of RtMidi open at the same time with different underlying API support, though this has not been tested.
+
+The static function RtMidi::getCompiledApi() is provided to determine the available compiled API support.  The function RtMidi::getCurrentApi() indicates the API selected for a given RtMidi instance.
+
+\section apinotes API Notes
+
+RtMidi is designed to provide a common API across the various supported operating systems and audio libraries.  Despite that, some issues should be mentioned with regard to each.
+
+\subsection linux Linux:
+
+RtMidi for Linux was developed using the Fedora distribution.  Two different MIDI APIs are supported on Linux platforms: <A href="http://www.alsa-project.org/">ALSA</A> and <A href="http://jackit.sourceforge.net/">Jack</A>. A decision was made to not include support for the OSS API because the OSS API provides such limited functionality and because <A href="http://www.alsa-project.org/">ALSA</A> support is now incorporated in the Linux kernel.  The ALSA sequencer and Jack APIs allows for virtual software input and output ports. 
+
+\subsection macosx Macintosh OS X (CoreAudio):
+
+The Apple CoreMidi API allows for the establishment of virtual input and output ports to which other software applications can connect.
+
+The RtMidi Jack support can be compiled on Macintosh OS-X systems, as well as in Linux.
+
+\subsection windowsds Windows (Multimedia Library):
+
+The \c configure script provides support for the MinGW compiler.
+
+The Windows Multimedia library MIDI calls used in RtMidi do not make use of streaming functionality.   Incoming system exclusive messages read by RtMidiIn are limited to a length as defined by the preprocessor definition RT_SYSEX_BUFFER_SIZE (set in RtMidi.cpp).  The default value is 1024.  There is no such limit for outgoing sysex messages via RtMidiOut.
+
+RtMidi was originally developed with Visual C++ version 6.0.
+
+The \c configure script provides support for the MinGW compiler.
+
+\section acknowledge Acknowledgements
+
+Many thanks to the following people for providing bug fixes and improvements:
+<UL>
+<LI>Sebastien Alaiwan (Jack memory leaks, Windows kernel streaming)</LI>
+<LI>Jean-Baptiste Berruchon (Windows sysex code)</LI>
+<LI>Pedro Lopez-Cabanillas (ALSA sequencer API, client naming)</LI>
+<LI>Jason Champion (MSW project file for library build)</LI>
+<LI>Eduardo Coutinho (Windows device names)</LI>
+<LI>Paul Dean (increment optimization)</LI>
+<LI>Luc Deschenaux (sysex issues)</LI>
+<LI>John Dey (OS-X timestamps)</LI>
+<LI>Christoph Eckert (ALSA sysex fixes)</LI>
+<LI>Martin Koegler (various fixes)</LI>
+<LI>Immanuel Litzroth (OS-X sysex fix)</LI>
+<LI>Jon McCormack (Snow Leopard updates)</LI>
+<LI>Axel Schmidt (client naming)</LI>
+<LI>Alexander Svetalkin (Jack MIDI)</LI>
+<LI>Casey Tucker (OS-X driver information, sysex sending)</LI>
+<LI>Bastiaan Verreijt (Windows sysex multi-buffer code)</LI>
+<LI>Dan Wilcox</LI>
+</UL>
+
+\section license License
+
+    RtMidi: realtime MIDI i/o C++ classes<BR>
+    Copyright (c) 2003-2012 Gary P. Scavone
+
+    Permission is hereby granted, free of charge, to any person
+    obtaining a copy of this software and associated documentation files
+    (the "Software"), to deal in the Software without restriction,
+    including without limitation the rights to use, copy, modify, merge,
+    publish, distribute, sublicense, and/or sell copies of the Software,
+    and to permit persons to whom the Software is furnished to do so,
+    subject to the following conditions:
+
+    The above copyright notice and this permission notice shall be
+    included in all copies or substantial portions of the Software.
+
+    Any person wishing to distribute modifications to the Software is
+    asked to send the modifications to the original developer so that
+    they can be incorporated into the canonical version.  This is,
+    however, not a binding provision of this license.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
+    ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
+    CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+*/
--- /dev/null
+++ giada-0.7.2/src/rtmidi/doc/doxygen/Doxyfile
@@ -0,0 +1,1566 @@
+# Doxyfile 1.6.2
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file 
+# that follow. The default is UTF-8 which is also the encoding used for all 
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the 
+# iconv built into libc) for the transcoding. See 
+# http://www.gnu.org/software/libiconv for the list of possible encodings.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = RtMidi
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. 
+# This could be handy for archiving the generated documentation or 
+# if some version control system is used.
+
+PROJECT_NUMBER         = 2.0.1
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
+# base path where the generated documentation will be put. 
+# If a relative path is entered, it will be relative to the location 
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = .
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 
+# 4096 sub-directories (in 2 levels) under the output directory of each output 
+# format and will distribute the generated files over these directories. 
+# Enabling this option can be useful when feeding doxygen a huge amount of 
+# source files, where putting all generated files in the same directory would 
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all 
+# documentation generated by doxygen is written. Doxygen will use this 
+# information to generate all constant output in the proper language. 
+# The default language is English, other supported languages are: 
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional, 
+# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German, 
+# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English 
+# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian, 
+# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak, 
+# Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will 
+# include brief member descriptions after the members that are listed in 
+# the file and class documentation (similar to JavaDoc). 
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend 
+# the brief description of a member or function before the detailed description. 
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the 
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator 
+# that is used to form the text in various listings. Each string 
+# in this list, if found as the leading text of the brief description, will be 
+# stripped from the text and the result after processing the whole list, is 
+# used as the annotated text. Otherwise, the brief description is used as-is. 
+# If left blank, the following values are used ("$name" is automatically 
+# replaced with the name of the entity): "The $name class" "The $name widget" 
+# "The $name file" "is" "provides" "specifies" "contains" 
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       = 
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then 
+# Doxygen will generate a detailed section even if there is only a brief 
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all 
+# inherited members of a class in the documentation of that class as if those 
+# members were ordinary class members. Constructors, destructors and assignment 
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full 
+# path before files name in the file list and in the header files. If set 
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag 
+# can be used to strip a user-defined part of the path. Stripping is 
+# only done if one of the specified strings matches the left-hand part of 
+# the path. The tag can be used to show relative paths in the file list. 
+# If left blank the directory from which doxygen is run is used as the 
+# path to strip.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of 
+# the path mentioned in the documentation of a class, which tells 
+# the reader which header file to include in order to use a class. 
+# If left blank only the name of the header file containing the class 
+# definition is used. Otherwise one should specify the include paths that 
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter 
+# (but less readable) file names. This can be useful is your file systems 
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
+# will interpret the first line (until the first dot) of a JavaDoc-style 
+# comment as the brief description. If set to NO, the JavaDoc 
+# comments will behave just like regular Qt-style comments 
+# (thus requiring an explicit @brief command for a brief description.)
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then Doxygen will 
+# interpret the first line (until the first dot) of a Qt-style 
+# comment as the brief description. If set to NO, the comments 
+# will behave just like regular Qt-style comments (thus requiring 
+# an explicit \brief command for a brief description.)
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen 
+# treat a multi-line C++ special comment block (i.e. a block of //! or /// 
+# comments) as a brief description. This used to be the default behaviour. 
+# The new default is to treat a multi-line C++ comment block as a detailed 
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented 
+# member inherits the documentation from any documented member that it 
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce 
+# a new page for each member. If set to NO, the documentation of a member will 
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. 
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts 
+# as commands in the documentation. An alias has the form "name=value". 
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to 
+# put the command \sideeffect (or @sideeffect) in the documentation, which 
+# will result in a user-defined paragraph with heading "Side Effects:". 
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C 
+# sources only. Doxygen will then generate output that is more tailored for C. 
+# For instance, some of the names that are used will be different. The list 
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Java. For instance, namespaces will be presented as packages, qualified 
+# scopes will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran 
+# sources only. Doxygen will then generate output that is more tailored for 
+# Fortran.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL 
+# sources. Doxygen will then generate output that is tailored for 
+# VHDL.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it parses. 
+# With this tag you can assign which parser to use for a given extension. 
+# Doxygen has a built-in mapping, but you can override or extend it using this tag. 
+# The format is ext=language, where ext is a file extension, and language is one of 
+# the parsers supported by doxygen: IDL, Java, Javascript, C#, C, C++, D, PHP, 
+# Objective-C, Python, Fortran, VHDL, C, C++. For instance to make doxygen treat 
+# .inc files as Fortran files (default is PHP), and .f files as C (default is Fortran), 
+# use: inc=Fortran f=C. Note that for custom extensions you also need to set
+# FILE_PATTERNS otherwise the files are not read by doxygen.
+
+EXTENSION_MAPPING      = 
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want 
+# to include (a tag file for) the STL sources as input, then you should 
+# set this tag to YES in order to let doxygen match functions declarations and 
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s. 
+# func(std::string) {}). This also make the inheritance and collaboration 
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to 
+# enable parsing support.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only. 
+# Doxygen will parse them like normal C++ but will assume all classes use public 
+# instead of private inheritance when no explicit protection keyword is present.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate getter 
+# and setter methods for a property. Setting this option to YES (the default) 
+# will make doxygen to replace the get and set methods by a property in the 
+# documentation. This will only work if the methods are indeed getting or 
+# setting a simple type. If this is not the case, or you want to show the 
+# methods anyway, you should set this option to NO.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC 
+# tag is set to YES, then doxygen will reuse the documentation of the first 
+# member in the group (if any) for the other members of the group. By default 
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of 
+# the same type (for instance a group of public functions) to be put as a 
+# subgroup of that type (e.g. under the Public Functions section). Set it to 
+# NO to prevent subgrouping. Alternatively, this can be done per class using 
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum 
+# is documented as struct, union, or enum with the name of the typedef. So 
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct 
+# with name TypeT. When disabled the typedef will appear as a member of a file, 
+# namespace, or class. And the struct will be named TypeS. This can typically 
+# be useful for C code in case the coding convention dictates that all compound 
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to 
+# determine which symbols to keep in memory and which to flush to disk. 
+# When the cache is full, less often used symbols will be written to disk. 
+# For small to medium size projects (<1000 input files) the default value is 
+# probably good enough. For larger projects a too small cache size can cause 
+# doxygen to be busy swapping symbols to and from disk most of the time 
+# causing a significant performance penality. 
+# If the system has enough physical memory increasing the cache will improve the 
+# performance by keeping more symbols in memory. Note that the value works on 
+# a logarithmic scale so increasing the size by one will rougly double the 
+# memory usage. The cache size is given by this formula: 
+# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0, 
+# corresponding to a cache size of 2^16 = 65536 symbols
+
+SYMBOL_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in 
+# documentation are documented, even if no documentation was available. 
+# Private class members and static file members will be hidden unless 
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class 
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file 
+# will be included in the documentation.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) 
+# defined locally in source files will be included in the documentation. 
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local 
+# methods, which are defined in the implementation section but not in 
+# the interface are included in the documentation. 
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be 
+# extracted and appear in the documentation as a namespace called 
+# 'anonymous_namespace{file}', where file will be replaced with the base 
+# name of the file that contains the anonymous namespace. By default 
+# anonymous namespace are hidden.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all 
+# undocumented members of documented classes, files or namespaces. 
+# If set to NO (the default) these members will be included in the 
+# various overviews, but no documentation section is generated. 
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = YES
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all 
+# undocumented classes that are normally visible in the class hierarchy. 
+# If set to NO (the default) these classes will be included in the various 
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all 
+# friend (class|struct|union) declarations. 
+# If set to NO (the default) these declarations will be included in the 
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any 
+# documentation blocks found inside the body of a function. 
+# If set to NO (the default) these blocks will be appended to the 
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation 
+# that is typed after a \internal command is included. If the tag is set 
+# to NO (the default) then the documentation will be excluded. 
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate 
+# file names in lower-case letters. If set to YES upper-case letters are also 
+# allowed. This is useful if you have classes or files whose names only differ 
+# in case and if your file system supports case sensitive file names. Windows 
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen 
+# will show members with their full class and namespace scopes in the 
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen 
+# will put a list of the files that are included by a file in the documentation 
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen 
+# will list include files with double quotes in the documentation 
+# rather than with sharp brackets.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] 
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen 
+# will sort the (detailed) documentation of file and class members 
+# alphabetically by member name. If set to NO the members will appear in 
+# declaration order.
+
+SORT_MEMBER_DOCS       = NO
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the 
+# brief documentation of file, namespace and class members alphabetically 
+# by member name. If set to NO (the default) the members will appear in 
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen
+# will sort the (brief and detailed) documentation of class members so that
+# constructors and destructors are listed first. If set to NO (the default)
+# the constructors will appear in the respective orders defined by
+# SORT_MEMBER_DOCS and SORT_BRIEF_DOCS.
+# This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO
+# and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the 
+# hierarchy of group names into alphabetical order. If set to NO (the default) 
+# the group names will appear in their defined order.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be 
+# sorted by fully-qualified names, including namespaces. If set to 
+# NO (the default), the class list will be sorted only by class name, 
+# not including the namespace part. 
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES. 
+# Note: This option applies only to the class list, not to the 
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or 
+# disable (NO) the todo list. This list is created by putting \todo 
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or 
+# disable (NO) the test list. This list is created by putting \test 
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or 
+# disable (NO) the bug list. This list is created by putting \bug 
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or 
+# disable (NO) the deprecated list. This list is created by putting 
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional 
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines 
+# the initial value of a variable or define consists of for it to appear in 
+# the documentation. If the initializer consists of more lines than specified 
+# here it will be hidden. Use a value of 0 to hide initializers completely. 
+# The appearance of the initializer of individual variables and defines in the 
+# documentation can be controlled using \showinitializer or \hideinitializer 
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated 
+# at the bottom of the documentation of classes and structs. If set to YES the 
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories 
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy 
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. 
+# This will remove the Files entry from the Quick Index and from the 
+# Folder Tree View (if specified). The default is YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the 
+# Namespaces page.  This will remove the Namespaces entry from the Quick Index 
+# and from the Folder Tree View (if specified). The default is YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that 
+# doxygen should invoke to get the current version for each file (typically from 
+# the version control system). Doxygen will invoke the program by executing (via 
+# popen()) the command <command> <input-file>, where <command> is the value of 
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file 
+# provided by doxygen. Whatever the program writes to standard output 
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    = 
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed by 
+# doxygen. The layout file controls the global structure of the generated output files 
+# in an output format independent way. The create the layout file that represents 
+# doxygen's defaults, run doxygen with the -l option. You can optionally specify a 
+# file name after the option, if omitted DoxygenLayout.xml will be used as the name 
+# of the layout file.
+
+LAYOUT_FILE            = 
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated 
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are 
+# generated by doxygen. Possible values are YES and NO. If left blank 
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings 
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will 
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for 
+# potential errors in the documentation, such as not documenting some 
+# parameters in a documented function, or documenting parameters that 
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for 
+# functions that are documented, but have no documentation for their parameters 
+# or return value. If set to NO (the default) doxygen will only warn about 
+# wrong or incomplete parameter documentation, but not about the absence of 
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that 
+# doxygen can produce. The string should contain the $file, $line, and $text 
+# tags, which will be replaced by the file and line number from which the 
+# warning originated and the warning text. Optionally the format may contain 
+# $version, which will be replaced by the version of the file (if it could 
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning 
+# and error messages should be written. If left blank the output is written 
+# to stderr.
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain 
+# documented source files. You may enter file names like "myfile.cpp" or 
+# directories like "/usr/src/myproject". Separate the files or directories 
+# with spaces.
+
+INPUT                  = tutorial.txt \
+                         ../../RtMidi.h \
+                         ../../RtError.h
+
+# This tag can be used to specify the character encoding of the source files 
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is 
+# also the default input encoding. Doxygen uses libiconv (or the iconv built 
+# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for 
+# the list of possible encodings.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the 
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank the following patterns are tested: 
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx 
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py *.f90
+
+FILE_PATTERNS          = 
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories 
+# should be searched for input files as well. Possible values are YES and NO. 
+# If left blank NO is used.
+
+RECURSIVE              = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should 
+# excluded from the INPUT source files. This way you can easily exclude a 
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or 
+# directories that are symbolic links (a Unix filesystem feature) are excluded 
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the 
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude 
+# certain files from those directories. Note that the wildcards are matched 
+# against the file with absolute path, so to exclude all test directories 
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = 
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names 
+# (namespaces, classes, functions, etc.) that should be excluded from the 
+# output. The symbol name can be a fully qualified name, a word, or if the 
+# wildcard * is used, a substring. Examples: ANamespace, AClass, 
+# AClass::ANamespace, ANamespace::*Test
+
+EXCLUDE_SYMBOLS        = 
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or 
+# directories that contain example code fragments that are included (see 
+# the \include command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the 
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp 
+# and *.h) to filter out the source-files in the directories. If left 
+# blank all files are included.
+
+EXAMPLE_PATTERNS       = 
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be 
+# searched for input files to be used with the \include or \dontinclude 
+# commands irrespective of the value of the RECURSIVE tag. 
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or 
+# directories that contain image that are included in the documentation (see 
+# the \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should 
+# invoke to filter for each input file. Doxygen will invoke the filter program 
+# by executing (via popen()) the command <filter> <input-file>, where <filter> 
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an 
+# input file. Doxygen will then use the output that the filter program writes 
+# to standard output.  If FILTER_PATTERNS is specified, this tag will be 
+# ignored.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern 
+# basis.  Doxygen will compare the file name with each pattern and apply the 
+# filter if there is a match.  The filters are a list of the form: 
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further 
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER 
+# is applied to all files.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using 
+# INPUT_FILTER) will be used to filter the input files when producing source 
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will 
+# be generated. Documented entities will be cross-referenced with these sources. 
+# Note: To get rid of all source code in the generated output, make sure also 
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body 
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct 
+# doxygen to hide any special comment blocks from generated source code 
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES 
+# then for each documented function all documented 
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES 
+# then for each documented function all documented entities 
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default) 
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from 
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will 
+# link to the source code.  Otherwise they will link to the documentation.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code 
+# will point to the HTML generated by the htags(1) tool instead of doxygen 
+# built-in source browser. The htags tool is part of GNU's global source 
+# tagging system (see http://www.gnu.org/software/global/global.html). You 
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen 
+# will generate a verbatim copy of the header file for each class for 
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index 
+# of all compounds will be generated. Enable this if the project 
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then 
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns 
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all 
+# classes will be put under the same header in the alphabetical index. 
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that 
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = ../html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for 
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank 
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard header.
+
+HTML_HEADER            = header.html
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for 
+# each generated HTML page. If it is left blank doxygen will generate a 
+# standard footer.
+
+HTML_FOOTER            = footer.html
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading 
+# style sheet that is used by each HTML page. It can be used to 
+# fine-tune the look of the HTML output. If the tag is left blank doxygen 
+# will generate a default style sheet. Note that doxygen will try to copy 
+# the style sheet file to the HTML output directory, so don't put your own 
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        = 
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML 
+# page will contain the date and time when the page was generated. Setting 
+# this to NO can help when comparing the output of multiple runs.
+
+HTML_TIMESTAMP         = NO
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, 
+# files or namespaces will be aligned in HTML using tables. If set to 
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML 
+# documentation will contain sections that can be hidden and shown after the 
+# page has loaded. For this to work a browser that supports 
+# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox 
+# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files 
+# will be generated that can be used as input for Apple's Xcode 3 
+# integrated development environment, introduced with OSX 10.5 (Leopard). 
+# To create a documentation set, doxygen will generate a Makefile in the 
+# HTML output directory. Running make will produce the docset in that 
+# directory and running "make install" will install the docset in 
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find 
+# it at startup. 
+# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html for more information.
+
+GENERATE_DOCSET        = NO
+
+# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the 
+# feed. A documentation feed provides an umbrella under which multiple 
+# documentation sets from a single provider (such as a company or product suite) 
+# can be grouped.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that 
+# should uniquely identify the documentation set bundle. This should be a 
+# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen 
+# will append .docset to the name.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files 
+# will be generated that can be used as input for tools like the 
+# Microsoft HTML help workshop to generate a compiled HTML help file (.chm) 
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can 
+# be used to specify the file name of the resulting .chm file. You 
+# can add a path in front of the file if the result should not be 
+# written to the html output directory.
+
+CHM_FILE               = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can 
+# be used to specify the location (absolute path including file name) of 
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run 
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag 
+# controls if a separate .chi index file is generated (YES) or that 
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING 
+# is used to encode HtmlHelp index (hhk), content (hhc) and project file 
+# content.
+
+CHM_INDEX_ENCODING     = 
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag 
+# controls whether a binary table of contents is generated (YES) or a 
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members 
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and QHP_VIRTUAL_FOLDER 
+# are set, an additional index file will be generated that can be used as input for 
+# Qt's qhelpgenerator to generate a Qt Compressed Help (.qch) of the generated 
+# HTML documentation.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can 
+# be used to specify the file name of the resulting .qch file. 
+# The path specified is relative to the HTML output folder.
+
+QCH_FILE               = 
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#namespace
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating 
+# Qt Help Project output. For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#virtual-folders
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to add. 
+# For more information please see 
+# http://doc.trolltech.com/qthelpproject.html#custom-filters
+
+QHP_CUST_FILTER_NAME   = 
+
+# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the custom filter to add.For more information please see 
+# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">Qt Help Project / Custom Filters</a>.
+
+QHP_CUST_FILTER_ATTRS  = 
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this project's 
+# filter section matches. 
+# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">Qt Help Project / Filter Attributes</a>.
+
+QHP_SECT_FILTER_ATTRS  = 
+
+# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can 
+# be used to specify the location of Qt's qhelpgenerator. 
+# If non-empty doxygen will try to run qhelpgenerator on the generated 
+# .qhp file.
+
+QHG_LOCATION           = 
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files  
+# will be generated, which together with the HTML files, form an Eclipse help  
+# plugin. To install this plugin and make it available under the help contents 
+# menu in Eclipse, the contents of the directory containing the HTML and XML 
+# files needs to be copied into the plugins directory of eclipse. The name of 
+# the directory within the plugins directory should be the same as 
+# the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before
+# the help appears.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the eclipse help plugin. When installing the plugin 
+# the directory name containing the HTML and XML files should also have 
+# this name.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at 
+# top of each HTML page. The value NO (the default) enables the index and 
+# the value YES disables it.
+
+DISABLE_INDEX          = YES
+
+# This tag can be used to set the number of enum values (range [1..20]) 
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index 
+# structure should be generated to display hierarchical information. 
+# If the tag value is set to YES, a side panel will be generated 
+# containing a tree-like index structure (just like the one that 
+# is generated for HTML Help). For this to work a browser that supports 
+# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser). 
+# Windows users are probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = NO
+
+# By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories, 
+# and Class Hierarchy pages using a tree view instead of an ordered list.
+
+USE_INLINE_TREES       = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be 
+# used to set the initial width (in pixels) of the frame in which the tree 
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+# Use this tag to change the font size of Latex formulas included 
+# as images in the HTML documentation. The default is 10. Note that 
+# when you change the font size after a successful doxygen run you need 
+# to manually remove any form_*.png images from the HTML output directory 
+# to force them to be regenerated.
+
+FORMULA_FONTSIZE       = 10
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box
+# for the HTML output. The underlying search engine uses javascript 
+# and DHTML and should work on any modern browser. Note that when using
+# HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets
+# (GENERATE_DOCSET) there is already a search function so this one should 
+# typically be disabled. For large projects the javascript based search engine 
+# can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.
+
+SEARCHENGINE           = NO
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a PHP enabled web server instead of at the web client
+# using Javascript. Doxygen will generate the search PHP script and index 
+# file to put on the web server. The advantage of the server
+# based approach is that it scales better to large projects and allows
+# full text search. The disadvances is that it is more difficult to setup 
+# and does not have live searching capabilities.
+
+SERVER_BASED_SEARCH    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
+# generate Latex output.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be 
+# invoked. If left blank `latex' will be used as the default command name. 
+# Note that when enabling USE_PDFLATEX this option is only used for 
+# generating bitmaps for formulas in the HTML output, but not in the 
+# Makefile that is written to the output directory.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to 
+# generate index for LaTeX. If left blank `makeindex' will be used as the 
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact 
+# LaTeX documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used 
+# by the printer. Possible values are: a4, a4wide, letter, legal and 
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = letter
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX 
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for 
+# the generated latex document. The header should contain everything until 
+# the first chapter. If it is left blank doxygen will generate a 
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated 
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will 
+# contain links (just like the HTML output) instead of page references 
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = NO
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of 
+# plain latex in the generated Makefile. Set this option to YES to get a 
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode. 
+# command to the generated LaTeX files. This will instruct LaTeX to keep 
+# running if errors occur, instead of asking the user for help. 
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not 
+# include the index chapters (such as File Index, Compound Index, etc.) 
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+# If LATEX_SOURCE_CODE is set to YES then doxygen will include
+# source code with syntax highlighting in the LaTeX output.
+# Note that which sources are shown also depends on other settings
+# such as SOURCE_BROWSER.
+
+LATEX_SOURCE_CODE      = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output 
+# The RTF output is optimized for Word 97 and may not look very pretty with 
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact 
+# RTF documents. This may be useful for small projects and may help to 
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated 
+# will contain hyperlink fields. The RTF file will 
+# contain links (just like the HTML output) instead of page references. 
+# This makes the output suitable for online browsing using WORD or other 
+# programs which support those fields. 
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's 
+# config file, i.e. a series of assignments. You only have to provide 
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an rtf document. 
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    = 
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to 
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, 
+# then it will generate one additional man file for each entity 
+# documented in the real man page(s). These additional files 
+# only source the real man page, but without them the man command 
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will 
+# generate an XML file that captures the structure of 
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. 
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be 
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_SCHEMA             = 
+
+# The XML_DTD tag can be used to specify an XML DTD, 
+# which can be used by a validating XML parser to check the 
+# syntax of the XML files.
+
+XML_DTD                = 
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will 
+# dump the program listings (including syntax highlighting 
+# and cross-referencing information) to the XML output. Note that 
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will 
+# generate an AutoGen Definitions (see autogen.sf.net) file 
+# that captures the structure of the code including all 
+# documentation. Note that this feature is still experimental 
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will 
+# generate a Perl module file that captures the structure of 
+# the code including all documentation. Note that this 
+# feature is still experimental and incomplete at the 
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate 
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able 
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be 
+# nicely formatted so it can be parsed by a human reader.  This is useful 
+# if you want to understand what is going on.  On the other hand, if this 
+# tag is set to NO the size of the Perl module output will be much smaller 
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file 
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. 
+# This is useful so different doxyrules.make files included by the same 
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will 
+# evaluate all C-preprocessor directives found in the sources and include 
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro 
+# names in the source code. If set to NO (the default) only conditional 
+# compilation will be performed. Macro expansion can be done in a controlled 
+# way by setting EXPAND_ONLY_PREDEF to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES 
+# then the macro expansion is limited to the macros specified with the 
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files 
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that 
+# contain include files that are not input files but should be processed by 
+# the preprocessor.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard 
+# patterns (like *.h and *.hpp) to filter out the header-files in the 
+# directories. If left blank, the patterns specified with FILE_PATTERNS will 
+# be used.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that 
+# are defined before the preprocessor is started (similar to the -D option of 
+# gcc). The argument of the tag is a list of macros of the form: name 
+# or name=definition (no spaces). If the definition and the = are 
+# omitted =1 is assumed. To prevent a macro definition from being 
+# undefined via #undef or recursively expanded use the := operator 
+# instead of the = operator.
+
+PREDEFINED             = __MACOSX_CORE__ \
+                         __WINDOWS_MM__ \
+                         __UNIX_JACK__ \
+                         __LINUX_ALSA__ \
+                         __WINDOWS_KS__
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then 
+# this tag can be used to specify a list of macro names that should be expanded. 
+# The macro definition that is found in the sources will be used. 
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then 
+# doxygen's preprocessor will remove all function-like macros that are alone 
+# on a line, have an all uppercase name, and do not end with a semicolon. Such 
+# function macros are typically used for boiler-plate code, and will confuse 
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles. 
+# Optionally an initial location of the external documentation 
+# can be added for each tagfile. The format of a tag file without 
+# this location is as follows: 
+#   TAGFILES = file1 file2 ... 
+# Adding location for the tag files is done as follows: 
+#   TAGFILES = file1=loc1 "file2 = loc2" ... 
+# where "loc1" and "loc2" can be relative or absolute paths or 
+# URLs. If a location is present for each tag, the installdox tool 
+# does not have to be run to correct the links. 
+# Note that each tag file must have a unique name 
+# (where the name does NOT include the path) 
+# If a tag file is not located in the directory in which doxygen 
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create 
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed 
+# in the class index. If set to NO only the inherited external classes 
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed 
+# in the modules index. If set to NO, only the current project's groups will 
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script 
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will 
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base 
+# or super classes. Setting the tag to NO turns the diagrams off. Note that 
+# this option is superseded by the HAVE_DOT option below. This is only a 
+# fallback. It is recommended to install and use dot, since it yields more 
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc 
+# command. Doxygen will then run the mscgen tool (see 
+# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the 
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where 
+# the mscgen tool resides. If left empty the tool is assumed to be found in the 
+# default search path.
+
+MSCGEN_PATH            = /Applications/Doxygen.app/Contents/Resources/
+
+# If set to YES, the inheritance and collaboration graphs will hide 
+# inheritance and usage relations if the target is undocumented 
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is 
+# available from the path. This tool is part of Graphviz, a graph visualization 
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section 
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = NO
+
+# By default doxygen will write a font called FreeSans.ttf to the output 
+# directory and reference it in all dot files that doxygen generates. This 
+# font does not include all possible unicode characters however, so when you need 
+# these (or just want a differently looking font) you can specify the font name 
+# using DOT_FONTNAME. You need need to make sure dot is able to find the font, 
+# which can be done by putting it in a standard location or by setting the 
+# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory 
+# containing the font.
+
+DOT_FONTNAME           = FreeSans
+
+# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs. 
+# The default size is 10pt.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the output directory to look for the 
+# FreeSans.ttf font (which doxygen will put there itself). If you specify a 
+# different font using DOT_FONTNAME you can set the path where dot 
+# can find it using this tag.
+
+DOT_FONTPATH           = 
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect inheritance relations. Setting this tag to YES will force the 
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for each documented class showing the direct and 
+# indirect implementation dependencies (inheritance, containment, and 
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen 
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and 
+# collaboration diagrams in a style similar to the OMG's Unified Modeling 
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the 
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT 
+# tags are set to YES then doxygen will generate a graph for each documented 
+# file showing the direct and indirect include dependencies of the file with 
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and 
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each 
+# documented header file showing the documented files that directly or 
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT options are set to YES then 
+# doxygen will generate a call dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable call graphs 
+# for selected functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then 
+# doxygen will generate a caller dependency graph for every global function 
+# or class method. Note that enabling this option will significantly increase 
+# the time of a run. So in most cases it will be better to enable caller 
+# graphs for selected functions only using the \callergraph command.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen 
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES 
+# then doxygen will show the dependencies a directory has on other directories 
+# in a graphical way. The dependency relations are determined by the #include 
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images 
+# generated by dot. Possible values are png, jpg, or gif 
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be 
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = /Applications/Doxygen.app/Contents/Resources/
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that 
+# contain dot files that are included in the documentation (see the 
+# \dotfile command).
+
+DOTFILE_DIRS           = 
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of 
+# nodes that will be shown in the graph. If the number of nodes in a graph 
+# becomes larger than this value, doxygen will truncate the graph, which is 
+# visualized by representing a node as a red box. Note that doxygen if the 
+# number of direct children of the root node in a graph is already larger than 
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note 
+# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the 
+# graphs generated by dot. A depth value of 3 means that only nodes reachable 
+# from the root by following a path via at most 3 edges will be shown. Nodes 
+# that lay further from the root node will be omitted. Note that setting this 
+# option to 1 or 2 may greatly reduce the computation time needed for large 
+# code bases. Also note that the size of a graph can be further restricted by 
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent 
+# background. This is disabled by default, because dot on Windows does not 
+# seem to support this out of the box. Warning: Depending on the platform used, 
+# enabling this option may lead to badly anti-aliased labels on the edges of 
+# a graph (i.e. they become hard to read).
+
+DOT_TRANSPARENT        = YES
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output 
+# files in one run (i.e. multiple -o and -T options on the command line). This 
+# makes dot run faster, but since only newer versions of dot (>1.8.10) 
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will 
+# generate a legend page explaining the meaning of the various boxes and 
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will 
+# remove the intermediate dot files that are used to generate 
+# the various graphs.
+
+DOT_CLEANUP            = YES
--- /dev/null
+++ giada-0.7.2/src/rtmidi/include/ksmedia.h
@@ -0,0 +1,4824 @@
+/**
+ * This file has no copyright assigned and is placed in the Public Domain.
+ * This file is part of the w64 mingw-runtime package.
+ */
+#if !defined(_KS_)
+ # warning ks.h must be included before ksmedia.h
+ # include "ks.h"
+#endif
+
+#if __GNUC__ >= 3
+ # pragma GCC system_header
+#endif
+
+#if !defined(_KSMEDIA_)
+ # define _KSMEDIA_
+
+typedef struct
+{
+  KSPROPERTY Property;
+  KSMULTIPLE_ITEM MultipleItem;
+}KSMULTIPLE_DATA_PROP, * PKSMULTIPLE_DATA_PROP;
+
+ # define STATIC_KSMEDIUMSETID_MidiBus                    \
+  0x05908040L, 0x3246, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("05908040-3246-11D0-A5D6-28DB04C10000", KSMEDIUMSETID_MidiBus);
+ # define KSMEDIUMSETID_MidiBus DEFINE_GUIDNAMED(KSMEDIUMSETID_MidiBus)
+
+ # define STATIC_KSMEDIUMSETID_VPBus                  \
+  0xA18C15ECL, 0xCE43, 0x11D0, 0xAB, 0xE7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("A18C15EC-CE43-11D0-ABE7-00A0C9223196", KSMEDIUMSETID_VPBus);
+ # define KSMEDIUMSETID_VPBus DEFINE_GUIDNAMED(KSMEDIUMSETID_VPBus)
+
+ # define STATIC_KSINTERFACESETID_Media                   \
+  0x3A13EB40L, 0x30A7, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("3A13EB40-30A7-11D0-A5D6-28DB04C10000", KSINTERFACESETID_Media);
+ # define KSINTERFACESETID_Media DEFINE_GUIDNAMED(KSINTERFACESETID_Media)
+
+typedef enum
+{
+  KSINTERFACE_MEDIA_MUSIC,
+  KSINTERFACE_MEDIA_WAVE_BUFFERED,
+  KSINTERFACE_MEDIA_WAVE_QUEUED
+}KSINTERFACE_MEDIA;
+
+ # ifndef INIT_USBAUDIO_MID
+  #  define INIT_USBAUDIO_MID(guid, id)                  \
+  {                                   \
+    (guid)->Data1 = 0x4e1cecd2 + (USHORT)(id);          \
+    (guid)->Data2 = 0x1679;                     \
+    (guid)->Data3 = 0x463b;                     \
+    (guid)->Data4[0] = 0xa7;                    \
+    (guid)->Data4[1] = 0x2f;                    \
+    (guid)->Data4[2] = 0xa5;                    \
+    (guid)->Data4[3] = 0xbf;                    \
+    (guid)->Data4[4] = 0x64;                    \
+    (guid)->Data4[5] = 0xc8;                    \
+    (guid)->Data4[6] = 0x6e;                    \
+    (guid)->Data4[7] = 0xba;                    \
+  }
+  #  define EXTRACT_USBAUDIO_MID(guid)                  \
+  (USHORT)((guid)->Data1 - 0x4e1cecd2)
+  #  define DEFINE_USBAUDIO_MID_GUID(id)                    \
+  0x4e1cecd2 + (USHORT)(id), 0x1679, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba
+  #  define IS_COMPATIBLE_USBAUDIO_MID(guid)                \
+  (((guid)->Data1 >= 0x4e1cecd2) &&               \
+   ((guid)->Data1 < 0x4e1cecd2 + 0xffff) &&           \
+   ((guid)->Data2 == 0x1679) &&                   \
+   ((guid)->Data3 == 0x463b) &&                   \
+   ((guid)->Data4[0] == 0xa7) &&                  \
+   ((guid)->Data4[1] == 0x2f) &&                  \
+   ((guid)->Data4[2] == 0xa5) &&                  \
+   ((guid)->Data4[3] == 0xbf) &&                  \
+   ((guid)->Data4[4] == 0x64) &&                  \
+   ((guid)->Data4[5] == 0xc8) &&                  \
+   ((guid)->Data4[6] == 0x6e) &&                  \
+   ((guid)->Data4[7] == 0xba))
+ # endif /* INIT_USBAUDIO_MID */
+
+ # ifndef INIT_USBAUDIO_PID
+  #  define INIT_USBAUDIO_PID(guid, id)                  \
+  {                                   \
+    (guid)->Data1 = 0xabcc5a5e + (USHORT)(id);          \
+    (guid)->Data2 = 0xc263;                     \
+    (guid)->Data3 = 0x463b;                     \
+    (guid)->Data4[0] = 0xa7;                    \
+    (guid)->Data4[1] = 0x2f;                    \
+    (guid)->Data4[2] = 0xa5;                    \
+    (guid)->Data4[3] = 0xbf;                    \
+    (guid)->Data4[4] = 0x64;                    \
+    (guid)->Data4[5] = 0xc8;                    \
+    (guid)->Data4[6] = 0x6e;                    \
+    (guid)->Data4[7] = 0xba;                    \
+  }
+  #  define EXTRACT_USBAUDIO_PID(guid)                  \
+  (USHORT)((guid)->Data1 - 0xabcc5a5e)
+  #  define DEFINE_USBAUDIO_PID_GUID(id)                    \
+  0xabcc5a5e + (USHORT)(id), 0xc263, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba
+  #  define IS_COMPATIBLE_USBAUDIO_PID(guid)                \
+  (((guid)->Data1 >= 0xabcc5a5e) &&               \
+   ((guid)->Data1 < 0xabcc5a5e + 0xffff) &&           \
+   ((guid)->Data2 == 0xc263) &&                   \
+   ((guid)->Data3 == 0x463b) &&                   \
+   ((guid)->Data4[0] == 0xa7) &&                  \
+   ((guid)->Data4[1] == 0x2f) &&                  \
+   ((guid)->Data4[2] == 0xa5) &&                  \
+   ((guid)->Data4[3] == 0xbf) &&                  \
+   ((guid)->Data4[4] == 0x64) &&                  \
+   ((guid)->Data4[5] == 0xc8) &&                  \
+   ((guid)->Data4[6] == 0x6e) &&                  \
+   ((guid)->Data4[7] == 0xba))
+ # endif /* INIT_USBAUDIO_PID */
+
+ # ifndef INIT_USBAUDIO_PRODUCT_NAME
+  #  define INIT_USBAUDIO_PRODUCT_NAME(guid, vid, pid, strIndex)       \
+  {                                   \
+    (guid)->Data1 = 0XFC575048 + (USHORT)(vid);         \
+    (guid)->Data2 = 0x2E08 + (USHORT)(pid);             \
+    (guid)->Data3 = 0x463B + (USHORT)(strIndex);            \
+    (guid)->Data4[0] = 0xA7;                    \
+    (guid)->Data4[1] = 0x2F;                    \
+    (guid)->Data4[2] = 0xA5;                    \
+    (guid)->Data4[3] = 0xBF;                    \
+    (guid)->Data4[4] = 0x64;                    \
+    (guid)->Data4[5] = 0xC8;                    \
+    (guid)->Data4[6] = 0x6E;                    \
+    (guid)->Data4[7] = 0xBA;                    \
+  }
+  #  define DEFINE_USBAUDIO_PRODUCT_NAME(vid, pid, strIndex)          \
+  0xFC575048 + (USHORT)(vid), 0x2E08 + (USHORT)(pid), 0x463B + (USHORT)(strIndex), 0xA7, 0x2F, 0xA5, 0xBF, 0x64, 0xC8, 0x6E, 0xBA
+ # endif /* INIT_USBAUDIO_PRODUCT_NAME */
+
+ # define STATIC_KSCOMPONENTID_USBAUDIO                   \
+  0x8F1275F0, 0x26E9, 0x4264, 0xBA, 0x4D, 0x39, 0xFF, 0xF0, 0x1D, 0x94, 0xAA
+DEFINE_GUIDSTRUCT("8F1275F0-26E9-4264-BA4D-39FFF01D94AA", KSCOMPONENTID_USBAUDIO);
+ # define KSCOMPONENTID_USBAUDIO DEFINE_GUIDNAMED(KSCOMPONENTID_USBAUDIO)
+
+ # define INIT_USB_TERMINAL(guid, id)                  \
+  {                                   \
+    (guid)->Data1 = 0xDFF219E0 + (USHORT)(id);          \
+    (guid)->Data2 = 0xF70F;                     \
+    (guid)->Data3 = 0x11D0;                     \
+    (guid)->Data4[0] = 0xb9;                    \
+    (guid)->Data4[1] = 0x17;                    \
+    (guid)->Data4[2] = 0x00;                    \
+    (guid)->Data4[3] = 0xa0;                    \
+    (guid)->Data4[4] = 0xc9;                    \
+    (guid)->Data4[5] = 0x22;                    \
+    (guid)->Data4[6] = 0x31;                    \
+    (guid)->Data4[7] = 0x96;                    \
+  }
+ # define EXTRACT_USB_TERMINAL(guid)                  \
+  (USHORT)((guid)->Data1 - 0xDFF219E0)
+ # define DEFINE_USB_TERMINAL_GUID(id)                    \
+  0xDFF219E0 + (USHORT)(id), 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+
+ # define STATIC_KSNODETYPE_MICROPHONE                    \
+  DEFINE_USB_TERMINAL_GUID(0x0201)
+DEFINE_GUIDSTRUCT("DFF21BE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MICROPHONE);
+ # define KSNODETYPE_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE)
+
+ # define STATIC_KSNODETYPE_DESKTOP_MICROPHONE                \
+  DEFINE_USB_TERMINAL_GUID(0x0202)
+DEFINE_GUIDSTRUCT("DFF21BE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DESKTOP_MICROPHONE);
+ # define KSNODETYPE_DESKTOP_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_MICROPHONE)
+
+ # define STATIC_KSNODETYPE_PERSONAL_MICROPHONE               \
+  DEFINE_USB_TERMINAL_GUID(0x0203)
+DEFINE_GUIDSTRUCT("DFF21BE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PERSONAL_MICROPHONE);
+ # define KSNODETYPE_PERSONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_PERSONAL_MICROPHONE)
+
+ # define STATIC_KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE           \
+  DEFINE_USB_TERMINAL_GUID(0x0204)
+DEFINE_GUIDSTRUCT("DFF21BE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE);
+ # define KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE)
+
+ # define STATIC_KSNODETYPE_MICROPHONE_ARRAY              \
+  DEFINE_USB_TERMINAL_GUID(0x0205)
+DEFINE_GUIDSTRUCT("DFF21BE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MICROPHONE_ARRAY);
+ # define KSNODETYPE_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE_ARRAY)
+
+ # define STATIC_KSNODETYPE_PROCESSING_MICROPHONE_ARRAY           \
+  DEFINE_USB_TERMINAL_GUID(0x0206)
+DEFINE_GUIDSTRUCT("DFF21BE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PROCESSING_MICROPHONE_ARRAY);
+ # define KSNODETYPE_PROCESSING_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_PROCESSING_MICROPHONE_ARRAY)
+
+ # define STATIC_KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR            \
+  0x830a44f2, 0xa32d, 0x476b, 0xbe, 0x97, 0x42, 0x84, 0x56, 0x73, 0xb3, 0x5a
+DEFINE_GUIDSTRUCT("830a44f2-a32d-476b-be97-42845673b35a", KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR);
+ # define KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR)
+
+ # define STATIC_KSNODETYPE_SPEAKER                   \
+  DEFINE_USB_TERMINAL_GUID(0x0301)
+DEFINE_GUIDSTRUCT("DFF21CE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPEAKER);
+ # define KSNODETYPE_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_SPEAKER)
+
+ # define STATIC_KSNODETYPE_HEADPHONES                    \
+  DEFINE_USB_TERMINAL_GUID(0x0302)
+DEFINE_GUIDSTRUCT("DFF21CE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEADPHONES);
+ # define KSNODETYPE_HEADPHONES DEFINE_GUIDNAMED(KSNODETYPE_HEADPHONES)
+
+ # define STATIC_KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO            \
+  DEFINE_USB_TERMINAL_GUID(0x0303)
+DEFINE_GUIDSTRUCT("DFF21CE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO);
+ # define KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO)
+
+ # define STATIC_KSNODETYPE_DESKTOP_SPEAKER               \
+  DEFINE_USB_TERMINAL_GUID(0x0304)
+DEFINE_GUIDSTRUCT("DFF21CE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DESKTOP_SPEAKER);
+ # define KSNODETYPE_DESKTOP_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_SPEAKER)
+
+ # define STATIC_KSNODETYPE_ROOM_SPEAKER                  \
+  DEFINE_USB_TERMINAL_GUID(0x0305)
+DEFINE_GUIDSTRUCT("DFF21CE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ROOM_SPEAKER);
+ # define KSNODETYPE_ROOM_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_ROOM_SPEAKER)
+
+ # define STATIC_KSNODETYPE_COMMUNICATION_SPEAKER             \
+  DEFINE_USB_TERMINAL_GUID(0x0306)
+DEFINE_GUIDSTRUCT("DFF21CE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_COMMUNICATION_SPEAKER);
+ # define KSNODETYPE_COMMUNICATION_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_COMMUNICATION_SPEAKER)
+
+ # define STATIC_KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER         \
+  DEFINE_USB_TERMINAL_GUID(0x0307)
+DEFINE_GUIDSTRUCT("DFF21CE7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER);
+ # define KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER)
+
+ # define STATIC_KSNODETYPE_HANDSET                   \
+  DEFINE_USB_TERMINAL_GUID(0x0401)
+DEFINE_GUIDSTRUCT("DFF21DE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HANDSET);
+ # define KSNODETYPE_HANDSET DEFINE_GUIDNAMED(KSNODETYPE_HANDSET)
+
+ # define STATIC_KSNODETYPE_HEADSET                   \
+  DEFINE_USB_TERMINAL_GUID(0x0402)
+DEFINE_GUIDSTRUCT("DFF21DE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEADSET);
+ # define KSNODETYPE_HEADSET DEFINE_GUIDNAMED(KSNODETYPE_HEADSET)
+
+ # define STATIC_KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION        \
+  DEFINE_USB_TERMINAL_GUID(0x0403)
+DEFINE_GUIDSTRUCT("DFF21DE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION);
+ # define KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION DEFINE_GUIDNAMED(KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION)
+
+ # define STATIC_KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE         \
+  DEFINE_USB_TERMINAL_GUID(0x0404)
+DEFINE_GUIDSTRUCT("DFF21DE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE);
+ # define KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE)
+
+ # define STATIC_KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE           \
+  DEFINE_USB_TERMINAL_GUID(0x0405)
+DEFINE_GUIDSTRUCT("DFF21DE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE);
+ # define KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE)
+
+ # define STATIC_KSNODETYPE_PHONE_LINE                    \
+  DEFINE_USB_TERMINAL_GUID(0x0501)
+DEFINE_GUIDSTRUCT("DFF21EE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PHONE_LINE);
+ # define KSNODETYPE_PHONE_LINE DEFINE_GUIDNAMED(KSNODETYPE_PHONE_LINE)
+
+ # define STATIC_KSNODETYPE_TELEPHONE                 \
+  DEFINE_USB_TERMINAL_GUID(0x0502)
+DEFINE_GUIDSTRUCT("DFF21EE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TELEPHONE);
+ # define KSNODETYPE_TELEPHONE DEFINE_GUIDNAMED(KSNODETYPE_TELEPHONE)
+
+ # define STATIC_KSNODETYPE_DOWN_LINE_PHONE               \
+  DEFINE_USB_TERMINAL_GUID(0x0503)
+DEFINE_GUIDSTRUCT("DFF21EE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DOWN_LINE_PHONE);
+ # define KSNODETYPE_DOWN_LINE_PHONE DEFINE_GUIDNAMED(KSNODETYPE_DOWN_LINE_PHONE)
+
+ # define STATIC_KSNODETYPE_ANALOG_CONNECTOR              \
+  DEFINE_USB_TERMINAL_GUID(0x601)
+DEFINE_GUIDSTRUCT("DFF21FE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ANALOG_CONNECTOR);
+ # define KSNODETYPE_ANALOG_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_CONNECTOR)
+
+ # define STATIC_KSNODETYPE_DIGITAL_AUDIO_INTERFACE           \
+  DEFINE_USB_TERMINAL_GUID(0x0602)
+DEFINE_GUIDSTRUCT("DFF21FE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DIGITAL_AUDIO_INTERFACE);
+ # define KSNODETYPE_DIGITAL_AUDIO_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_DIGITAL_AUDIO_INTERFACE)
+
+ # define STATIC_KSNODETYPE_LINE_CONNECTOR                \
+  DEFINE_USB_TERMINAL_GUID(0x0603)
+DEFINE_GUIDSTRUCT("DFF21FE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LINE_CONNECTOR);
+ # define KSNODETYPE_LINE_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LINE_CONNECTOR)
+
+ # define STATIC_KSNODETYPE_LEGACY_AUDIO_CONNECTOR            \
+  DEFINE_USB_TERMINAL_GUID(0x0604)
+DEFINE_GUIDSTRUCT("DFF21FE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LEGACY_AUDIO_CONNECTOR);
+ # define KSNODETYPE_LEGACY_AUDIO_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LEGACY_AUDIO_CONNECTOR)
+
+ # define STATIC_KSNODETYPE_SPDIF_INTERFACE               \
+  DEFINE_USB_TERMINAL_GUID(0x0605)
+DEFINE_GUIDSTRUCT("DFF21FE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPDIF_INTERFACE);
+ # define KSNODETYPE_SPDIF_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_SPDIF_INTERFACE)
+
+ # define STATIC_KSNODETYPE_1394_DA_STREAM                \
+  DEFINE_USB_TERMINAL_GUID(0x0606)
+DEFINE_GUIDSTRUCT("DFF21FE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_1394_DA_STREAM);
+ # define KSNODETYPE_1394_DA_STREAM DEFINE_GUIDNAMED(KSNODETYPE_1394_DA_STREAM)
+
+ # define STATIC_KSNODETYPE_1394_DV_STREAM_SOUNDTRACK         \
+  DEFINE_USB_TERMINAL_GUID(0x0607)
+DEFINE_GUIDSTRUCT("DFF21FE7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_1394_DV_STREAM_SOUNDTRACK);
+ # define KSNODETYPE_1394_DV_STREAM_SOUNDTRACK DEFINE_GUIDNAMED(KSNODETYPE_1394_DV_STREAM_SOUNDTRACK)
+
+ # define STATIC_KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE        \
+  DEFINE_USB_TERMINAL_GUID(0x0701)
+DEFINE_GUIDSTRUCT("DFF220E1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE);
+ # define KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE DEFINE_GUIDNAMED(KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE)
+
+ # define STATIC_KSNODETYPE_EQUALIZATION_NOISE                \
+  DEFINE_USB_TERMINAL_GUID(0x0702)
+DEFINE_GUIDSTRUCT("DFF220E2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_EQUALIZATION_NOISE);
+ # define KSNODETYPE_EQUALIZATION_NOISE DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZATION_NOISE)
+
+ # define STATIC_KSNODETYPE_CD_PLAYER                 \
+  DEFINE_USB_TERMINAL_GUID(0x0703)
+DEFINE_GUIDSTRUCT("DFF220E3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_CD_PLAYER);
+ # define KSNODETYPE_CD_PLAYER DEFINE_GUIDNAMED(KSNODETYPE_CD_PLAYER)
+
+ # define STATIC_KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE         \
+  DEFINE_USB_TERMINAL_GUID(0x0704)
+DEFINE_GUIDSTRUCT("DFF220E4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE);
+ # define KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE DEFINE_GUIDNAMED(KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE)
+
+ # define STATIC_KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE       \
+  DEFINE_USB_TERMINAL_GUID(0x0705)
+DEFINE_GUIDSTRUCT("DFF220E5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE);
+ # define KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE DEFINE_GUIDNAMED(KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE)
+
+ # define STATIC_KSNODETYPE_MINIDISK                  \
+  DEFINE_USB_TERMINAL_GUID(0x0706)
+DEFINE_GUIDSTRUCT("DFF220E6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MINIDISK);
+ # define KSNODETYPE_MINIDISK DEFINE_GUIDNAMED(KSNODETYPE_MINIDISK)
+
+ # define STATIC_KSNODETYPE_ANALOG_TAPE                   \
+  DEFINE_USB_TERMINAL_GUID(0x0707)
+DEFINE_GUIDSTRUCT("DFF220E7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ANALOG_TAPE);
+ # define KSNODETYPE_ANALOG_TAPE DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_TAPE)
+
+ # define STATIC_KSNODETYPE_PHONOGRAPH                    \
+  DEFINE_USB_TERMINAL_GUID(0x0708)
+DEFINE_GUIDSTRUCT("DFF220E8-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PHONOGRAPH);
+ # define KSNODETYPE_PHONOGRAPH DEFINE_GUIDNAMED(KSNODETYPE_PHONOGRAPH)
+
+ # define STATIC_KSNODETYPE_VCR_AUDIO                 \
+  DEFINE_USB_TERMINAL_GUID(0x0708)
+DEFINE_GUIDSTRUCT("DFF220E9-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VCR_AUDIO);
+ # define KSNODETYPE_VCR_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VCR_AUDIO)
+
+ # define STATIC_KSNODETYPE_VIDEO_DISC_AUDIO              \
+  DEFINE_USB_TERMINAL_GUID(0x070A)
+DEFINE_GUIDSTRUCT("DFF220EA-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_DISC_AUDIO);
+ # define KSNODETYPE_VIDEO_DISC_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_DISC_AUDIO)
+
+ # define STATIC_KSNODETYPE_DVD_AUDIO                 \
+  DEFINE_USB_TERMINAL_GUID(0x070B)
+DEFINE_GUIDSTRUCT("DFF220EB-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DVD_AUDIO);
+ # define KSNODETYPE_DVD_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DVD_AUDIO)
+
+ # define STATIC_KSNODETYPE_TV_TUNER_AUDIO                \
+  DEFINE_USB_TERMINAL_GUID(0x070C)
+DEFINE_GUIDSTRUCT("DFF220EC-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TV_TUNER_AUDIO);
+ # define KSNODETYPE_TV_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_TV_TUNER_AUDIO)
+
+ # define STATIC_KSNODETYPE_SATELLITE_RECEIVER_AUDIO          \
+  DEFINE_USB_TERMINAL_GUID(0x070D)
+DEFINE_GUIDSTRUCT("DFF220ED-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SATELLITE_RECEIVER_AUDIO);
+ # define KSNODETYPE_SATELLITE_RECEIVER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_SATELLITE_RECEIVER_AUDIO)
+
+ # define STATIC_KSNODETYPE_CABLE_TUNER_AUDIO             \
+  DEFINE_USB_TERMINAL_GUID(0x070E)
+DEFINE_GUIDSTRUCT("DFF220EE-F70F-11D0-B917-00A0C9223196", KSNODETYPE_CABLE_TUNER_AUDIO);
+ # define KSNODETYPE_CABLE_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_CABLE_TUNER_AUDIO)
+
+ # define STATIC_KSNODETYPE_DSS_AUDIO                 \
+  DEFINE_USB_TERMINAL_GUID(0x070F)
+DEFINE_GUIDSTRUCT("DFF220EF-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DSS_AUDIO);
+ # define KSNODETYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DSS_AUDIO)
+
+ # define STATIC_KSNODETYPE_RADIO_RECEIVER                \
+  DEFINE_USB_TERMINAL_GUID(0x0710)
+DEFINE_GUIDSTRUCT("DFF220F0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_RADIO_RECEIVER);
+ # define KSNODETYPE_RADIO_RECEIVER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_RECEIVER)
+
+ # define STATIC_KSNODETYPE_RADIO_TRANSMITTER             \
+  DEFINE_USB_TERMINAL_GUID(0x0711)
+DEFINE_GUIDSTRUCT("DFF220F1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_RADIO_TRANSMITTER);
+ # define KSNODETYPE_RADIO_TRANSMITTER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_TRANSMITTER)
+
+ # define STATIC_KSNODETYPE_MULTITRACK_RECORDER               \
+  DEFINE_USB_TERMINAL_GUID(0x0712)
+DEFINE_GUIDSTRUCT("DFF220F2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MULTITRACK_RECORDER);
+ # define KSNODETYPE_MULTITRACK_RECORDER DEFINE_GUIDNAMED(KSNODETYPE_MULTITRACK_RECORDER)
+
+ # define STATIC_KSNODETYPE_SYNTHESIZER                   \
+  DEFINE_USB_TERMINAL_GUID(0x0713)
+DEFINE_GUIDSTRUCT("DFF220F3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SYNTHESIZER);
+ # define KSNODETYPE_SYNTHESIZER DEFINE_GUIDNAMED(KSNODETYPE_SYNTHESIZER)
+
+ # define STATIC_KSNODETYPE_SWSYNTH                   \
+  0x423274A0L, 0x8B81, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
+DEFINE_GUIDSTRUCT("423274A0-8B81-11D1-A050-0000F8004788", KSNODETYPE_SWSYNTH);
+ # define KSNODETYPE_SWSYNTH DEFINE_GUIDNAMED(KSNODETYPE_SWSYNTH)
+
+ # define STATIC_KSNODETYPE_SWMIDI                    \
+  0xCB9BEFA0L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
+DEFINE_GUIDSTRUCT("CB9BEFA0-A251-11D1-A050-0000F8004788", KSNODETYPE_SWMIDI);
+ # define KSNODETYPE_SWMIDI DEFINE_GUIDNAMED(KSNODETYPE_SWMIDI)
+
+ # define STATIC_KSNODETYPE_DRM_DESCRAMBLE                \
+  0xFFBB6E3FL, 0xCCFE, 0x4D84, 0x90, 0xD9, 0x42, 0x14, 0x18, 0xB0, 0x3A, 0x8E
+DEFINE_GUIDSTRUCT("FFBB6E3F-CCFE-4D84-90D9-421418B03A8E", KSNODETYPE_DRM_DESCRAMBLE);
+ # define KSNODETYPE_DRM_DESCRAMBLE DEFINE_GUIDNAMED(KSNODETYPE_DRM_DESCRAMBLE)
+
+ # define STATIC_KSCATEGORY_AUDIO                     \
+  0x6994AD04L, 0x93EF, 0x11D0, { 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96 }
+DEFINE_GUIDSTRUCT("6994AD04-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_AUDIO);
+ # define KSCATEGORY_AUDIO DEFINE_GUIDNAMED(KSCATEGORY_AUDIO)
+
+ # define STATIC_KSCATEGORY_VIDEO                     \
+  0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("6994AD05-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_VIDEO);
+ # define KSCATEGORY_VIDEO DEFINE_GUIDNAMED(KSCATEGORY_VIDEO)
+
+ # define STATIC_KSCATEGORY_TEXT                      \
+  0x6994AD06L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("6994AD06-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_TEXT);
+ # define KSCATEGORY_TEXT DEFINE_GUIDNAMED(KSCATEGORY_TEXT)
+
+ # define STATIC_KSCATEGORY_NETWORK                   \
+  0x67C9CC3CL, 0x69C4, 0x11D2, 0x87, 0x59, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("67C9CC3C-69C4-11D2-8759-00A0C9223196", KSCATEGORY_NETWORK);
+ # define KSCATEGORY_NETWORK DEFINE_GUIDNAMED(KSCATEGORY_NETWORK)
+
+ # define STATIC_KSCATEGORY_TOPOLOGY                  \
+  0xDDA54A40L, 0x1E4C, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("DDA54A40-1E4C-11D1-A050-405705C10000", KSCATEGORY_TOPOLOGY);
+ # define KSCATEGORY_TOPOLOGY DEFINE_GUIDNAMED(KSCATEGORY_TOPOLOGY)
+
+ # define STATIC_KSCATEGORY_VIRTUAL                   \
+  0x3503EAC4L, 0x1F26, 0x11D1, 0x8A, 0xB0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("3503EAC4-1F26-11D1-8AB0-00A0C9223196", KSCATEGORY_VIRTUAL);
+ # define KSCATEGORY_VIRTUAL DEFINE_GUIDNAMED(KSCATEGORY_VIRTUAL)
+
+ # define STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL              \
+  0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("BF963D80-C559-11D0-8A2B-00A0C9255AC1", KSCATEGORY_ACOUSTIC_ECHO_CANCEL);
+ # define KSCATEGORY_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSCATEGORY_ACOUSTIC_ECHO_CANCEL)
+
+ # define STATIC_KSCATEGORY_SYSAUDIO                  \
+  0xA7C7A5B1L, 0x5AF3, 0x11D1, 0x9C, 0xED, 0x00, 0xA0, 0x24, 0xBF, 0x04, 0x07
+DEFINE_GUIDSTRUCT("A7C7A5B1-5AF3-11D1-9CED-00A024BF0407", KSCATEGORY_SYSAUDIO);
+ # define KSCATEGORY_SYSAUDIO DEFINE_GUIDNAMED(KSCATEGORY_SYSAUDIO)
+
+ # define STATIC_KSCATEGORY_WDMAUD                    \
+  0x3E227E76L, 0x690D, 0x11D2, 0x81, 0x61, 0x00, 0x00, 0xF8, 0x77, 0x5B, 0xF1
+DEFINE_GUIDSTRUCT("3E227E76-690D-11D2-8161-0000F8775BF1", KSCATEGORY_WDMAUD);
+ # define KSCATEGORY_WDMAUD DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD)
+
+ # define STATIC_KSCATEGORY_AUDIO_GFX                 \
+  0x9BAF9572L, 0x340C, 0x11D3, 0xAB, 0xDC, 0x00, 0xA0, 0xC9, 0x0A, 0xB1, 0x6F
+DEFINE_GUIDSTRUCT("9BAF9572-340C-11D3-ABDC-00A0C90AB16F", KSCATEGORY_AUDIO_GFX);
+ # define KSCATEGORY_AUDIO_GFX DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_GFX)
+
+ # define STATIC_KSCATEGORY_AUDIO_SPLITTER                \
+  0x9EA331FAL, 0xB91B, 0x45F8, 0x92, 0x85, 0xBD, 0x2B, 0xC7, 0x7A, 0xFC, 0xDE
+DEFINE_GUIDSTRUCT("9EA331FA-B91B-45F8-9285-BD2BC77AFCDE", KSCATEGORY_AUDIO_SPLITTER);
+ # define KSCATEGORY_AUDIO_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_SPLITTER)
+
+ # define STATIC_KSCATEGORY_SYNTHESIZER STATIC_KSNODETYPE_SYNTHESIZER
+ # define KSCATEGORY_SYNTHESIZER KSNODETYPE_SYNTHESIZER
+
+ # define STATIC_KSCATEGORY_DRM_DESCRAMBLE STATIC_KSNODETYPE_DRM_DESCRAMBLE
+ # define KSCATEGORY_DRM_DESCRAMBLE KSNODETYPE_DRM_DESCRAMBLE
+
+ # define STATIC_KSCATEGORY_AUDIO_DEVICE                  \
+  0xFBF6F530L, 0x07B9, 0x11D2, 0xA7, 0x1E, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
+DEFINE_GUIDSTRUCT("FBF6F530-07B9-11D2-A71E-0000F8004788", KSCATEGORY_AUDIO_DEVICE);
+ # define KSCATEGORY_AUDIO_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_DEVICE)
+
+ # define STATIC_KSCATEGORY_PREFERRED_WAVEOUT_DEVICE          \
+  0xD6C5066EL, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
+DEFINE_GUIDSTRUCT("D6C5066E-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_WAVEOUT_DEVICE);
+ # define KSCATEGORY_PREFERRED_WAVEOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEOUT_DEVICE)
+
+ # define STATIC_KSCATEGORY_PREFERRED_WAVEIN_DEVICE           \
+  0xD6C50671L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
+DEFINE_GUIDSTRUCT("D6C50671-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_WAVEIN_DEVICE);
+ # define KSCATEGORY_PREFERRED_WAVEIN_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEIN_DEVICE)
+
+ # define STATIC_KSCATEGORY_PREFERRED_MIDIOUT_DEVICE          \
+  0xD6C50674L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
+DEFINE_GUIDSTRUCT("D6C50674-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_MIDIOUT_DEVICE);
+ # define KSCATEGORY_PREFERRED_MIDIOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_MIDIOUT_DEVICE)
+
+ # define STATIC_KSCATEGORY_WDMAUD_USE_PIN_NAME               \
+  0x47A4FA20L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
+DEFINE_GUIDSTRUCT("47A4FA20-A251-11D1-A050-0000F8004788", KSCATEGORY_WDMAUD_USE_PIN_NAME);
+ # define KSCATEGORY_WDMAUD_USE_PIN_NAME DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD_USE_PIN_NAME)
+
+ # define STATIC_KSCATEGORY_ESCALANTE_PLATFORM_DRIVER         \
+  0x74f3aea8L, 0x9768, 0x11d1, 0x8e, 0x07, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e
+DEFINE_GUIDSTRUCT("74f3aea8-9768-11d1-8e07-00a0c95ec22e", KSCATEGORY_ESCALANTE_PLATFORM_DRIVER);
+ # define KSCATEGORY_ESCALANTE_PLATFORM_DRIVER DEFINE_GUIDNAMED(KSCATEGORY_ESCALANTE_PLATFORM_DRIVER)
+
+ # define STATIC_KSDATAFORMAT_TYPE_VIDEO                  \
+  0x73646976L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
+DEFINE_GUIDSTRUCT("73646976-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_VIDEO);
+ # define KSDATAFORMAT_TYPE_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VIDEO)
+
+ # define STATIC_KSDATAFORMAT_TYPE_AUDIO                  \
+  0x73647561L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
+DEFINE_GUIDSTRUCT("73647561-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_AUDIO);
+ # define KSDATAFORMAT_TYPE_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_TYPE_TEXT                   \
+  0x73747874L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
+DEFINE_GUIDSTRUCT("73747874-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_TEXT);
+ # define KSDATAFORMAT_TYPE_TEXT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_TEXT)
+
+ # if !defined(DEFINE_WAVEFORMATEX_GUID)
+  #  define DEFINE_WAVEFORMATEX_GUID(x)                 \
+  (USHORT)(x), 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 }
+ # endif
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX            \
+  0x00000000L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
+DEFINE_GUIDSTRUCT("00000000-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_WAVEFORMATEX);
+ # define KSDATAFORMAT_SUBTYPE_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_WAVEFORMATEX)
+
+ # define INIT_WAVEFORMATEX_GUID(Guid, x)                  \
+  {                                   \
+    *(Guid) = KSDATAFORMAT_SUBTYPE_WAVEFORMATEX;            \
+    (Guid)->Data1 = (USHORT)(x);                    \
+  }
+
+ # define EXTRACT_WAVEFORMATEX_ID(Guid)                   \
+  (USHORT)((Guid)->Data1)
+
+ # define IS_VALID_WAVEFORMATEX_GUID(Guid)                \
+  (!memcmp(((PUSHORT)&KSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1, sizeof(GUID) - sizeof(USHORT)))
+
+ # ifndef INIT_MMREG_MID
+  #  define INIT_MMREG_MID(guid, id)                     \
+  {                                   \
+    (guid)->Data1 = 0xd5a47fa7 + (USHORT)(id);          \
+    (guid)->Data2 = 0x6d98;                     \
+    (guid)->Data3 = 0x11d1;                     \
+    (guid)->Data4[0] = 0xa2;                    \
+    (guid)->Data4[1] = 0x1a;                    \
+    (guid)->Data4[2] = 0x00;                    \
+    (guid)->Data4[3] = 0xa0;                    \
+    (guid)->Data4[4] = 0xc9;                    \
+    (guid)->Data4[5] = 0x22;                    \
+    (guid)->Data4[6] = 0x31;                    \
+    (guid)->Data4[7] = 0x96;                    \
+  }
+  #  define EXTRACT_MMREG_MID(guid)                     \
+  (USHORT)((guid)->Data1 - 0xd5a47fa7)
+  #  define DEFINE_MMREG_MID_GUID(id)                   \
+  0xd5a47fa7 + (USHORT)(id), 0x6d98, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96
+
+  #  define IS_COMPATIBLE_MMREG_MID(guid)                   \
+  (((guid)->Data1 >= 0xd5a47fa7) &&               \
+   ((guid)->Data1 < 0xd5a47fa7 + 0xffff) &&           \
+   ((guid)->Data2 == 0x6d98) &&                   \
+   ((guid)->Data3 == 0x11d1) &&                   \
+   ((guid)->Data4[0] == 0xa2) &&                  \
+   ((guid)->Data4[1] == 0x1a) &&                  \
+   ((guid)->Data4[2] == 0x00) &&                  \
+   ((guid)->Data4[3] == 0xa0) &&                  \
+   ((guid)->Data4[4] == 0xc9) &&                  \
+   ((guid)->Data4[5] == 0x22) &&                  \
+   ((guid)->Data4[6] == 0x31) &&                  \
+   ((guid)->Data4[7] == 0x96))
+ # endif /* INIT_MMREG_MID */
+
+ # ifndef INIT_MMREG_PID
+  #  define INIT_MMREG_PID(guid, id)                     \
+  {                                   \
+    (guid)->Data1 = 0xe36dc2ac + (USHORT)(id);          \
+    (guid)->Data2 = 0x6d9a;                     \
+    (guid)->Data3 = 0x11d1;                     \
+    (guid)->Data4[0] = 0xa2;                    \
+    (guid)->Data4[1] = 0x1a;                    \
+    (guid)->Data4[2] = 0x00;                    \
+    (guid)->Data4[3] = 0xa0;                    \
+    (guid)->Data4[4] = 0xc9;                    \
+    (guid)->Data4[5] = 0x22;                    \
+    (guid)->Data4[6] = 0x31;                    \
+    (guid)->Data4[7] = 0x96;                    \
+  }
+  #  define EXTRACT_MMREG_PID(guid)                     \
+  (USHORT)((guid)->Data1 - 0xe36dc2ac)
+  #  define DEFINE_MMREG_PID_GUID(id)                   \
+  0xe36dc2ac + (USHORT)(id), 0x6d9a, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96
+
+  #  define IS_COMPATIBLE_MMREG_PID(guid)                   \
+  (((guid)->Data1 >= 0xe36dc2ac) &&               \
+   ((guid)->Data1 < 0xe36dc2ac + 0xffff) &&           \
+   ((guid)->Data2 == 0x6d9a) &&                   \
+   ((guid)->Data3 == 0x11d1) &&                   \
+   ((guid)->Data4[0] == 0xa2) &&                  \
+   ((guid)->Data4[1] == 0x1a) &&                  \
+   ((guid)->Data4[2] == 0x00) &&                  \
+   ((guid)->Data4[3] == 0xa0) &&                  \
+   ((guid)->Data4[4] == 0xc9) &&                  \
+   ((guid)->Data4[5] == 0x22) &&                  \
+   ((guid)->Data4[6] == 0x31) &&                  \
+   ((guid)->Data4[7] == 0x96))
+ # endif /* INIT_MMREG_PID */
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_ANALOG              \
+  0x6dba3190L, 0x67bd, 0x11cf, 0xa0, 0xf7, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
+DEFINE_GUIDSTRUCT("6dba3190-67bd-11cf-a0f7-0020afd156e4", KSDATAFORMAT_SUBTYPE_ANALOG);
+ # define KSDATAFORMAT_SUBTYPE_ANALOG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ANALOG)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_PCM                 \
+  DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_PCM)
+DEFINE_GUIDSTRUCT("00000001-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_PCM);
+ # define KSDATAFORMAT_SUBTYPE_PCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_PCM)
+
+ # ifdef _INC_MMREG
+  #  define STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT              \
+  DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT)
+DEFINE_GUIDSTRUCT("00000003-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEEE_FLOAT);
+  #  define KSDATAFORMAT_SUBTYPE_IEEE_FLOAT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
+
+  #  define STATIC_KSDATAFORMAT_SUBTYPE_DRM                 \
+  DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DRM)
+DEFINE_GUIDSTRUCT("00000009-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_DRM);
+  #  define KSDATAFORMAT_SUBTYPE_DRM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DRM)
+
+  #  define STATIC_KSDATAFORMAT_SUBTYPE_ALAW                \
+  DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ALAW)
+DEFINE_GUIDSTRUCT("00000006-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_ALAW);
+  #  define KSDATAFORMAT_SUBTYPE_ALAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ALAW)
+
+  #  define STATIC_KSDATAFORMAT_SUBTYPE_MULAW               \
+  DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MULAW)
+DEFINE_GUIDSTRUCT("00000007-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_MULAW);
+  #  define KSDATAFORMAT_SUBTYPE_MULAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MULAW)
+
+  #  define STATIC_KSDATAFORMAT_SUBTYPE_ADPCM               \
+  DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ADPCM)
+DEFINE_GUIDSTRUCT("00000002-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_ADPCM);
+  #  define KSDATAFORMAT_SUBTYPE_ADPCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ADPCM)
+
+  #  define STATIC_KSDATAFORMAT_SUBTYPE_MPEG                \
+  DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MPEG)
+DEFINE_GUIDSTRUCT("00000050-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_MPEG);
+  #  define KSDATAFORMAT_SUBTYPE_MPEG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG)
+ # endif /* _INC_MMREG */
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_VC_ID             \
+  0xAD98D184L, 0xAAC3, 0x11D0, 0xA4, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("AD98D184-AAC3-11D0-A41C-00A0C9223196", KSDATAFORMAT_SPECIFIER_VC_ID);
+ # define KSDATAFORMAT_SPECIFIER_VC_ID DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VC_ID)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX          \
+  0x05589f81L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
+DEFINE_GUIDSTRUCT("05589f81-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_WAVEFORMATEX);
+ # define KSDATAFORMAT_SPECIFIER_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_DSOUND                \
+  0x518590a2L, 0xa184, 0x11d0, 0x85, 0x22, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
+DEFINE_GUIDSTRUCT("518590a2-a184-11d0-8522-00c04fd9baf3", KSDATAFORMAT_SPECIFIER_DSOUND);
+ # define KSDATAFORMAT_SPECIFIER_DSOUND DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DSOUND)
+
+ # if defined(_INC_MMSYSTEM) || defined(_INC_MMREG) || 1
+  #  if !defined(PACK_PRAGMAS_NOT_SUPPORTED)
+   #   include <pshpack1.h>
+  #  endif
+typedef struct
+{
+  KSDATAFORMAT DataFormat;
+  WAVEFORMATEX WaveFormatEx;
+}KSDATAFORMAT_WAVEFORMATEX, * PKSDATAFORMAT_WAVEFORMATEX;
+
+  #  ifndef _WAVEFORMATEXTENSIBLE_
+   #   define _WAVEFORMATEXTENSIBLE_
+typedef struct
+{
+  WAVEFORMATEX Format;
+  union
+  {
+    WORD wValidBitsPerSample;
+    WORD wSamplesPerBlock;
+    WORD wReserved;
+  }Samples;
+  DWORD dwChannelMask;
+
+  GUID SubFormat;
+}WAVEFORMATEXTENSIBLE, * PWAVEFORMATEXTENSIBLE;
+  #  endif /* _WAVEFORMATEXTENSIBLE_ */
+
+  #  if !defined(WAVE_FORMAT_EXTENSIBLE)
+   #   define WAVE_FORMAT_EXTENSIBLE 0xFFFE
+  #  endif
+
+typedef struct
+{
+  ULONG Flags;
+  ULONG Control;
+  WAVEFORMATEX WaveFormatEx;
+}KSDSOUND_BUFFERDESC, * PKSDSOUND_BUFFERDESC;
+
+typedef struct
+{
+  KSDATAFORMAT DataFormat;
+  KSDSOUND_BUFFERDESC BufferDesc;
+}KSDATAFORMAT_DSOUND, * PKSDATAFORMAT_DSOUND;
+
+  #  if !defined(PACK_PRAGMAS_NOT_SUPPORTED)
+   #   include <poppack.h>
+  #  endif
+ # endif /* defined(_INC_MMSYSTEM) || defined(_INC_MMREG) */
+
+ # define KSDSOUND_BUFFER_PRIMARY 0x00000001
+ # define KSDSOUND_BUFFER_STATIC 0x00000002
+ # define KSDSOUND_BUFFER_LOCHARDWARE 0x00000004
+ # define KSDSOUND_BUFFER_LOCSOFTWARE 0x00000008
+
+ # define KSDSOUND_BUFFER_CTRL_3D 0x00000001
+ # define KSDSOUND_BUFFER_CTRL_FREQUENCY 0x00000002
+ # define KSDSOUND_BUFFER_CTRL_PAN 0x00000004
+ # define KSDSOUND_BUFFER_CTRL_VOLUME 0x00000008
+ # define KSDSOUND_BUFFER_CTRL_POSITIONNOTIFY 0x00000010
+
+typedef struct
+{
+  DWORDLONG PlayOffset;
+  DWORDLONG WriteOffset;
+}KSAUDIO_POSITION, * PKSAUDIO_POSITION;
+
+typedef struct _DS3DVECTOR
+{
+  __MINGW_EXTENSION union
+  {
+    FLOAT x;
+    FLOAT dvX;
+  };
+  __MINGW_EXTENSION union
+  {
+    FLOAT y;
+    FLOAT dvY;
+  };
+  __MINGW_EXTENSION union
+  {
+    FLOAT z;
+    FLOAT dvZ;
+  };
+}DS3DVECTOR, * PDS3DVECTOR;
+
+ # define STATIC_KSPROPSETID_DirectSound3DListener            \
+  0x437b3414L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
+DEFINE_GUIDSTRUCT("437b3414-d060-11d0-8583-00c04fd9baf3", KSPROPSETID_DirectSound3DListener);
+ # define KSPROPSETID_DirectSound3DListener DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DListener)
+
+typedef enum
+{
+  KSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
+  KSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
+  KSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
+  KSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
+  KSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
+  KSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
+  KSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
+  KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
+  KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION
+}KSPROPERTY_DIRECTSOUND3DLISTENER;
+
+typedef struct
+{
+  DS3DVECTOR Position;
+  DS3DVECTOR Velocity;
+  DS3DVECTOR OrientFront;
+  DS3DVECTOR OrientTop;
+  FLOAT DistanceFactor;
+  FLOAT RolloffFactor;
+  FLOAT DopplerFactor;
+}KSDS3D_LISTENER_ALL, * PKSDS3D_LISTENER_ALL;
+
+typedef struct
+{
+  DS3DVECTOR Front;
+  DS3DVECTOR Top;
+}KSDS3D_LISTENER_ORIENTATION, * PKSDS3D_LISTENER_ORIENTATION;
+
+ # define STATIC_KSPROPSETID_DirectSound3DBuffer              \
+  0x437b3411L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
+DEFINE_GUIDSTRUCT("437b3411-d060-11d0-8583-00c04fd9baf3", KSPROPSETID_DirectSound3DBuffer);
+ # define KSPROPSETID_DirectSound3DBuffer DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DBuffer)
+
+typedef enum
+{
+  KSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
+  KSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
+  KSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
+  KSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
+  KSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
+  KSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
+  KSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
+  KSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
+  KSPROPERTY_DIRECTSOUND3DBUFFER_MODE
+}KSPROPERTY_DIRECTSOUND3DBUFFER;
+
+typedef struct
+{
+  DS3DVECTOR Position;
+  DS3DVECTOR Velocity;
+  ULONG InsideConeAngle;
+  ULONG OutsideConeAngle;
+  DS3DVECTOR ConeOrientation;
+  LONG ConeOutsideVolume;
+  FLOAT MinDistance;
+  FLOAT MaxDistance;
+  ULONG Mode;
+}KSDS3D_BUFFER_ALL, * PKSDS3D_BUFFER_ALL;
+
+typedef struct
+{
+  ULONG InsideConeAngle;
+  ULONG OutsideConeAngle;
+}KSDS3D_BUFFER_CONE_ANGLES, * PKSDS3D_BUFFER_CONE_ANGLES;
+
+ # define KSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE (-1)
+ # define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MIN 5
+ # define KSAUDIO_STEREO_SPEAKER_GEOMETRY_NARROW 10
+ # define KSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE 20
+ # define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MAX 180
+
+ # define KSDSOUND_3D_MODE_NORMAL 0x00000000
+ # define KSDSOUND_3D_MODE_HEADRELATIVE 0x00000001
+ # define KSDSOUND_3D_MODE_DISABLE 0x00000002
+
+ # define KSDSOUND_BUFFER_CTRL_HRTF_3D 0x40000000
+
+typedef struct
+{
+  ULONG Size;
+  ULONG Enabled;
+  WINBOOL SwapChannels;
+  WINBOOL ZeroAzimuth;
+  WINBOOL CrossFadeOutput;
+  ULONG FilterSize;
+}KSDS3D_HRTF_PARAMS_MSG, * PKSDS3D_HRTF_PARAMS_MSG;
+
+typedef enum
+{
+  FULL_FILTER,
+  LIGHT_FILTER,
+  KSDS3D_FILTER_QUALITY_COUNT
+}KSDS3D_HRTF_FILTER_QUALITY;
+
+typedef struct
+{
+  ULONG Size;
+  KSDS3D_HRTF_FILTER_QUALITY Quality;
+  FLOAT SampleRate;
+  ULONG MaxFilterSize;
+  ULONG FilterTransientMuteLength;
+  ULONG FilterOverlapBufferLength;
+  ULONG OutputOverlapBufferLength;
+  ULONG Reserved;
+}KSDS3D_HRTF_INIT_MSG, * PKSDS3D_HRTF_INIT_MSG;
+
+typedef enum
+{
+  FLOAT_COEFF,
+  SHORT_COEFF,
+  KSDS3D_COEFF_COUNT
+}KSDS3D_HRTF_COEFF_FORMAT;
+
+typedef enum
+{
+  DIRECT_FORM,
+  CASCADE_FORM,
+  KSDS3D_FILTER_METHOD_COUNT
+}KSDS3D_HRTF_FILTER_METHOD;
+
+typedef enum
+{
+  DS3D_HRTF_VERSION_1
+}KSDS3D_HRTF_FILTER_VERSION;
+
+typedef struct
+{
+  KSDS3D_HRTF_FILTER_METHOD FilterMethod;
+  KSDS3D_HRTF_COEFF_FORMAT CoeffFormat;
+  KSDS3D_HRTF_FILTER_VERSION Version;
+  ULONG Reserved;
+}KSDS3D_HRTF_FILTER_FORMAT_MSG, * PKSDS3D_HRTF_FILTER_FORMAT_MSG;
+
+ # define STATIC_KSPROPSETID_Hrtf3d                   \
+  0xb66decb0L, 0xa083, 0x11d0, 0x85, 0x1e, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
+DEFINE_GUIDSTRUCT("b66decb0-a083-11d0-851e-00c04fd9baf3", KSPROPSETID_Hrtf3d);
+ # define KSPROPSETID_Hrtf3d DEFINE_GUIDNAMED(KSPROPSETID_Hrtf3d)
+
+typedef enum
+{
+  KSPROPERTY_HRTF3D_PARAMS = 0,
+  KSPROPERTY_HRTF3D_INITIALIZE,
+  KSPROPERTY_HRTF3D_FILTER_FORMAT
+}KSPROPERTY_HRTF3D;
+
+typedef struct
+{
+  LONG Channel;
+  FLOAT VolSmoothScale;
+  FLOAT TotalDryAttenuation;
+  FLOAT TotalWetAttenuation;
+  LONG SmoothFrequency;
+  LONG Delay;
+}KSDS3D_ITD_PARAMS, * PKSDS3D_ITD_PARAMS;
+
+typedef struct
+{
+  ULONG Enabled;
+  KSDS3D_ITD_PARAMS LeftParams;
+  KSDS3D_ITD_PARAMS RightParams;
+  ULONG Reserved;
+}KSDS3D_ITD_PARAMS_MSG, * PKSDS3D_ITD_PARAMS_MSG;
+
+ # define STATIC_KSPROPSETID_Itd3d                    \
+  0x6429f090L, 0x9fd9, 0x11d0, 0xa7, 0x5b, 0x00, 0xa0, 0xc9, 0x03, 0x65, 0xe3
+DEFINE_GUIDSTRUCT("6429f090-9fd9-11d0-a75b-00a0c90365e3", KSPROPSETID_Itd3d);
+ # define KSPROPSETID_Itd3d DEFINE_GUIDNAMED(KSPROPSETID_Itd3d)
+
+typedef enum
+{
+  KSPROPERTY_ITD3D_PARAMS = 0
+}KSPROPERTY_ITD3D;
+
+typedef struct
+{
+  KSDATARANGE DataRange;
+  ULONG MaximumChannels;
+  ULONG MinimumBitsPerSample;
+  ULONG MaximumBitsPerSample;
+  ULONG MinimumSampleFrequency;
+  ULONG MaximumSampleFrequency;
+}KSDATARANGE_AUDIO, * PKSDATARANGE_AUDIO;
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_RIFF                \
+  0x4995DAEEL, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("4995DAEE-9EE6-11D0-A40E-00A0C9223196", KSDATAFORMAT_SUBTYPE_RIFF);
+ # define KSDATAFORMAT_SUBTYPE_RIFF DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFF)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_RIFFWAVE                \
+  0xe436eb8bL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
+DEFINE_GUIDSTRUCT("e436eb8b-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_RIFFWAVE);
+ # define KSDATAFORMAT_SUBTYPE_RIFFWAVE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFWAVE)
+
+ # define STATIC_KSPROPSETID_Bibliographic                \
+  0x07BA150EL, 0xE2B1, 0x11D0, 0xAC, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("07BA150E-E2B1-11D0-AC17-00A0C9223196", KSPROPSETID_Bibliographic);
+ # define KSPROPSETID_Bibliographic DEFINE_GUIDNAMED(KSPROPSETID_Bibliographic)
+
+ # define SEB_MK_FOURCC(a, b, c, d) ((a << 24) | (b << 16) | (c << 8) | (d << 0))
+
+typedef enum
+{
+  KSPROPERTY_BIBLIOGRAPHIC_LEADER = SEB_MK_FOURCC('R', 'D', 'L', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_LCCN = SEB_MK_FOURCC('0', '1', '0', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_ISBN = SEB_MK_FOURCC('0', '2', '0', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_ISSN = SEB_MK_FOURCC('2', '2', '0', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_CATALOGINGSOURCE = SEB_MK_FOURCC('0', '4', '0', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_MAINPERSONALNAME = SEB_MK_FOURCC('0', '0', '1', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_MAINCORPORATEBODY = SEB_MK_FOURCC('0', '1', '1', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_MAINMEETINGNAME = SEB_MK_FOURCC('1', '1', '1', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_MAINUNIFORMTITLE = SEB_MK_FOURCC('0', '3', '1', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_UNIFORMTITLE = SEB_MK_FOURCC('0', '4', '2', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_TITLESTATEMENT = SEB_MK_FOURCC('5', '4', '2', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_VARYINGFORMTITLE = SEB_MK_FOURCC('6', '4', '2', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_PUBLICATION = SEB_MK_FOURCC('0', '6', '2', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_PHYSICALDESCRIPTION = SEB_MK_FOURCC('0', '0', '3', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTITLE = SEB_MK_FOURCC('0', '4', '4', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENT = SEB_MK_FOURCC('0', '9', '4', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_GENERALNOTE = SEB_MK_FOURCC('0', '0', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_BIBLIOGRAPHYNOTE = SEB_MK_FOURCC('4', '0', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_CONTENTSNOTE = SEB_MK_FOURCC('5', '0', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_CREATIONCREDIT = SEB_MK_FOURCC('8', '0', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_CITATION = SEB_MK_FOURCC('0', '1', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_PARTICIPANT = SEB_MK_FOURCC('1', '1', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_SUMMARY = SEB_MK_FOURCC('0', '2', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_TARGETAUDIENCE = SEB_MK_FOURCC('1', '2', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_ADDEDFORMAVAILABLE = SEB_MK_FOURCC('0', '3', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_SYSTEMDETAILS = SEB_MK_FOURCC('8', '3', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_AWARDS = SEB_MK_FOURCC('6', '8', '5', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYPERSONALNAME = SEB_MK_FOURCC('0', '0', '6', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTOPICALTERM = SEB_MK_FOURCC('0', '5', '6', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYGEOGRAPHIC = SEB_MK_FOURCC('1', '5', '6', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMGENRE = SEB_MK_FOURCC('5', '5', '6', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMCURRICULUM = SEB_MK_FOURCC('8', '5', '6', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYUNIFORMTITLE = SEB_MK_FOURCC('0', '3', '7', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYRELATED = SEB_MK_FOURCC('0', '4', '7', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTPERSONALNAME = SEB_MK_FOURCC('0', '0', '8', ' '),
+  KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTUNIFORMTITLE = SEB_MK_FOURCC('0', '3', '8', ' ')
+}KSPROPERTY_BIBLIOGRAPHIC;
+
+ # undef SEB_MK_FOURCC
+
+ # define STATIC_KSPROPSETID_TopologyNode                 \
+  0x45FFAAA1L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
+DEFINE_GUIDSTRUCT("45FFAAA1-6E1B-11D0-BCF2-444553540000", KSPROPSETID_TopologyNode);
+ # define KSPROPSETID_TopologyNode DEFINE_GUIDNAMED(KSPROPSETID_TopologyNode)
+
+typedef enum
+{
+  KSPROPERTY_TOPOLOGYNODE_ENABLE = 1,
+  KSPROPERTY_TOPOLOGYNODE_RESET
+}KSPROPERTY_TOPOLOGYNODE;
+
+ # define STATIC_KSPROPSETID_RtAudio                  \
+  0xa855a48c, 0x2f78, 0x4729, 0x90, 0x51, 0x19, 0x68, 0x74, 0x6b, 0x9e, 0xef
+DEFINE_GUIDSTRUCT("A855A48C-2F78-4729-9051-1968746B9EEF", KSPROPSETID_RtAudio);
+ # define KSPROPSETID_RtAudio DEFINE_GUIDNAMED(KSPROPSETID_RtAudio)
+
+typedef enum
+{
+  KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION
+}KSPROPERTY_RTAUDIO;
+
+ # define STATIC_KSPROPSETID_DrmAudioStream               \
+  0x2f2c8ddd, 0x4198, 0x4fac, 0xba, 0x29, 0x61, 0xbb, 0x5, 0xb7, 0xde, 0x6
+DEFINE_GUIDSTRUCT("2F2C8DDD-4198-4fac-BA29-61BB05B7DE06", KSPROPSETID_DrmAudioStream);
+ # define KSPROPSETID_DrmAudioStream DEFINE_GUIDNAMED(KSPROPSETID_DrmAudioStream)
+
+typedef enum
+{
+  KSPROPERTY_DRMAUDIOSTREAM_CONTENTID
+}KSPROPERTY_DRMAUDIOSTREAM;
+
+ # define STATIC_KSPROPSETID_Audio                    \
+  0x45FFAAA0L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
+DEFINE_GUIDSTRUCT("45FFAAA0-6E1B-11D0-BCF2-444553540000", KSPROPSETID_Audio);
+ # define KSPROPSETID_Audio DEFINE_GUIDNAMED(KSPROPSETID_Audio)
+
+typedef enum
+{
+  KSPROPERTY_AUDIO_LATENCY = 1,
+  KSPROPERTY_AUDIO_COPY_PROTECTION,
+  KSPROPERTY_AUDIO_CHANNEL_CONFIG,
+  KSPROPERTY_AUDIO_VOLUMELEVEL,
+  KSPROPERTY_AUDIO_POSITION,
+  KSPROPERTY_AUDIO_DYNAMIC_RANGE,
+  KSPROPERTY_AUDIO_QUALITY,
+  KSPROPERTY_AUDIO_SAMPLING_RATE,
+  KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,
+  KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
+  KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
+  KSPROPERTY_AUDIO_MUX_SOURCE,
+  KSPROPERTY_AUDIO_MUTE,
+  KSPROPERTY_AUDIO_BASS,
+  KSPROPERTY_AUDIO_MID,
+  KSPROPERTY_AUDIO_TREBLE,
+  KSPROPERTY_AUDIO_BASS_BOOST,
+  KSPROPERTY_AUDIO_EQ_LEVEL,
+  KSPROPERTY_AUDIO_NUM_EQ_BANDS,
+  KSPROPERTY_AUDIO_EQ_BANDS,
+  KSPROPERTY_AUDIO_AGC,
+  KSPROPERTY_AUDIO_DELAY,
+  KSPROPERTY_AUDIO_LOUDNESS,
+  KSPROPERTY_AUDIO_WIDE_MODE,
+  KSPROPERTY_AUDIO_WIDENESS,
+  KSPROPERTY_AUDIO_REVERB_LEVEL,
+  KSPROPERTY_AUDIO_CHORUS_LEVEL,
+  KSPROPERTY_AUDIO_DEV_SPECIFIC,
+  KSPROPERTY_AUDIO_DEMUX_DEST,
+  KSPROPERTY_AUDIO_STEREO_ENHANCE,
+  KSPROPERTY_AUDIO_MANUFACTURE_GUID,
+  KSPROPERTY_AUDIO_PRODUCT_GUID,
+  KSPROPERTY_AUDIO_CPU_RESOURCES,
+  KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
+  KSPROPERTY_AUDIO_SURROUND_ENCODE,
+  KSPROPERTY_AUDIO_3D_INTERFACE,
+  KSPROPERTY_AUDIO_PEAKMETER,
+  KSPROPERTY_AUDIO_ALGORITHM_INSTANCE,
+  KSPROPERTY_AUDIO_FILTER_STATE,
+  KSPROPERTY_AUDIO_PREFERRED_STATUS
+}KSPROPERTY_AUDIO;
+
+ # define KSAUDIO_QUALITY_WORST 0x0
+ # define KSAUDIO_QUALITY_PC 0x1
+ # define KSAUDIO_QUALITY_BASIC 0x2
+ # define KSAUDIO_QUALITY_ADVANCED 0x3
+
+ # define KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU 0x00000000
+ # define KSAUDIO_CPU_RESOURCES_HOST_CPU 0x7FFFFFFF
+
+typedef struct
+{
+  WINBOOL fCopyrighted;
+  WINBOOL fOriginal;
+}KSAUDIO_COPY_PROTECTION, * PKSAUDIO_COPY_PROTECTION;
+
+typedef struct
+{
+  LONG ActiveSpeakerPositions;
+}KSAUDIO_CHANNEL_CONFIG, * PKSAUDIO_CHANNEL_CONFIG;
+
+ # define SPEAKER_FRONT_LEFT 0x1
+ # define SPEAKER_FRONT_RIGHT 0x2
+ # define SPEAKER_FRONT_CENTER 0x4
+ # define SPEAKER_LOW_FREQUENCY 0x8
+ # define SPEAKER_BACK_LEFT 0x10
+ # define SPEAKER_BACK_RIGHT 0x20
+ # define SPEAKER_FRONT_LEFT_OF_CENTER 0x40
+ # define SPEAKER_FRONT_RIGHT_OF_CENTER 0x80
+ # define SPEAKER_BACK_CENTER 0x100
+ # define SPEAKER_SIDE_LEFT 0x200
+ # define SPEAKER_SIDE_RIGHT 0x400
+ # define SPEAKER_TOP_CENTER 0x800
+ # define SPEAKER_TOP_FRONT_LEFT 0x1000
+ # define SPEAKER_TOP_FRONT_CENTER 0x2000
+ # define SPEAKER_TOP_FRONT_RIGHT 0x4000
+ # define SPEAKER_TOP_BACK_LEFT 0x8000
+ # define SPEAKER_TOP_BACK_CENTER 0x10000
+ # define SPEAKER_TOP_BACK_RIGHT 0x20000
+
+ # define SPEAKER_RESERVED 0x7FFC0000
+
+ # define SPEAKER_ALL 0x80000000
+
+ # define KSAUDIO_SPEAKER_DIRECTOUT 0
+ # define KSAUDIO_SPEAKER_MONO (SPEAKER_FRONT_CENTER)
+ # define KSAUDIO_SPEAKER_STEREO (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT)
+ # define KSAUDIO_SPEAKER_QUAD (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |     \
+                                SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT)
+ # define KSAUDIO_SPEAKER_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |     \
+                                    SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER)
+ # define KSAUDIO_SPEAKER_5POINT1 (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |     \
+                                   SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY |     \
+                                   SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT)
+ # define KSAUDIO_SPEAKER_7POINT1 (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |     \
+                                   SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY |     \
+                                   SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT |       \
+                                   SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER)
+ # define KSAUDIO_SPEAKER_5POINT1_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |        \
+                                            SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY |    \
+                                            SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT)
+ # define KSAUDIO_SPEAKER_7POINT1_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT |        \
+                                            SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY |    \
+                                            SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT |      \
+                                            SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT)
+
+ # define KSAUDIO_SPEAKER_5POINT1_BACK KSAUDIO_SPEAKER_5POINT1
+ # define KSAUDIO_SPEAKER_7POINT1_WIDE KSAUDIO_SPEAKER_7POINT1
+
+ # define KSAUDIO_SPEAKER_GROUND_FRONT_LEFT SPEAKER_FRONT_LEFT
+ # define KSAUDIO_SPEAKER_GROUND_FRONT_CENTER SPEAKER_FRONT_CENTER
+ # define KSAUDIO_SPEAKER_GROUND_FRONT_RIGHT SPEAKER_FRONT_RIGHT
+ # define KSAUDIO_SPEAKER_GROUND_REAR_LEFT SPEAKER_BACK_LEFT
+ # define KSAUDIO_SPEAKER_GROUND_REAR_RIGHT SPEAKER_BACK_RIGHT
+ # define KSAUDIO_SPEAKER_TOP_MIDDLE SPEAKER_TOP_CENTER
+ # define KSAUDIO_SPEAKER_SUPER_WOOFER SPEAKER_LOW_FREQUENCY
+
+typedef struct
+{
+  ULONG QuietCompression;
+  ULONG LoudCompression;
+}KSAUDIO_DYNAMIC_RANGE, * PKSAUDIO_DYNAMIC_RANGE;
+
+typedef struct
+{
+  WINBOOL Mute;
+  LONG Level;
+}KSAUDIO_MIXLEVEL, * PKSAUDIO_MIXLEVEL;
+
+typedef struct
+{
+  WINBOOL Mute;
+  LONG Minimum;
+  LONG Maximum;
+  LONG Reset;
+}KSAUDIO_MIX_CAPS, * PKSAUDIO_MIX_CAPS;
+
+typedef struct
+{
+  ULONG InputChannels;
+  ULONG OutputChannels;
+  KSAUDIO_MIX_CAPS Capabilities[1];
+}KSAUDIO_MIXCAP_TABLE, * PKSAUDIO_MIXCAP_TABLE;
+
+typedef enum
+{
+  SE_TECH_NONE,
+  SE_TECH_ANALOG_DEVICES_PHAT,
+  SE_TECH_CREATIVE,
+  SE_TECH_NATIONAL_SEMI,
+  SE_TECH_YAMAHA_YMERSION,
+  SE_TECH_BBE,
+  SE_TECH_CRYSTAL_SEMI,
+  SE_TECH_QSOUND_QXPANDER,
+  SE_TECH_SPATIALIZER,
+  SE_TECH_SRS,
+  SE_TECH_PLATFORM_TECH,
+  SE_TECH_AKM,
+  SE_TECH_AUREAL,
+  SE_TECH_AZTECH,
+  SE_TECH_BINAURA,
+  SE_TECH_ESS_TECH,
+  SE_TECH_HARMAN_VMAX,
+  SE_TECH_NVIDEA,
+  SE_TECH_PHILIPS_INCREDIBLE,
+  SE_TECH_TEXAS_INST,
+  SE_TECH_VLSI_TECH
+}SE_TECHNIQUE;
+
+typedef struct
+{
+  SE_TECHNIQUE Technique;
+  ULONG Center;
+  ULONG Depth;
+  ULONG Reserved;
+}KSAUDIO_STEREO_ENHANCE, * PKSAUDIO_STEREO_ENHANCE;
+
+typedef enum
+{
+  KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT = 0,
+  KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT,
+  KSPROPERTY_SYSAUDIO_RECORD_DEFAULT,
+  KSPROPERTY_SYSAUDIO_MIDI_DEFAULT,
+  KSPROPERTY_SYSAUDIO_MIXER_DEFAULT
+}KSPROPERTY_SYSAUDIO_DEFAULT_TYPE;
+
+typedef struct
+{
+  WINBOOL Enable;
+  KSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType;
+  ULONG Flags;
+  ULONG Reserved;
+}KSAUDIO_PREFERRED_STATUS, * PKSAUDIO_PREFERRED_STATUS;
+
+ # define STATIC_KSNODETYPE_DAC                       \
+  0x507AE360L, 0xC554, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("507AE360-C554-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DAC);
+ # define KSNODETYPE_DAC DEFINE_GUIDNAMED(KSNODETYPE_DAC)
+
+ # define STATIC_KSNODETYPE_ADC                       \
+  0x4D837FE0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("4D837FE0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_ADC);
+ # define KSNODETYPE_ADC DEFINE_GUIDNAMED(KSNODETYPE_ADC)
+
+ # define STATIC_KSNODETYPE_SRC                       \
+  0x9DB7B9E0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("9DB7B9E0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SRC);
+ # define KSNODETYPE_SRC DEFINE_GUIDNAMED(KSNODETYPE_SRC)
+
+ # define STATIC_KSNODETYPE_SUPERMIX                  \
+  0xE573ADC0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("E573ADC0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SUPERMIX);
+ # define KSNODETYPE_SUPERMIX DEFINE_GUIDNAMED(KSNODETYPE_SUPERMIX)
+
+ # define STATIC_KSNODETYPE_MUX                       \
+  0x2CEAF780L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("2CEAF780-C556-11D0-8A2B-00A0C9255AC1", KSNODETYPE_MUX);
+ # define KSNODETYPE_MUX DEFINE_GUIDNAMED(KSNODETYPE_MUX)
+
+ # define STATIC_KSNODETYPE_DEMUX                     \
+  0xC0EB67D4L, 0xE807, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("C0EB67D4-E807-11D0-958A-00C04FB925D3", KSNODETYPE_DEMUX);
+ # define KSNODETYPE_DEMUX DEFINE_GUIDNAMED(KSNODETYPE_DEMUX)
+
+ # define STATIC_KSNODETYPE_SUM                       \
+  0xDA441A60L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("DA441A60-C556-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SUM);
+ # define KSNODETYPE_SUM DEFINE_GUIDNAMED(KSNODETYPE_SUM)
+
+ # define STATIC_KSNODETYPE_MUTE                      \
+  0x02B223C0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("02B223C0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_MUTE);
+ # define KSNODETYPE_MUTE DEFINE_GUIDNAMED(KSNODETYPE_MUTE)
+
+ # define STATIC_KSNODETYPE_VOLUME                    \
+  0x3A5ACC00L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("3A5ACC00-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_VOLUME);
+ # define KSNODETYPE_VOLUME DEFINE_GUIDNAMED(KSNODETYPE_VOLUME)
+
+ # define STATIC_KSNODETYPE_TONE                      \
+  0x7607E580L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("7607E580-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_TONE);
+ # define KSNODETYPE_TONE DEFINE_GUIDNAMED(KSNODETYPE_TONE)
+
+ # define STATIC_KSNODETYPE_EQUALIZER                 \
+  0x9D41B4A0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("9D41B4A0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_EQUALIZER);
+ # define KSNODETYPE_EQUALIZER DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZER)
+
+ # define STATIC_KSNODETYPE_AGC                       \
+  0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("E88C9BA0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_AGC);
+ # define KSNODETYPE_AGC DEFINE_GUIDNAMED(KSNODETYPE_AGC)
+
+ # define STATIC_KSNODETYPE_NOISE_SUPPRESS                \
+  0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5
+DEFINE_GUIDSTRUCT("E07F903F-62FD-4e60-8CDD-DEA7236665B5", KSNODETYPE_NOISE_SUPPRESS);
+ # define KSNODETYPE_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSNODETYPE_NOISE_SUPPRESS)
+
+ # define STATIC_KSNODETYPE_DELAY                     \
+  0x144981E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("144981E0-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DELAY);
+ # define KSNODETYPE_DELAY DEFINE_GUIDNAMED(KSNODETYPE_DELAY)
+
+ # define STATIC_KSNODETYPE_LOUDNESS                  \
+  0x41887440L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("41887440-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_LOUDNESS);
+ # define KSNODETYPE_LOUDNESS DEFINE_GUIDNAMED(KSNODETYPE_LOUDNESS)
+
+ # define STATIC_KSNODETYPE_PROLOGIC_DECODER              \
+  0x831C2C80L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("831C2C80-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_PROLOGIC_DECODER);
+ # define KSNODETYPE_PROLOGIC_DECODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_DECODER)
+
+ # define STATIC_KSNODETYPE_STEREO_WIDE                   \
+  0xA9E69800L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("A9E69800-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_STEREO_WIDE);
+ # define KSNODETYPE_STEREO_WIDE DEFINE_GUIDNAMED(KSNODETYPE_STEREO_WIDE)
+
+ # define STATIC_KSNODETYPE_STEREO_ENHANCE                \
+  0xAF6878ACL, 0xE83F, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("AF6878AC-E83F-11D0-958A-00C04FB925D3", KSNODETYPE_STEREO_ENHANCE);
+ # define KSNODETYPE_STEREO_ENHANCE DEFINE_GUIDNAMED(KSNODETYPE_STEREO_ENHANCE)
+
+ # define STATIC_KSNODETYPE_REVERB                    \
+  0xEF0328E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("EF0328E0-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_REVERB);
+ # define KSNODETYPE_REVERB DEFINE_GUIDNAMED(KSNODETYPE_REVERB)
+
+ # define STATIC_KSNODETYPE_CHORUS                    \
+  0x20173F20L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("20173F20-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_CHORUS);
+ # define KSNODETYPE_CHORUS DEFINE_GUIDNAMED(KSNODETYPE_CHORUS)
+
+ # define STATIC_KSNODETYPE_3D_EFFECTS                    \
+  0x55515860L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("55515860-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_3D_EFFECTS);
+ # define KSNODETYPE_3D_EFFECTS DEFINE_GUIDNAMED(KSNODETYPE_3D_EFFECTS)
+
+ # define STATIC_KSNODETYPE_ACOUSTIC_ECHO_CANCEL STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL
+ # define KSNODETYPE_ACOUSTIC_ECHO_CANCEL KSCATEGORY_ACOUSTIC_ECHO_CANCEL
+
+ # define STATIC_KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL      \
+  0x1c22c56dL, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10
+DEFINE_GUIDSTRUCT("1C22C56D-9879-4f5b-A389-27996DDC2810", KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL);
+ # define KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL)
+
+ # define STATIC_KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS        \
+  0x5ab0882eL, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0
+DEFINE_GUIDSTRUCT("5AB0882E-7274-4516-877D-4EEE99BA4FD0", KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS);
+ # define KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS)
+
+ # define STATIC_KSALGORITHMINSTANCE_SYSTEM_AGC               \
+  0x950e55b9L, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa
+DEFINE_GUIDSTRUCT("950E55B9-877C-4c67-BE08-E47B5611130A", KSALGORITHMINSTANCE_SYSTEM_AGC);
+ # define KSALGORITHMINSTANCE_SYSTEM_AGC DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_AGC)
+
+ # define STATIC_KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR    \
+  0xB6F5A0A0L, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F
+DEFINE_GUIDSTRUCT("B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F", KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR);
+ # define KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR)
+
+ # define STATIC_KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR STATIC_KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR
+ # define KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR
+
+ # define STATIC_KSNODETYPE_DEV_SPECIFIC                  \
+  0x941C7AC0L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
+DEFINE_GUIDSTRUCT("941C7AC0-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DEV_SPECIFIC);
+ # define KSNODETYPE_DEV_SPECIFIC DEFINE_GUIDNAMED(KSNODETYPE_DEV_SPECIFIC)
+
+ # define STATIC_KSNODETYPE_PROLOGIC_ENCODER              \
+  0x8074C5B2L, 0x3C66, 0x11D2, 0xB4, 0x5A, 0x30, 0x78, 0x30, 0x2C, 0x20, 0x30
+DEFINE_GUIDSTRUCT("8074C5B2-3C66-11D2-B45A-3078302C2030", KSNODETYPE_PROLOGIC_ENCODER);
+ # define KSNODETYPE_PROLOGIC_ENCODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_ENCODER)
+ # define KSNODETYPE_SURROUND_ENCODER KSNODETYPE_PROLOGIC_ENCODER
+
+ # define STATIC_KSNODETYPE_PEAKMETER                 \
+  0xa085651eL, 0x5f0d, 0x4b36, 0xa8, 0x69, 0xd1, 0x95, 0xd6, 0xab, 0x4b, 0x9e
+DEFINE_GUIDSTRUCT("A085651E-5F0D-4b36-A869-D195D6AB4B9E", KSNODETYPE_PEAKMETER);
+ # define KSNODETYPE_PEAKMETER DEFINE_GUIDNAMED(KSNODETYPE_PEAKMETER)
+
+ # define STATIC_KSAUDFNAME_BASS                      \
+  0x185FEDE0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDE0-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_BASS);
+ # define KSAUDFNAME_BASS DEFINE_GUIDNAMED(KSAUDFNAME_BASS)
+
+ # define STATIC_KSAUDFNAME_TREBLE                    \
+  0x185FEDE1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDE1-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_TREBLE);
+ # define KSAUDFNAME_TREBLE DEFINE_GUIDNAMED(KSAUDFNAME_TREBLE)
+
+ # define STATIC_KSAUDFNAME_3D_STEREO                 \
+  0x185FEDE2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDE2-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_3D_STEREO);
+ # define KSAUDFNAME_3D_STEREO DEFINE_GUIDNAMED(KSAUDFNAME_3D_STEREO)
+
+ # define STATIC_KSAUDFNAME_MASTER_VOLUME                 \
+  0x185FEDE3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDE3-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MASTER_VOLUME);
+ # define KSAUDFNAME_MASTER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_VOLUME)
+
+ # define STATIC_KSAUDFNAME_MASTER_MUTE                   \
+  0x185FEDE4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDE4-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MASTER_MUTE);
+ # define KSAUDFNAME_MASTER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_MUTE)
+
+ # define STATIC_KSAUDFNAME_WAVE_VOLUME                   \
+  0x185FEDE5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDE5-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_VOLUME);
+ # define KSAUDFNAME_WAVE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_VOLUME)
+
+ # define STATIC_KSAUDFNAME_WAVE_MUTE                 \
+  0x185FEDE6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDE6-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_MUTE);
+ # define KSAUDFNAME_WAVE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_MUTE)
+
+ # define STATIC_KSAUDFNAME_MIDI_VOLUME                   \
+  0x185FEDE7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDE7-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_VOLUME);
+ # define KSAUDFNAME_MIDI_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_VOLUME)
+
+ # define STATIC_KSAUDFNAME_MIDI_MUTE                 \
+  0x185FEDE8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDE8-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_MUTE);
+ # define KSAUDFNAME_MIDI_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_MUTE)
+
+ # define STATIC_KSAUDFNAME_CD_VOLUME                 \
+  0x185FEDE9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDE9-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_VOLUME);
+ # define KSAUDFNAME_CD_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_VOLUME)
+
+ # define STATIC_KSAUDFNAME_CD_MUTE                   \
+  0x185FEDEAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDEA-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_MUTE);
+ # define KSAUDFNAME_CD_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_CD_MUTE)
+
+ # define STATIC_KSAUDFNAME_LINE_VOLUME                   \
+  0x185FEDEBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDEB-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_VOLUME);
+ # define KSAUDFNAME_LINE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_VOLUME)
+
+ # define STATIC_KSAUDFNAME_LINE_MUTE                 \
+  0x185FEDECL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDEC-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_MUTE);
+ # define KSAUDFNAME_LINE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_LINE_MUTE)
+
+ # define STATIC_KSAUDFNAME_MIC_VOLUME                    \
+  0x185FEDEDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDED-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_VOLUME);
+ # define KSAUDFNAME_MIC_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_VOLUME)
+
+ # define STATIC_KSAUDFNAME_MIC_MUTE                  \
+  0x185FEDEEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDEE-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_MUTE);
+ # define KSAUDFNAME_MIC_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIC_MUTE)
+
+ # define STATIC_KSAUDFNAME_RECORDING_SOURCE              \
+  0x185FEDEFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDEF-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_RECORDING_SOURCE);
+ # define KSAUDFNAME_RECORDING_SOURCE DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_SOURCE)
+
+ # define STATIC_KSAUDFNAME_PC_SPEAKER_VOLUME             \
+  0x185FEDF0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDF0-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER_VOLUME);
+ # define KSAUDFNAME_PC_SPEAKER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_VOLUME)
+
+ # define STATIC_KSAUDFNAME_PC_SPEAKER_MUTE               \
+  0x185FEDF1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDF1-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER_MUTE);
+ # define KSAUDFNAME_PC_SPEAKER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_MUTE)
+
+ # define STATIC_KSAUDFNAME_MIDI_IN_VOLUME                \
+  0x185FEDF2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDF2-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_IN_VOLUME);
+ # define KSAUDFNAME_MIDI_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_IN_VOLUME)
+
+ # define STATIC_KSAUDFNAME_CD_IN_VOLUME                  \
+  0x185FEDF3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDF3-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_IN_VOLUME);
+ # define KSAUDFNAME_CD_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_IN_VOLUME)
+
+ # define STATIC_KSAUDFNAME_LINE_IN_VOLUME                \
+  0x185FEDF4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDF4-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_IN_VOLUME);
+ # define KSAUDFNAME_LINE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN_VOLUME)
+
+ # define STATIC_KSAUDFNAME_MIC_IN_VOLUME                 \
+  0x185FEDF5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDF5-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_IN_VOLUME);
+ # define KSAUDFNAME_MIC_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_IN_VOLUME)
+
+ # define STATIC_KSAUDFNAME_WAVE_IN_VOLUME                \
+  0x185FEDF6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDF6-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_IN_VOLUME);
+ # define KSAUDFNAME_WAVE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_IN_VOLUME)
+
+ # define STATIC_KSAUDFNAME_VOLUME_CONTROL                \
+  0x185FEDF7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDF7-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_VOLUME_CONTROL);
+ # define KSAUDFNAME_VOLUME_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_VOLUME_CONTROL)
+
+ # define STATIC_KSAUDFNAME_MIDI                      \
+  0x185FEDF8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDF8-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI);
+ # define KSAUDFNAME_MIDI DEFINE_GUIDNAMED(KSAUDFNAME_MIDI)
+
+ # define STATIC_KSAUDFNAME_LINE_IN                   \
+  0x185FEDF9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDF9-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_IN);
+ # define KSAUDFNAME_LINE_IN DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN)
+
+ # define STATIC_KSAUDFNAME_RECORDING_CONTROL             \
+  0x185FEDFAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDFA-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_RECORDING_CONTROL);
+ # define KSAUDFNAME_RECORDING_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_CONTROL)
+
+ # define STATIC_KSAUDFNAME_CD_AUDIO                  \
+  0x185FEDFBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDFB-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_AUDIO);
+ # define KSAUDFNAME_CD_AUDIO DEFINE_GUIDNAMED(KSAUDFNAME_CD_AUDIO)
+
+ # define STATIC_KSAUDFNAME_AUX_VOLUME                    \
+  0x185FEDFCL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDFC-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX_VOLUME);
+ # define KSAUDFNAME_AUX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_AUX_VOLUME)
+
+ # define STATIC_KSAUDFNAME_AUX_MUTE                  \
+  0x185FEDFDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDFD-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX_MUTE);
+ # define KSAUDFNAME_AUX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_AUX_MUTE)
+
+ # define STATIC_KSAUDFNAME_AUX                       \
+  0x185FEDFEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDFE-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX);
+ # define KSAUDFNAME_AUX DEFINE_GUIDNAMED(KSAUDFNAME_AUX)
+
+ # define STATIC_KSAUDFNAME_PC_SPEAKER                    \
+  0x185FEDFFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEDFF-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER);
+ # define KSAUDFNAME_PC_SPEAKER DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER)
+
+ # define STATIC_KSAUDFNAME_WAVE_OUT_MIX                  \
+  0x185FEE00L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("185FEE00-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_OUT_MIX);
+ # define KSAUDFNAME_WAVE_OUT_MIX DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_OUT_MIX)
+
+ # define STATIC_KSAUDFNAME_MONO_OUT                  \
+  0xf9b41dc3L, 0x96e2, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("F9B41DC3-96E2-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT);
+ # define KSAUDFNAME_MONO_OUT DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT)
+
+ # define STATIC_KSAUDFNAME_STEREO_MIX                    \
+  0xdff077L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("00DFF077-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX);
+ # define KSAUDFNAME_STEREO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX)
+
+ # define STATIC_KSAUDFNAME_MONO_MIX                  \
+  0xdff078L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("00DFF078-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX);
+ # define KSAUDFNAME_MONO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX)
+
+ # define STATIC_KSAUDFNAME_MONO_OUT_VOLUME               \
+  0x1ad247ebL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("1AD247EB-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT_VOLUME);
+ # define KSAUDFNAME_MONO_OUT_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_VOLUME)
+
+ # define STATIC_KSAUDFNAME_MONO_OUT_MUTE                 \
+  0x1ad247ecL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("1AD247EC-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT_MUTE);
+ # define KSAUDFNAME_MONO_OUT_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_MUTE)
+
+ # define STATIC_KSAUDFNAME_STEREO_MIX_VOLUME             \
+  0x1ad247edL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("1AD247ED-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX_VOLUME);
+ # define KSAUDFNAME_STEREO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_VOLUME)
+
+ # define STATIC_KSAUDFNAME_STEREO_MIX_MUTE               \
+  0x22b0eafdL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("22B0EAFD-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX_MUTE);
+ # define KSAUDFNAME_STEREO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_MUTE)
+
+ # define STATIC_KSAUDFNAME_MONO_MIX_VOLUME               \
+  0x22b0eafeL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("22B0EAFE-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX_VOLUME);
+ # define KSAUDFNAME_MONO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_VOLUME)
+
+ # define STATIC_KSAUDFNAME_MONO_MIX_MUTE                 \
+  0x2bc31d69L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("2BC31D69-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX_MUTE);
+ # define KSAUDFNAME_MONO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_MUTE)
+
+ # define STATIC_KSAUDFNAME_MICROPHONE_BOOST              \
+  0x2bc31d6aL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("2BC31D6A-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MICROPHONE_BOOST);
+ # define KSAUDFNAME_MICROPHONE_BOOST DEFINE_GUIDNAMED(KSAUDFNAME_MICROPHONE_BOOST)
+
+ # define STATIC_KSAUDFNAME_ALTERNATE_MICROPHONE              \
+  0x2bc31d6bL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("2BC31D6B-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_ALTERNATE_MICROPHONE);
+ # define KSAUDFNAME_ALTERNATE_MICROPHONE DEFINE_GUIDNAMED(KSAUDFNAME_ALTERNATE_MICROPHONE)
+
+ # define STATIC_KSAUDFNAME_3D_DEPTH                  \
+  0x63ff5747L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("63FF5747-991F-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_3D_DEPTH);
+ # define KSAUDFNAME_3D_DEPTH DEFINE_GUIDNAMED(KSAUDFNAME_3D_DEPTH)
+
+ # define STATIC_KSAUDFNAME_3D_CENTER                 \
+  0x9f0670b4L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("9F0670B4-991F-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_3D_CENTER);
+ # define KSAUDFNAME_3D_CENTER DEFINE_GUIDNAMED(KSAUDFNAME_3D_CENTER)
+
+ # define STATIC_KSAUDFNAME_VIDEO_VOLUME                  \
+  0x9b46e708L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("9B46E708-992A-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_VIDEO_VOLUME);
+ # define KSAUDFNAME_VIDEO_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_VOLUME)
+
+ # define STATIC_KSAUDFNAME_VIDEO_MUTE                    \
+  0x9b46e709L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("9B46E709-992A-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_VIDEO_MUTE);
+ # define KSAUDFNAME_VIDEO_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_MUTE)
+
+ # define STATIC_KSAUDFNAME_VIDEO                     \
+  0x915daec4L, 0xa434, 0x11d2, 0xac, 0x52, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
+DEFINE_GUIDSTRUCT("915DAEC4-A434-11d2-AC52-00C04F8EFB68", KSAUDFNAME_VIDEO);
+ # define KSAUDFNAME_VIDEO DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO)
+
+ # define STATIC_KSAUDFNAME_PEAKMETER                 \
+  0x57e24340L, 0xfc5b, 0x4612, 0xa5, 0x62, 0x72, 0xb1, 0x1a, 0x29, 0xdf, 0xae
+DEFINE_GUIDSTRUCT("57E24340-FC5B-4612-A562-72B11A29DFAE", KSAUDFNAME_PEAKMETER);
+ # define KSAUDFNAME_PEAKMETER DEFINE_GUIDNAMED(KSAUDFNAME_PEAKMETER)
+
+ # define KSNODEPIN_STANDARD_IN 1
+ # define KSNODEPIN_STANDARD_OUT 0
+
+ # define KSNODEPIN_SUM_MUX_IN 1
+ # define KSNODEPIN_SUM_MUX_OUT 0
+
+ # define KSNODEPIN_DEMUX_IN 0
+ # define KSNODEPIN_DEMUX_OUT 1
+
+ # define KSNODEPIN_AEC_RENDER_IN 1
+ # define KSNODEPIN_AEC_RENDER_OUT 0
+ # define KSNODEPIN_AEC_CAPTURE_IN 2
+ # define KSNODEPIN_AEC_CAPTURE_OUT 3
+
+ # define STATIC_KSMETHODSETID_Wavetable                  \
+  0xDCEF31EBL, 0xD907, 0x11D0, 0x95, 0x83, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("DCEF31EB-D907-11D0-9583-00C04FB925D3", KSMETHODSETID_Wavetable);
+ # define KSMETHODSETID_Wavetable DEFINE_GUIDNAMED(KSMETHODSETID_Wavetable)
+
+typedef enum
+{
+  KSMETHOD_WAVETABLE_WAVE_ALLOC,
+  KSMETHOD_WAVETABLE_WAVE_FREE,
+  KSMETHOD_WAVETABLE_WAVE_FIND,
+  KSMETHOD_WAVETABLE_WAVE_WRITE
+}KSMETHOD_WAVETABLE;
+
+typedef struct
+{
+  KSIDENTIFIER Identifier;
+  ULONG Size;
+  WINBOOL Looped;
+  ULONG LoopPoint;
+  WINBOOL InROM;
+  KSDATAFORMAT Format;
+}KSWAVETABLE_WAVE_DESC, * PKSWAVETABLE_WAVE_DESC;
+
+ # define STATIC_KSPROPSETID_Acoustic_Echo_Cancel             \
+  0xd7a4af8bL, 0x3dc1, 0x4902, 0x91, 0xea, 0x8a, 0x15, 0xc9, 0x0e, 0x05, 0xb2
+DEFINE_GUIDSTRUCT("D7A4AF8B-3DC1-4902-91EA-8A15C90E05B2", KSPROPSETID_Acoustic_Echo_Cancel);
+ # define KSPROPSETID_Acoustic_Echo_Cancel DEFINE_GUIDNAMED(KSPROPSETID_Acoustic_Echo_Cancel)
+
+typedef enum
+{
+  KSPROPERTY_AEC_NOISE_FILL_ENABLE = 0,
+  KSPROPERTY_AEC_STATUS,
+  KSPROPERTY_AEC_MODE
+}KSPROPERTY_AEC;
+
+ # define AEC_STATUS_FD_HISTORY_UNINITIALIZED 0x0
+ # define AEC_STATUS_FD_HISTORY_CONTINUOUSLY_CONVERGED 0x1
+ # define AEC_STATUS_FD_HISTORY_PREVIOUSLY_DIVERGED 0x2
+ # define AEC_STATUS_FD_CURRENTLY_CONVERGED 0x8
+
+ # define AEC_MODE_PASS_THROUGH 0x0
+ # define AEC_MODE_HALF_DUPLEX 0x1
+ # define AEC_MODE_FULL_DUPLEX 0x2
+
+ # define STATIC_KSPROPSETID_Wave                     \
+  0x924e54b0L, 0x630f, 0x11cf, 0xad, 0xa7, 0x08, 0x00, 0x3e, 0x30, 0x49, 0x4a
+DEFINE_GUIDSTRUCT("924e54b0-630f-11cf-ada7-08003e30494a", KSPROPSETID_Wave);
+ # define KSPROPSETID_Wave DEFINE_GUIDNAMED(KSPROPSETID_Wave)
+
+typedef enum
+{
+  KSPROPERTY_WAVE_COMPATIBLE_CAPABILITIES,
+  KSPROPERTY_WAVE_INPUT_CAPABILITIES,
+  KSPROPERTY_WAVE_OUTPUT_CAPABILITIES,
+  KSPROPERTY_WAVE_BUFFER,
+  KSPROPERTY_WAVE_FREQUENCY,
+  KSPROPERTY_WAVE_VOLUME,
+  KSPROPERTY_WAVE_PAN
+}KSPROPERTY_WAVE;
+
+typedef struct
+{
+  ULONG ulDeviceType;
+}KSWAVE_COMPATCAPS, * PKSWAVE_COMPATCAPS;
+
+ # define KSWAVE_COMPATCAPS_INPUT 0x00000000
+ # define KSWAVE_COMPATCAPS_OUTPUT 0x00000001
+
+typedef struct
+{
+  ULONG MaximumChannelsPerConnection;
+  ULONG MinimumBitsPerSample;
+  ULONG MaximumBitsPerSample;
+  ULONG MinimumSampleFrequency;
+  ULONG MaximumSampleFrequency;
+  ULONG TotalConnections;
+  ULONG ActiveConnections;
+}KSWAVE_INPUT_CAPABILITIES, * PKSWAVE_INPUT_CAPABILITIES;
+
+typedef struct
+{
+  ULONG MaximumChannelsPerConnection;
+  ULONG MinimumBitsPerSample;
+  ULONG MaximumBitsPerSample;
+  ULONG MinimumSampleFrequency;
+  ULONG MaximumSampleFrequency;
+  ULONG TotalConnections;
+  ULONG StaticConnections;
+  ULONG StreamingConnections;
+  ULONG ActiveConnections;
+  ULONG ActiveStaticConnections;
+  ULONG ActiveStreamingConnections;
+  ULONG Total3DConnections;
+  ULONG Static3DConnections;
+  ULONG Streaming3DConnections;
+  ULONG Active3DConnections;
+  ULONG ActiveStatic3DConnections;
+  ULONG ActiveStreaming3DConnections;
+  ULONG TotalSampleMemory;
+  ULONG FreeSampleMemory;
+  ULONG LargestFreeContiguousSampleMemory;
+}KSWAVE_OUTPUT_CAPABILITIES, * PKSWAVE_OUTPUT_CAPABILITIES;
+
+typedef struct
+{
+  LONG LeftAttenuation;
+  LONG RightAttenuation;
+}KSWAVE_VOLUME, * PKSWAVE_VOLUME;
+
+ # define KSWAVE_BUFFER_ATTRIBUTEF_LOOPING 0x00000001
+ # define KSWAVE_BUFFER_ATTRIBUTEF_STATIC 0x00000002
+
+typedef struct
+{
+  ULONG Attributes;
+  ULONG BufferSize;
+  PVOID BufferAddress;
+}KSWAVE_BUFFER, * PKSWAVE_BUFFER;
+
+ # define STATIC_KSMUSIC_TECHNOLOGY_PORT                  \
+  0x86C92E60L, 0x62E8, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("86C92E60-62E8-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_PORT);
+ # define KSMUSIC_TECHNOLOGY_PORT DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_PORT)
+
+ # define STATIC_KSMUSIC_TECHNOLOGY_SQSYNTH               \
+  0x0ECF4380L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("0ECF4380-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_SQSYNTH);
+ # define KSMUSIC_TECHNOLOGY_SQSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SQSYNTH)
+
+ # define STATIC_KSMUSIC_TECHNOLOGY_FMSYNTH               \
+  0x252C5C80L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("252C5C80-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_FMSYNTH);
+ # define KSMUSIC_TECHNOLOGY_FMSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_FMSYNTH)
+
+ # define STATIC_KSMUSIC_TECHNOLOGY_WAVETABLE             \
+  0x394EC7C0L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("394EC7C0-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_WAVETABLE);
+ # define KSMUSIC_TECHNOLOGY_WAVETABLE DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_WAVETABLE)
+
+ # define STATIC_KSMUSIC_TECHNOLOGY_SWSYNTH               \
+  0x37407736L, 0x3620, 0x11D1, 0x85, 0xD3, 0x00, 0x00, 0xF8, 0x75, 0x43, 0x80
+DEFINE_GUIDSTRUCT("37407736-3620-11D1-85D3-0000F8754380", KSMUSIC_TECHNOLOGY_SWSYNTH);
+ # define KSMUSIC_TECHNOLOGY_SWSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SWSYNTH)
+
+ # define STATIC_KSPROPSETID_WaveTable                    \
+  0x8539E660L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("8539E660-62E9-11CF-A5D6-28DB04C10000", KSPROPSETID_WaveTable);
+ # define KSPROPSETID_WaveTable DEFINE_GUIDNAMED(KSPROPSETID_WaveTable)
+
+typedef enum
+{
+  KSPROPERTY_WAVETABLE_LOAD_SAMPLE,
+  KSPROPERTY_WAVETABLE_UNLOAD_SAMPLE,
+  KSPROPERTY_WAVETABLE_MEMORY,
+  KSPROPERTY_WAVETABLE_VERSION
+}KSPROPERTY_WAVETABLE;
+
+typedef struct
+{
+  KSDATARANGE DataRange;
+  GUID Technology;
+  ULONG Channels;
+  ULONG Notes;
+  ULONG ChannelMask;
+}KSDATARANGE_MUSIC, * PKSDATARANGE_MUSIC;
+
+ # define STATIC_KSEVENTSETID_Cyclic                  \
+  0x142C1AC0L, 0x072A, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("142C1AC0-072A-11D0-A5D6-28DB04C10000", KSEVENTSETID_Cyclic);
+ # define KSEVENTSETID_Cyclic DEFINE_GUIDNAMED(KSEVENTSETID_Cyclic)
+
+typedef enum
+{
+  KSEVENT_CYCLIC_TIME_INTERVAL
+}KSEVENT_CYCLIC_TIME;
+
+ # define STATIC_KSPROPSETID_Cyclic                   \
+  0x3FFEAEA0L, 0x2BEE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("3FFEAEA0-2BEE-11CF-A5D6-28DB04C10000", KSPROPSETID_Cyclic);
+ # define KSPROPSETID_Cyclic DEFINE_GUIDNAMED(KSPROPSETID_Cyclic)
+
+typedef enum
+{
+  KSPROPERTY_CYCLIC_POSITION
+}KSPROPERTY_CYCLIC;
+
+ # define STATIC_KSEVENTSETID_AudioControlChange              \
+  0xE85E9698L, 0xFA2F, 0x11D1, 0x95, 0xBD, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
+DEFINE_GUIDSTRUCT("E85E9698-FA2F-11D1-95BD-00C04FB925D3", KSEVENTSETID_AudioControlChange);
+ # define KSEVENTSETID_AudioControlChange DEFINE_GUIDNAMED(KSEVENTSETID_AudioControlChange)
+
+typedef enum
+{
+  KSEVENT_CONTROL_CHANGE
+}KSEVENT_AUDIO_CONTROL_CHANGE;
+
+ # define STATIC_KSEVENTSETID_LoopedStreaming             \
+  0x4682B940L, 0xC6EF, 0x11D0, 0x96, 0xD8, 0x00, 0xAA, 0x00, 0x51, 0xE5, 0x1D
+DEFINE_GUIDSTRUCT("4682B940-C6EF-11D0-96D8-00AA0051E51D", KSEVENTSETID_LoopedStreaming);
+ # define KSEVENTSETID_LoopedStreaming DEFINE_GUIDNAMED(KSEVENTSETID_LoopedStreaming)
+
+typedef enum
+{
+  KSEVENT_LOOPEDSTREAMING_POSITION
+}KSEVENT_LOOPEDSTREAMING;
+
+typedef struct
+{
+  KSEVENTDATA KsEventData;
+  DWORDLONG Position;
+}LOOPEDSTREAMING_POSITION_EVENT_DATA, * PLOOPEDSTREAMING_POSITION_EVENT_DATA;
+
+ # define STATIC_KSPROPSETID_Sysaudio                 \
+  0xCBE3FAA0L, 0xCC75, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
+DEFINE_GUIDSTRUCT("CBE3FAA0-CC75-11D0-B465-00001A1818E6", KSPROPSETID_Sysaudio);
+ # define KSPROPSETID_Sysaudio DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio)
+
+typedef enum
+{
+  KSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
+  KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME = 2,
+  KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE = 3,
+  KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME = 4,
+  KSPROPERTY_SYSAUDIO_SELECT_GRAPH = 5,
+  KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE = 6,
+  KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT = 7,
+  KSPROPERTY_SYSAUDIO_INSTANCE_INFO = 14,
+  KSPROPERTY_SYSAUDIO_COMPONENT_ID = 16
+}KSPROPERTY_SYSAUDIO;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  GUID PinCategory;
+  GUID PinName;
+}SYSAUDIO_CREATE_VIRTUAL_SOURCE, * PSYSAUDIO_CREATE_VIRTUAL_SOURCE;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG PinId;
+  ULONG NodeId;
+  ULONG Flags;
+  ULONG Reserved;
+}SYSAUDIO_SELECT_GRAPH, * PSYSAUDIO_SELECT_GRAPH;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG Flags;
+  ULONG DeviceNumber;
+}SYSAUDIO_INSTANCE_INFO, * PSYSAUDIO_INSTANCE_INFO;
+
+ # define SYSAUDIO_FLAGS_DONT_COMBINE_PINS 0x00000001
+
+ # define STATIC_KSPROPSETID_Sysaudio_Pin                 \
+  0xA3A53220L, 0xC6E4, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
+DEFINE_GUIDSTRUCT("A3A53220-C6E4-11D0-B465-00001A1818E6", KSPROPSETID_Sysaudio_Pin);
+ # define KSPROPSETID_Sysaudio_Pin DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio_Pin)
+
+typedef enum
+{
+  KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE = 1
+}KSPROPERTY_SYSAUDIO_PIN;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG MixerPinId;
+  ULONG Reserved;
+}SYSAUDIO_ATTACH_VIRTUAL_SOURCE, * PSYSAUDIO_ATTACH_VIRTUAL_SOURCE;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG NodeId;
+  ULONG Reserved;
+}KSNODEPROPERTY, * PKSNODEPROPERTY;
+
+typedef struct
+{
+  KSNODEPROPERTY NodeProperty;
+  LONG Channel;
+  ULONG Reserved;
+}KSNODEPROPERTY_AUDIO_CHANNEL, * PKSNODEPROPERTY_AUDIO_CHANNEL;
+
+typedef struct
+{
+  KSNODEPROPERTY NodeProperty;
+  ULONG DevSpecificId;
+  ULONG DeviceInfo;
+  ULONG Length;
+}KSNODEPROPERTY_AUDIO_DEV_SPECIFIC, * PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC;
+
+typedef struct
+{
+  KSNODEPROPERTY NodeProperty;
+  PVOID ListenerId;
+ # ifndef _WIN64
+  ULONG Reserved;
+ # endif
+}KSNODEPROPERTY_AUDIO_3D_LISTENER, * PKSNODEPROPERTY_AUDIO_3D_LISTENER;
+
+typedef struct
+{
+  KSNODEPROPERTY NodeProperty;
+  PVOID AppContext;
+  ULONG Length;
+ # ifndef _WIN64
+  ULONG Reserved;
+ # endif
+}KSNODEPROPERTY_AUDIO_PROPERTY, * PKSNODEPROPERTY_AUDIO_PROPERTY;
+
+ # define STATIC_KSPROPSETID_AudioGfx                 \
+  0x79a9312eL, 0x59ae, 0x43b0, 0xa3, 0x50, 0x8b, 0x5, 0x28, 0x4c, 0xab, 0x24
+DEFINE_GUIDSTRUCT("79A9312E-59AE-43b0-A350-8B05284CAB24", KSPROPSETID_AudioGfx);
+ # define KSPROPSETID_AudioGfx DEFINE_GUIDNAMED(KSPROPSETID_AudioGfx)
+
+typedef enum
+{
+  KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID,
+  KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID
+}KSPROPERTY_AUDIOGFX;
+
+ # define STATIC_KSPROPSETID_Linear                   \
+  0x5A2FFE80L, 0x16B9, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("5A2FFE80-16B9-11D0-A5D6-28DB04C10000", KSPROPSETID_Linear);
+ # define KSPROPSETID_Linear DEFINE_GUIDNAMED(KSPROPSETID_Linear)
+
+typedef enum
+{
+  KSPROPERTY_LINEAR_POSITION
+}KSPROPERTY_LINEAR;
+
+ # define STATIC_KSDATAFORMAT_TYPE_MUSIC                  \
+  0xE725D360L, 0x62CC, 0x11CF, { 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00 }
+DEFINE_GUIDSTRUCT("E725D360-62CC-11CF-A5D6-28DB04C10000", KSDATAFORMAT_TYPE_MUSIC);
+ # define KSDATAFORMAT_TYPE_MUSIC DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MUSIC)
+
+ # define STATIC_KSDATAFORMAT_TYPE_MIDI                   \
+  0x7364696DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
+DEFINE_GUIDSTRUCT("7364696D-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_MIDI);
+ # define KSDATAFORMAT_TYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MIDI)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_MIDI                \
+  0x1D262760L, 0xE957, 0x11CF, { 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00 }
+DEFINE_GUIDSTRUCT("1D262760-E957-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SUBTYPE_MIDI);
+ # define KSDATAFORMAT_SUBTYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_MIDI_BUS                \
+  0x2CA15FA0L, 0x6CFE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("2CA15FA0-6CFE-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SUBTYPE_MIDI_BUS);
+ # define KSDATAFORMAT_SUBTYPE_MIDI_BUS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI_BUS)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_RIFFMIDI                \
+  0x4995DAF0L, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("4995DAF0-9EE6-11D0-A40E-00A0C9223196", KSDATAFORMAT_SUBTYPE_RIFFMIDI);
+ # define KSDATAFORMAT_SUBTYPE_RIFFMIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFMIDI)
+
+typedef struct
+{
+  ULONG TimeDeltaMs;
+
+  ULONG ByteCount;
+}KSMUSICFORMAT, * PKSMUSICFORMAT;
+
+ # define STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM     \
+  0x36523b11L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B11-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM);
+ # define KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM)
+
+ # define STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET            \
+  0x36523b12L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B12-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_PES_PACKET);
+ # define KSDATAFORMAT_TYPE_STANDARD_PES_PACKET DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PES_PACKET)
+
+ # define STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER           \
+  0x36523b13L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B13-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER);
+ # define KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO        \
+  0x36523b21L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B21-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO);
+ # define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO        \
+  0x36523b22L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B22-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO);
+ # define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO        \
+  0x36523b23L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B23-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO);
+ # define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO        \
+  0x36523b24L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B24-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO);
+ # define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO          \
+  0x36523b25L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B25-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO);
+ # define KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO       \
+  0x36523b31L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B31-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO);
+ # define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO       \
+  0x36523b32L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B32-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO);
+ # define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO       \
+  0x36523b33L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B33-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO);
+ # define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO       \
+  0x36523b34L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B34-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO);
+ # define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO         \
+  0x36523b35L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
+DEFINE_GUIDSTRUCT("36523B35-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO);
+ # define KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_DSS_VIDEO               \
+  0xa0af4f81L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
+DEFINE_GUIDSTRUCT("a0af4f81-e163-11d0-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_DSS_VIDEO);
+ # define KSDATAFORMAT_SUBTYPE_DSS_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_VIDEO)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_DSS_AUDIO               \
+  0xa0af4f82L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
+DEFINE_GUIDSTRUCT("a0af4f82-e163-11d0-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_DSS_AUDIO);
+ # define KSDATAFORMAT_SUBTYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Packet             \
+  0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
+DEFINE_GUIDSTRUCT("e436eb80-524f-11ce-9F53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Packet);
+ # define KSDATAFORMAT_SUBTYPE_MPEG1Packet DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Packet)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Payload            \
+  0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
+DEFINE_GUIDSTRUCT("e436eb81-524f-11ce-9F53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Payload);
+ # define KSDATAFORMAT_SUBTYPE_MPEG1Payload DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Payload)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Video              \
+  0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
+DEFINE_GUIDSTRUCT("e436eb86-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Video);
+ # define KSDATAFORMAT_SUBTYPE_MPEG1Video DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Video)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO           \
+  0x05589f82L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
+DEFINE_GUIDSTRUCT("05589f82-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO);
+ # define KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO)
+
+ # define STATIC_KSDATAFORMAT_TYPE_MPEG2_PES              \
+  0xe06d8020L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d8020-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_PES);
+ # define KSDATAFORMAT_TYPE_MPEG2_PES DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PES)
+
+ # define STATIC_KSDATAFORMAT_TYPE_MPEG2_PROGRAM              \
+  0xe06d8022L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d8022-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_PROGRAM);
+ # define KSDATAFORMAT_TYPE_MPEG2_PROGRAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PROGRAM)
+
+ # define STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT            \
+  0xe06d8023L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d8023-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_TRANSPORT);
+ # define KSDATAFORMAT_TYPE_MPEG2_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_TRANSPORT)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO             \
+  0xe06d8026L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d8026-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO);
+ # define KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO           \
+  0xe06d80e3L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d80e3-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO);
+ # define KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO)
+
+ # define STATIC_KSPROPSETID_Mpeg2Vid                 \
+  0xC8E11B60L, 0x0CC9, 0x11D0, 0xBD, 0x69, 0x00, 0x35, 0x05, 0xC1, 0x03, 0xA9
+DEFINE_GUIDSTRUCT("C8E11B60-0CC9-11D0-BD69-003505C103A9", KSPROPSETID_Mpeg2Vid);
+ # define KSPROPSETID_Mpeg2Vid DEFINE_GUIDNAMED(KSPROPSETID_Mpeg2Vid)
+
+typedef enum
+{
+  KSPROPERTY_MPEG2VID_MODES,
+  KSPROPERTY_MPEG2VID_CUR_MODE,
+  KSPROPERTY_MPEG2VID_4_3_RECT,
+  KSPROPERTY_MPEG2VID_16_9_RECT,
+  KSPROPERTY_MPEG2VID_16_9_PANSCAN
+}KSPROPERTY_MPEG2VID;
+
+ # define KSMPEGVIDMODE_PANSCAN 0x0001
+ # define KSMPEGVIDMODE_LTRBOX 0x0002
+ # define KSMPEGVIDMODE_SCALE 0x0004
+
+typedef struct _KSMPEGVID_RECT
+{
+  ULONG StartX;
+  ULONG StartY;
+  ULONG EndX;
+  ULONG EndY;
+}KSMPEGVID_RECT, * PKSMPEGVID_RECT;
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO             \
+  0xe06d802bL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d802b-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO);
+ # define KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO           \
+  0xe06d80e5L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d80e5-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO);
+ # define KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_LPCM_AUDIO              \
+  0xe06d8032L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d8032-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_LPCM_AUDIO);
+ # define KSDATAFORMAT_SUBTYPE_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_LPCM_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_LPCM_AUDIO            \
+  0xe06d80e6L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d80e6-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_LPCM_AUDIO);
+ # define KSDATAFORMAT_SPECIFIER_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_LPCM_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_AC3_AUDIO               \
+  0xe06d802cL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d802c-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_AC3_AUDIO);
+ # define KSDATAFORMAT_SUBTYPE_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_AC3_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_AC3_AUDIO             \
+  0xe06d80e4L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d80e4-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_AC3_AUDIO);
+ # define KSDATAFORMAT_SPECIFIER_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_AC3_AUDIO)
+
+ # define STATIC_KSPROPSETID_AC3                      \
+  0xBFABE720L, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
+DEFINE_GUIDSTRUCT("BFABE720-6E1F-11D0-BCF2-444553540000", KSPROPSETID_AC3);
+ # define KSPROPSETID_AC3 DEFINE_GUIDNAMED(KSPROPSETID_AC3)
+
+typedef enum
+{
+  KSPROPERTY_AC3_ERROR_CONCEALMENT = 1,
+  KSPROPERTY_AC3_ALTERNATE_AUDIO,
+  KSPROPERTY_AC3_DOWNMIX,
+  KSPROPERTY_AC3_BIT_STREAM_MODE,
+  KSPROPERTY_AC3_DIALOGUE_LEVEL,
+  KSPROPERTY_AC3_LANGUAGE_CODE,
+  KSPROPERTY_AC3_ROOM_TYPE
+}KSPROPERTY_AC3;
+
+typedef struct
+{
+  WINBOOL fRepeatPreviousBlock;
+  WINBOOL fErrorInCurrentBlock;
+}KSAC3_ERROR_CONCEALMENT, * PKSAC3_ERROR_CONCEALMENT;
+
+typedef struct
+{
+  WINBOOL fStereo;
+  ULONG DualMode;
+}KSAC3_ALTERNATE_AUDIO, * PKSAC3_ALTERNATE_AUDIO;
+
+ # define KSAC3_ALTERNATE_AUDIO_1 1
+ # define KSAC3_ALTERNATE_AUDIO_2 2
+ # define KSAC3_ALTERNATE_AUDIO_BOTH 3
+
+typedef struct
+{
+  WINBOOL fDownMix;
+  WINBOOL fDolbySurround;
+}KSAC3_DOWNMIX, * PKSAC3_DOWNMIX;
+
+typedef struct
+{
+  LONG BitStreamMode;
+}KSAC3_BIT_STREAM_MODE, * PKSAC3_BIT_STREAM_MODE;
+
+ # define KSAC3_SERVICE_MAIN_AUDIO 0
+ # define KSAC3_SERVICE_NO_DIALOG 1
+ # define KSAC3_SERVICE_VISUALLY_IMPAIRED 2
+ # define KSAC3_SERVICE_HEARING_IMPAIRED 3
+ # define KSAC3_SERVICE_DIALOG_ONLY 4
+ # define KSAC3_SERVICE_COMMENTARY 5
+ # define KSAC3_SERVICE_EMERGENCY_FLASH 6
+ # define KSAC3_SERVICE_VOICE_OVER 7
+
+typedef struct
+{
+  ULONG DialogueLevel;
+}KSAC3_DIALOGUE_LEVEL, * PKSAC3_DIALOGUE_LEVEL;
+
+typedef struct
+{
+  WINBOOL fLargeRoom;
+}KSAC3_ROOM_TYPE, * PKSAC3_ROOM_TYPE;
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_DTS_AUDIO               \
+  0xe06d8033L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d8033-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_DTS_AUDIO);
+ # define KSDATAFORMAT_SUBTYPE_DTS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DTS_AUDIO)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_SDDS_AUDIO              \
+  0xe06d8034L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d8034-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_SDDS_AUDIO);
+ # define KSDATAFORMAT_SUBTYPE_SDDS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SDDS_AUDIO)
+
+ # define STATIC_KSPROPSETID_AudioDecoderOut              \
+  0x6ca6e020L, 0x43bd, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
+DEFINE_GUIDSTRUCT("6ca6e020-43bd-11d0-bd6a-003505c103a9", KSPROPSETID_AudioDecoderOut);
+ # define KSPROPSETID_AudioDecoderOut DEFINE_GUIDNAMED(KSPROPSETID_AudioDecoderOut)
+
+typedef enum
+{
+  KSPROPERTY_AUDDECOUT_MODES,
+  KSPROPERTY_AUDDECOUT_CUR_MODE
+}KSPROPERTY_AUDDECOUT;
+
+ # define KSAUDDECOUTMODE_STEREO_ANALOG 0x0001
+ # define KSAUDDECOUTMODE_PCM_51 0x0002
+ # define KSAUDDECOUTMODE_SPDIFF 0x0004
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_SUBPICTURE              \
+  0xe06d802dL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
+DEFINE_GUIDSTRUCT("e06d802d-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_SUBPICTURE);
+ # define KSDATAFORMAT_SUBTYPE_SUBPICTURE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SUBPICTURE)
+
+ # define STATIC_KSPROPSETID_DvdSubPic                    \
+  0xac390460L, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
+DEFINE_GUIDSTRUCT("ac390460-43af-11d0-bd6a-003505c103a9", KSPROPSETID_DvdSubPic);
+ # define KSPROPSETID_DvdSubPic DEFINE_GUIDNAMED(KSPROPSETID_DvdSubPic)
+
+typedef enum
+{
+  KSPROPERTY_DVDSUBPIC_PALETTE,
+  KSPROPERTY_DVDSUBPIC_HLI,
+  KSPROPERTY_DVDSUBPIC_COMPOSIT_ON
+}KSPROPERTY_DVDSUBPIC;
+
+typedef struct _KS_DVD_YCrCb
+{
+  UCHAR Reserved;
+  UCHAR Y;
+  UCHAR Cr;
+  UCHAR Cb;
+}KS_DVD_YCrCb, * PKS_DVD_YCrCb;
+
+typedef struct _KS_DVD_YUV
+{
+  UCHAR Reserved;
+  UCHAR Y;
+  UCHAR V;
+  UCHAR U;
+}KS_DVD_YUV, * PKS_DVD_YUV;
+
+typedef struct _KSPROPERTY_SPPAL
+{
+  KS_DVD_YUV sppal[16];
+}KSPROPERTY_SPPAL, * PKSPROPERTY_SPPAL;
+
+typedef struct _KS_COLCON
+{
+  UCHAR emph1col : 4;
+  UCHAR emph2col : 4;
+  UCHAR backcol : 4;
+  UCHAR patcol : 4;
+  UCHAR emph1con : 4;
+  UCHAR emph2con : 4;
+  UCHAR backcon : 4;
+  UCHAR patcon : 4;
+}KS_COLCON, * PKS_COLCON;
+
+typedef struct _KSPROPERTY_SPHLI
+{
+  USHORT HLISS;
+  USHORT Reserved;
+  ULONG StartPTM;
+  ULONG EndPTM;
+  USHORT StartX;
+  USHORT StartY;
+  USHORT StopX;
+  USHORT StopY;
+  KS_COLCON ColCon;
+}KSPROPERTY_SPHLI, * PKSPROPERTY_SPHLI;
+
+typedef WINBOOL KSPROPERTY_COMPOSIT_ON, * PKSPROPERTY_COMPOSIT_ON;
+
+ # define STATIC_KSPROPSETID_CopyProt                 \
+  0x0E8A0A40L, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3
+DEFINE_GUIDSTRUCT("0E8A0A40-6AEF-11D0-9ED0-00A024CA19B3", KSPROPSETID_CopyProt);
+ # define KSPROPSETID_CopyProt DEFINE_GUIDNAMED(KSPROPSETID_CopyProt)
+
+typedef enum
+{
+  KSPROPERTY_DVDCOPY_CHLG_KEY = 0x01,
+  KSPROPERTY_DVDCOPY_DVD_KEY1,
+  KSPROPERTY_DVDCOPY_DEC_KEY2,
+  KSPROPERTY_DVDCOPY_TITLE_KEY,
+  KSPROPERTY_COPY_MACROVISION,
+  KSPROPERTY_DVDCOPY_REGION,
+  KSPROPERTY_DVDCOPY_SET_COPY_STATE,
+  KSPROPERTY_DVDCOPY_DISC_KEY = 0x80
+}KSPROPERTY_COPYPROT;
+
+typedef struct _KS_DVDCOPY_CHLGKEY
+{
+  BYTE ChlgKey[10];
+  BYTE Reserved[2];
+}KS_DVDCOPY_CHLGKEY, * PKS_DVDCOPY_CHLGKEY;
+
+typedef struct _KS_DVDCOPY_BUSKEY
+{
+  BYTE BusKey[5];
+  BYTE Reserved[1];
+}KS_DVDCOPY_BUSKEY, * PKS_DVDCOPY_BUSKEY;
+
+typedef struct _KS_DVDCOPY_DISCKEY
+{
+  BYTE DiscKey[2048];
+}KS_DVDCOPY_DISCKEY, * PKS_DVDCOPY_DISCKEY;
+
+typedef struct _KS_DVDCOPY_REGION
+{
+  UCHAR Reserved;
+  UCHAR RegionData;
+  UCHAR Reserved2[2];
+}KS_DVDCOPY_REGION, * PKS_DVDCOPY_REGION;
+
+typedef struct _KS_DVDCOPY_TITLEKEY
+{
+  ULONG KeyFlags;
+  ULONG ReservedNT[2];
+  UCHAR TitleKey[6];
+  UCHAR Reserved[2];
+}KS_DVDCOPY_TITLEKEY, * PKS_DVDCOPY_TITLEKEY;
+
+typedef struct _KS_COPY_MACROVISION
+{
+  ULONG MACROVISIONLevel;
+}KS_COPY_MACROVISION, * PKS_COPY_MACROVISION;
+
+typedef struct _KS_DVDCOPY_SET_COPY_STATE
+{
+  ULONG DVDCopyState;
+}KS_DVDCOPY_SET_COPY_STATE, * PKS_DVDCOPY_SET_COPY_STATE;
+
+typedef enum
+{
+  KS_DVDCOPYSTATE_INITIALIZE,
+  KS_DVDCOPYSTATE_INITIALIZE_TITLE,
+  KS_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED,
+  KS_DVDCOPYSTATE_AUTHENTICATION_REQUIRED,
+  KS_DVDCOPYSTATE_DONE
+}KS_DVDCOPYSTATE;
+
+typedef enum
+{
+  KS_MACROVISION_DISABLED,
+  KS_MACROVISION_LEVEL1,
+  KS_MACROVISION_LEVEL2,
+  KS_MACROVISION_LEVEL3
+}KS_COPY_MACROVISION_LEVEL, * PKS_COPY_MACROVISION_LEVEL;
+
+ # define KS_DVD_CGMS_RESERVED_MASK 0x00000078
+
+ # define KS_DVD_CGMS_COPY_PROTECT_MASK 0x00000018
+ # define KS_DVD_CGMS_COPY_PERMITTED 0x00000000
+ # define KS_DVD_CGMS_COPY_ONCE 0x00000010
+ # define KS_DVD_CGMS_NO_COPY 0x00000018
+
+ # define KS_DVD_COPYRIGHT_MASK 0x00000040
+ # define KS_DVD_NOT_COPYRIGHTED 0x00000000
+ # define KS_DVD_COPYRIGHTED 0x00000040
+
+ # define KS_DVD_SECTOR_PROTECT_MASK 0x00000020
+ # define KS_DVD_SECTOR_NOT_PROTECTED 0x00000000
+ # define KS_DVD_SECTOR_PROTECTED 0x00000020
+
+ # define STATIC_KSCATEGORY_TVTUNER                   \
+  0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
+DEFINE_GUIDSTRUCT("a799a800-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_TVTUNER);
+ # define KSCATEGORY_TVTUNER DEFINE_GUIDNAMED(KSCATEGORY_TVTUNER)
+
+ # define STATIC_KSCATEGORY_CROSSBAR                  \
+  0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
+DEFINE_GUIDSTRUCT("a799a801-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_CROSSBAR);
+ # define KSCATEGORY_CROSSBAR DEFINE_GUIDNAMED(KSCATEGORY_CROSSBAR)
+
+ # define STATIC_KSCATEGORY_TVAUDIO                   \
+  0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
+DEFINE_GUIDSTRUCT("a799a802-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_TVAUDIO);
+ # define KSCATEGORY_TVAUDIO DEFINE_GUIDNAMED(KSCATEGORY_TVAUDIO)
+
+ # define STATIC_KSCATEGORY_VPMUX                     \
+  0xa799a803L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
+DEFINE_GUIDSTRUCT("a799a803-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_VPMUX);
+ # define KSCATEGORY_VPMUX DEFINE_GUIDNAMED(KSCATEGORY_VPMUX)
+
+ # define STATIC_KSCATEGORY_VBICODEC                  \
+  0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
+DEFINE_GUIDSTRUCT("07dad660-22f1-11d1-a9f4-00c04fbbde8f", KSCATEGORY_VBICODEC);
+ # define KSCATEGORY_VBICODEC DEFINE_GUIDNAMED(KSCATEGORY_VBICODEC)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_VPVideo             \
+  0x5a9b6a40L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
+DEFINE_GUIDSTRUCT("5a9b6a40-1a22-11d1-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_VPVideo);
+ # define KSDATAFORMAT_SUBTYPE_VPVideo DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVideo)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_VPVBI               \
+  0x5a9b6a41L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
+DEFINE_GUIDSTRUCT("5a9b6a41-1a22-11d1-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_VPVBI);
+ # define KSDATAFORMAT_SUBTYPE_VPVBI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVBI)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO             \
+  0x05589f80L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
+DEFINE_GUIDSTRUCT("05589f80-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_VIDEOINFO);
+ # define KSDATAFORMAT_SPECIFIER_VIDEOINFO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2            \
+  0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("f72a76A0-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SPECIFIER_VIDEOINFO2);
+ # define KSDATAFORMAT_SPECIFIER_VIDEOINFO2 DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO2)
+
+ # define STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO                \
+  0x0482dde1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
+DEFINE_GUIDSTRUCT("0482dde1-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_TYPE_ANALOGVIDEO);
+ # define KSDATAFORMAT_TYPE_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_ANALOGVIDEO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO           \
+  0x0482dde0L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
+DEFINE_GUIDSTRUCT("0482dde0-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_SPECIFIER_ANALOGVIDEO);
+ # define KSDATAFORMAT_SPECIFIER_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)
+
+ # define STATIC_KSDATAFORMAT_TYPE_ANALOGAUDIO                \
+  0x0482dee1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
+DEFINE_GUIDSTRUCT("0482DEE1-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_TYPE_ANALOGAUDIO);
+ # define KSDATAFORMAT_TYPE_ANALOGAUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_ANALOGAUDIO)
+
+ # define STATIC_KSDATAFORMAT_SPECIFIER_VBI               \
+  0xf72a76e0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("f72a76e0-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SPECIFIER_VBI);
+ # define KSDATAFORMAT_SPECIFIER_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VBI)
+
+ # define STATIC_KSDATAFORMAT_TYPE_VBI                    \
+  0xf72a76e1L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("f72a76e1-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_TYPE_VBI);
+ # define KSDATAFORMAT_TYPE_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VBI)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_RAW8                \
+  0xca20d9a0, 0x3e3e, 0x11d1, 0x9b, 0xf9, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0xbf
+DEFINE_GUIDSTRUCT("ca20d9a0-3e3e-11d1-9bf9-00c04fbbdebf", KSDATAFORMAT_SUBTYPE_RAW8);
+ # define KSDATAFORMAT_SUBTYPE_RAW8 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RAW8)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_CC                  \
+  0x33214cc1, 0x11f, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
+DEFINE_GUIDSTRUCT("33214CC1-011F-11D2-B4B1-00A0D102CFBE", KSDATAFORMAT_SUBTYPE_CC);
+ # define KSDATAFORMAT_SUBTYPE_CC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_CC)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_NABTS               \
+  0xf72a76e2L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("f72a76e2-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SUBTYPE_NABTS);
+ # define KSDATAFORMAT_SUBTYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_TELETEXT                \
+  0xf72a76e3L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("f72a76e3-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SUBTYPE_TELETEXT);
+ # define KSDATAFORMAT_SUBTYPE_TELETEXT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_TELETEXT)
+
+ # define KS_BI_RGB 0L
+ # define KS_BI_RLE8 1L
+ # define KS_BI_RLE4 2L
+ # define KS_BI_BITFIELDS 3L
+
+typedef struct tagKS_RGBQUAD
+{
+  BYTE rgbBlue;
+  BYTE rgbGreen;
+  BYTE rgbRed;
+  BYTE rgbReserved;
+}KS_RGBQUAD, * PKS_RGBQUAD;
+
+ # define KS_iPALETTE_COLORS 256
+ # define KS_iEGA_COLORS 16
+ # define KS_iMASK_COLORS 3
+ # define KS_iTRUECOLOR 16
+ # define KS_iRED 0
+ # define KS_iGREEN 1
+ # define KS_iBLUE 2
+ # define KS_iPALETTE 8
+ # define KS_iMAXBITS 8
+ # define KS_SIZE_EGA_PALETTE (KS_iEGA_COLORS * sizeof(KS_RGBQUAD))
+ # define KS_SIZE_PALETTE (KS_iPALETTE_COLORS * sizeof(KS_RGBQUAD))
+
+typedef struct tagKS_BITMAPINFOHEADER
+{
+  DWORD biSize;
+  LONG biWidth;
+  LONG biHeight;
+  WORD biPlanes;
+  WORD biBitCount;
+  DWORD biCompression;
+  DWORD biSizeImage;
+  LONG biXPelsPerMeter;
+  LONG biYPelsPerMeter;
+  DWORD biClrUsed;
+  DWORD biClrImportant;
+}KS_BITMAPINFOHEADER, * PKS_BITMAPINFOHEADER;
+
+typedef struct tag_KS_TRUECOLORINFO
+{
+  DWORD dwBitMasks[KS_iMASK_COLORS];
+  KS_RGBQUAD bmiColors[KS_iPALETTE_COLORS];
+}KS_TRUECOLORINFO, * PKS_TRUECOLORINFO;
+
+ # define KS_WIDTHBYTES(bits) ((DWORD)(((bits) + 31) & (~31)) / 8)
+ # define KS_DIBWIDTHBYTES(bi) (DWORD)KS_WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
+ # define KS__DIBSIZE(bi) (KS_DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
+ # define KS_DIBSIZE(bi) ((bi).biHeight < 0 ? (-1) * (KS__DIBSIZE(bi)) : KS__DIBSIZE(bi))
+
+typedef LONGLONG REFERENCE_TIME;
+
+typedef struct tagKS_VIDEOINFOHEADER
+{
+  RECT rcSource;
+  RECT rcTarget;
+  DWORD dwBitRate;
+  DWORD dwBitErrorRate;
+  REFERENCE_TIME AvgTimePerFrame;
+  KS_BITMAPINFOHEADER bmiHeader;
+}KS_VIDEOINFOHEADER, * PKS_VIDEOINFOHEADER;
+
+typedef struct tagKS_VIDEOINFO
+{
+  RECT rcSource;
+  RECT rcTarget;
+  DWORD dwBitRate;
+  DWORD dwBitErrorRate;
+  REFERENCE_TIME AvgTimePerFrame;
+  KS_BITMAPINFOHEADER bmiHeader;
+  __MINGW_EXTENSION union
+  {
+    KS_RGBQUAD bmiColors[KS_iPALETTE_COLORS];
+    DWORD dwBitMasks[KS_iMASK_COLORS];
+    KS_TRUECOLORINFO TrueColorInfo;
+  };
+}KS_VIDEOINFO, * PKS_VIDEOINFO;
+
+ # define KS_SIZE_MASKS (KS_iMASK_COLORS * sizeof(DWORD))
+ # define KS_SIZE_PREHEADER (FIELD_OFFSET(KS_VIDEOINFOHEADER, bmiHeader))
+
+ # define KS_SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + KS_SIZE_PREHEADER)
+
+typedef struct tagKS_VBIINFOHEADER
+{
+  ULONG StartLine;
+  ULONG EndLine;
+  ULONG SamplingFrequency;
+  ULONG MinLineStartTime;
+  ULONG MaxLineStartTime;
+  ULONG ActualLineStartTime;
+  ULONG ActualLineEndTime;
+  ULONG VideoStandard;
+  ULONG SamplesPerLine;
+  ULONG StrideInBytes;
+  ULONG BufferSize;
+}KS_VBIINFOHEADER, * PKS_VBIINFOHEADER;
+
+ # define KS_VBIDATARATE_NABTS (5727272L)
+ # define KS_VBIDATARATE_CC (503493L)
+ # define KS_VBISAMPLINGRATE_4X_NABTS ((long)(4 * KS_VBIDATARATE_NABTS))
+ # define KS_VBISAMPLINGRATE_47X_NABTS ((long)(27000000))
+ # define KS_VBISAMPLINGRATE_5X_NABTS ((long)(5 * KS_VBIDATARATE_NABTS))
+
+ # define KS_47NABTS_SCALER (KS_VBISAMPLINGRATE_47X_NABTS / (double)KS_VBIDATARATE_NABTS)
+
+typedef struct tagKS_AnalogVideoInfo
+{
+  RECT rcSource;
+  RECT rcTarget;
+  DWORD dwActiveWidth;
+  DWORD dwActiveHeight;
+  REFERENCE_TIME AvgTimePerFrame;
+}KS_ANALOGVIDEOINFO, * PKS_ANALOGVIDEOINFO;
+
+ # define KS_TVTUNER_CHANGE_BEGIN_TUNE 0x0001L
+ # define KS_TVTUNER_CHANGE_END_TUNE 0x0002L
+
+typedef struct tagKS_TVTUNER_CHANGE_INFO
+{
+  DWORD dwFlags;
+  DWORD dwCountryCode;
+  DWORD dwAnalogVideoStandard;
+  DWORD dwChannel;
+}KS_TVTUNER_CHANGE_INFO, * PKS_TVTUNER_CHANGE_INFO;
+
+typedef enum
+{
+  KS_MPEG2Level_Low,
+  KS_MPEG2Level_Main,
+  KS_MPEG2Level_High1440,
+  KS_MPEG2Level_High
+}KS_MPEG2Level;
+
+typedef enum
+{
+  KS_MPEG2Profile_Simple,
+  KS_MPEG2Profile_Main,
+  KS_MPEG2Profile_SNRScalable,
+  KS_MPEG2Profile_SpatiallyScalable,
+  KS_MPEG2Profile_High
+}KS_MPEG2Profile;
+
+ # define KS_INTERLACE_IsInterlaced 0x00000001
+ # define KS_INTERLACE_1FieldPerSample 0x00000002
+ # define KS_INTERLACE_Field1First 0x00000004
+ # define KS_INTERLACE_UNUSED 0x00000008
+ # define KS_INTERLACE_FieldPatternMask 0x00000030
+ # define KS_INTERLACE_FieldPatField1Only 0x00000000
+ # define KS_INTERLACE_FieldPatField2Only 0x00000010
+ # define KS_INTERLACE_FieldPatBothRegular 0x00000020
+ # define KS_INTERLACE_FieldPatBothIrregular 0x00000030
+ # define KS_INTERLACE_DisplayModeMask 0x000000c0
+ # define KS_INTERLACE_DisplayModeBobOnly 0x00000000
+ # define KS_INTERLACE_DisplayModeWeaveOnly 0x00000040
+ # define KS_INTERLACE_DisplayModeBobOrWeave 0x00000080
+
+ # define KS_MPEG2_DoPanScan 0x00000001
+ # define KS_MPEG2_DVDLine21Field1 0x00000002
+ # define KS_MPEG2_DVDLine21Field2 0x00000004
+ # define KS_MPEG2_SourceIsLetterboxed 0x00000008
+ # define KS_MPEG2_FilmCameraMode 0x00000010
+ # define KS_MPEG2_LetterboxAnalogOut 0x00000020
+ # define KS_MPEG2_DSS_UserData 0x00000040
+ # define KS_MPEG2_DVB_UserData 0x00000080
+ # define KS_MPEG2_27MhzTimebase 0x00000100
+
+typedef struct tagKS_VIDEOINFOHEADER2
+{
+  RECT rcSource;
+  RECT rcTarget;
+  DWORD dwBitRate;
+  DWORD dwBitErrorRate;
+  REFERENCE_TIME AvgTimePerFrame;
+  DWORD dwInterlaceFlags;
+  DWORD dwCopyProtectFlags;
+  DWORD dwPictAspectRatioX;
+  DWORD dwPictAspectRatioY;
+  DWORD dwReserved1;
+  DWORD dwReserved2;
+  KS_BITMAPINFOHEADER bmiHeader;
+}KS_VIDEOINFOHEADER2, * PKS_VIDEOINFOHEADER2;
+
+typedef struct tagKS_MPEG1VIDEOINFO
+{
+  KS_VIDEOINFOHEADER hdr;
+  DWORD dwStartTimeCode;
+  DWORD cbSequenceHeader;
+  BYTE bSequenceHeader[1];
+}KS_MPEG1VIDEOINFO, * PKS_MPEG1VIDEOINFO;
+
+ # define KS_MAX_SIZE_MPEG1_SEQUENCE_INFO 140
+ # define KS_SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(KS_MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
+ # define KS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE*)(pv)->bSequenceHeader)
+
+typedef struct tagKS_MPEGVIDEOINFO2
+{
+  KS_VIDEOINFOHEADER2 hdr;
+  DWORD dwStartTimeCode;
+  DWORD cbSequenceHeader;
+  DWORD dwProfile;
+  DWORD dwLevel;
+  DWORD dwFlags;
+  DWORD bSequenceHeader[1];
+}KS_MPEGVIDEOINFO2, * PKS_MPEGVIDEOINFO2;
+
+ # define KS_SIZE_MPEGVIDEOINFO2(pv) (FIELD_OFFSET(KS_MPEGVIDEOINFO2, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
+ # define KS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE*)(pv)->bSequenceHeader)
+
+ # define KS_MPEGAUDIOINFO_27MhzTimebase 0x00000001
+
+typedef struct tagKS_MPEAUDIOINFO
+{
+  DWORD dwFlags;
+  DWORD dwReserved1;
+  DWORD dwReserved2;
+  DWORD dwReserved3;
+}KS_MPEGAUDIOINFO, * PKS_MPEGAUDIOINFO;
+
+typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER
+{
+  KSDATAFORMAT DataFormat;
+  KS_VIDEOINFOHEADER VideoInfoHeader;
+}KS_DATAFORMAT_VIDEOINFOHEADER, * PKS_DATAFORMAT_VIDEOINFOHEADER;
+
+typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER2
+{
+  KSDATAFORMAT DataFormat;
+  KS_VIDEOINFOHEADER2 VideoInfoHeader2;
+}KS_DATAFORMAT_VIDEOINFOHEADER2, * PKS_DATAFORMAT_VIDEOINFOHEADER2;
+
+typedef struct tagKS_DATAFORMAT_VIDEOINFO_PALETTE
+{
+  KSDATAFORMAT DataFormat;
+  KS_VIDEOINFO VideoInfo;
+}KS_DATAFORMAT_VIDEOINFO_PALETTE, * PKS_DATAFORMAT_VIDEOINFO_PALETTE;
+
+typedef struct tagKS_DATAFORMAT_VBIINFOHEADER
+{
+  KSDATAFORMAT DataFormat;
+  KS_VBIINFOHEADER VBIInfoHeader;
+}KS_DATAFORMAT_VBIINFOHEADER, * PKS_DATAFORMAT_VBIINFOHEADER;
+
+typedef struct _KS_VIDEO_STREAM_CONFIG_CAPS
+{
+  GUID guid;
+  ULONG VideoStandard;
+  SIZE InputSize;
+  SIZE MinCroppingSize;
+  SIZE MaxCroppingSize;
+  int CropGranularityX;
+  int CropGranularityY;
+  int CropAlignX;
+  int CropAlignY;
+  SIZE MinOutputSize;
+  SIZE MaxOutputSize;
+  int OutputGranularityX;
+  int OutputGranularityY;
+  int StretchTapsX;
+  int StretchTapsY;
+  int ShrinkTapsX;
+  int ShrinkTapsY;
+  LONGLONG MinFrameInterval;
+  LONGLONG MaxFrameInterval;
+  LONG MinBitsPerSecond;
+  LONG MaxBitsPerSecond;
+}KS_VIDEO_STREAM_CONFIG_CAPS, * PKS_VIDEO_STREAM_CONFIG_CAPS;
+
+typedef struct tagKS_DATARANGE_VIDEO
+{
+  KSDATARANGE DataRange;
+  WINBOOL bFixedSizeSamples;
+  WINBOOL bTemporalCompression;
+  DWORD StreamDescriptionFlags;
+  DWORD MemoryAllocationFlags;
+  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
+  KS_VIDEOINFOHEADER VideoInfoHeader;
+}KS_DATARANGE_VIDEO, * PKS_DATARANGE_VIDEO;
+
+typedef struct tagKS_DATARANGE_VIDEO2
+{
+  KSDATARANGE DataRange;
+  WINBOOL bFixedSizeSamples;
+  WINBOOL bTemporalCompression;
+  DWORD StreamDescriptionFlags;
+  DWORD MemoryAllocationFlags;
+  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
+  KS_VIDEOINFOHEADER2 VideoInfoHeader;
+}KS_DATARANGE_VIDEO2, * PKS_DATARANGE_VIDEO2;
+
+typedef struct tagKS_DATARANGE_MPEG1_VIDEO
+{
+  KSDATARANGE DataRange;
+  WINBOOL bFixedSizeSamples;
+  WINBOOL bTemporalCompression;
+  DWORD StreamDescriptionFlags;
+  DWORD MemoryAllocationFlags;
+  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
+  KS_MPEG1VIDEOINFO VideoInfoHeader;
+}KS_DATARANGE_MPEG1_VIDEO, * PKS_DATARANGE_MPEG1_VIDEO;
+
+typedef struct tagKS_DATARANGE_MPEG2_VIDEO
+{
+  KSDATARANGE DataRange;
+  WINBOOL bFixedSizeSamples;
+  WINBOOL bTemporalCompression;
+  DWORD StreamDescriptionFlags;
+  DWORD MemoryAllocationFlags;
+  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
+  KS_MPEGVIDEOINFO2 VideoInfoHeader;
+}KS_DATARANGE_MPEG2_VIDEO, * PKS_DATARANGE_MPEG2_VIDEO;
+
+typedef struct tagKS_DATARANGE_VIDEO_PALETTE
+{
+  KSDATARANGE DataRange;
+  WINBOOL bFixedSizeSamples;
+  WINBOOL bTemporalCompression;
+  DWORD StreamDescriptionFlags;
+  DWORD MemoryAllocationFlags;
+  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
+  KS_VIDEOINFO VideoInfo;
+}KS_DATARANGE_VIDEO_PALETTE, * PKS_DATARANGE_VIDEO_PALETTE;
+
+typedef struct tagKS_DATARANGE_VIDEO_VBI
+{
+  KSDATARANGE DataRange;
+  WINBOOL bFixedSizeSamples;
+  WINBOOL bTemporalCompression;
+  DWORD StreamDescriptionFlags;
+  DWORD MemoryAllocationFlags;
+  KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
+  KS_VBIINFOHEADER VBIInfoHeader;
+}KS_DATARANGE_VIDEO_VBI, * PKS_DATARANGE_VIDEO_VBI;
+
+typedef struct tagKS_DATARANGE_ANALOGVIDEO
+{
+  KSDATARANGE DataRange;
+  KS_ANALOGVIDEOINFO AnalogVideoInfo;
+}KS_DATARANGE_ANALOGVIDEO, * PKS_DATARANGE_ANALOGVIDEO;
+
+ # define KS_VIDEOSTREAM_PREVIEW 0x0001
+ # define KS_VIDEOSTREAM_CAPTURE 0x0002
+ # define KS_VIDEOSTREAM_VBI 0x0010
+ # define KS_VIDEOSTREAM_NABTS 0x0020
+ # define KS_VIDEOSTREAM_CC 0x0100
+ # define KS_VIDEOSTREAM_EDS 0x0200
+ # define KS_VIDEOSTREAM_TELETEXT 0x0400
+ # define KS_VIDEOSTREAM_STILL 0x1000
+ # define KS_VIDEOSTREAM_IS_VPE 0x8000
+
+ # define KS_VIDEO_ALLOC_VPE_SYSTEM 0x0001
+ # define KS_VIDEO_ALLOC_VPE_DISPLAY 0x0002
+ # define KS_VIDEO_ALLOC_VPE_AGP 0x0004
+
+ # define STATIC_KSPROPSETID_VBICAP_PROPERTIES                \
+  0xf162c607, 0x7b35, 0x496f, 0xad, 0x7f, 0x2d, 0xca, 0x3b, 0x46, 0xb7, 0x18
+DEFINE_GUIDSTRUCT("F162C607-7B35-496f-AD7F-2DCA3B46B718", KSPROPSETID_VBICAP_PROPERTIES);
+ # define KSPROPSETID_VBICAP_PROPERTIES DEFINE_GUIDNAMED(KSPROPSETID_VBICAP_PROPERTIES)
+
+typedef enum
+{
+  KSPROPERTY_VBICAP_PROPERTIES_PROTECTION = 0x01
+}KSPROPERTY_VBICAP;
+
+typedef struct _VBICAP_PROPERTIES_PROTECTION_S
+{
+  KSPROPERTY Property;
+  ULONG StreamIndex;
+  ULONG Status;
+}VBICAP_PROPERTIES_PROTECTION_S, * PVBICAP_PROPERTIES_PROTECTION_S;
+
+ # define KS_VBICAP_PROTECTION_MV_PRESENT 0x0001L
+ # define KS_VBICAP_PROTECTION_MV_HARDWARE 0x0002L
+ # define KS_VBICAP_PROTECTION_MV_DETECTED 0x0004L
+
+ # define KS_NABTS_GROUPID_ORIGINAL_CONTENT_BASE 0x800
+ # define KS_NABTS_GROUPID_ORIGINAL_CONTENT_ADVERTISER_BASE 0x810
+
+ # define KS_NABTS_GROUPID_PRODUCTION_COMPANY_CONTENT_BASE 0x820
+ # define KS_NABTS_GROUPID_PRODUCTION_COMPANY_ADVERTISER_BASE 0x830
+
+ # define KS_NABTS_GROUPID_SYNDICATED_SHOW_CONTENT_BASE 0x840
+ # define KS_NABTS_GROUPID_SYNDICATED_SHOW_ADVERTISER_BASE 0x850
+
+ # define KS_NABTS_GROUPID_NETWORK_WIDE_CONTENT_BASE 0x860
+ # define KS_NABTS_GROUPID_NETWORK_WIDE_ADVERTISER_BASE 0x870
+
+ # define KS_NABTS_GROUPID_TELEVISION_STATION_CONTENT_BASE 0x880
+ # define KS_NABTS_GROUPID_TELEVISION_STATION_ADVERTISER_BASE 0x890
+
+ # define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_CONTENT_BASE 0x8A0
+ # define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_ADVERTISER_BASE 0x8B0
+
+ # define KS_NABTS_GROUPID_MICROSOFT_RESERVED_TEST_DATA_BASE 0x8F0
+
+ # define STATIC_KSDATAFORMAT_TYPE_NABTS                  \
+  0xe757bca0, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
+DEFINE_GUIDSTRUCT("E757BCA0-39AC-11d1-A9F5-00C04FBBDE8F", KSDATAFORMAT_TYPE_NABTS);
+ # define KSDATAFORMAT_TYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_NABTS)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_NABTS_FEC               \
+  0xe757bca1, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
+DEFINE_GUIDSTRUCT("E757BCA1-39AC-11d1-A9F5-00C04FBBDE8F", KSDATAFORMAT_SUBTYPE_NABTS_FEC);
+ # define KSDATAFORMAT_SUBTYPE_NABTS_FEC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS_FEC)
+
+ # define MAX_NABTS_VBI_LINES_PER_FIELD 11
+ # define NABTS_LINES_PER_BUNDLE 16
+ # define NABTS_PAYLOAD_PER_LINE 28
+ # define NABTS_BYTES_PER_LINE 36
+
+typedef struct _NABTSFEC_BUFFER
+{
+  ULONG dataSize;
+  USHORT groupID;
+  USHORT Reserved;
+  UCHAR data[NABTS_LINES_PER_BUNDLE * NABTS_PAYLOAD_PER_LINE];
+}NABTSFEC_BUFFER, * PNABTSFEC_BUFFER;
+
+ # define STATIC_KSPROPSETID_VBICodecFiltering                \
+  0xcafeb0caL, 0x8715, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0xc0, 0xed, 0xba, 0xbe
+DEFINE_GUIDSTRUCT("cafeb0ca-8715-11d0-bd6a-0035c0edbabe", KSPROPSETID_VBICodecFiltering);
+ # define KSPROPSETID_VBICodecFiltering DEFINE_GUIDNAMED(KSPROPSETID_VBICodecFiltering)
+
+typedef enum
+{
+  KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY = 0x01,
+  KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
+  KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
+  KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
+  KSPROPERTY_VBICODECFILTERING_STATISTICS
+}KSPROPERTY_VBICODECFILTERING;
+
+typedef struct _VBICODECFILTERING_SCANLINES
+{
+  DWORD DwordBitArray[32];
+}VBICODECFILTERING_SCANLINES, * PVBICODECFILTERING_SCANLINES;
+
+typedef struct _VBICODECFILTERING_NABTS_SUBSTREAMS
+{
+  DWORD SubstreamMask[128];
+}VBICODECFILTERING_NABTS_SUBSTREAMS, * PVBICODECFILTERING_NABTS_SUBSTREAMS;
+
+typedef struct _VBICODECFILTERING_CC_SUBSTREAMS
+{
+  DWORD SubstreamMask;
+}VBICODECFILTERING_CC_SUBSTREAMS, * PVBICODECFILTERING_CC_SUBSTREAMS;
+
+ # define KS_CC_SUBSTREAM_ODD 0x0001L
+ # define KS_CC_SUBSTREAM_EVEN 0x0002L
+
+ # define KS_CC_SUBSTREAM_FIELD1_MASK 0x00F0L
+ # define KS_CC_SUBSTREAM_SERVICE_CC1 0x0010L
+ # define KS_CC_SUBSTREAM_SERVICE_CC2 0x0020L
+ # define KS_CC_SUBSTREAM_SERVICE_T1 0x0040L
+ # define KS_CC_SUBSTREAM_SERVICE_T2 0x0080L
+
+ # define KS_CC_SUBSTREAM_FIELD2_MASK 0x1F00L
+ # define KS_CC_SUBSTREAM_SERVICE_CC3 0x0100L
+ # define KS_CC_SUBSTREAM_SERVICE_CC4 0x0200L
+ # define KS_CC_SUBSTREAM_SERVICE_T3 0x0400L
+ # define KS_CC_SUBSTREAM_SERVICE_T4 0x0800L
+ # define KS_CC_SUBSTREAM_SERVICE_XDS 0x1000L
+
+ # define CC_MAX_HW_DECODE_LINES 12
+typedef struct _CC_BYTE_PAIR
+{
+  BYTE Decoded[2];
+  USHORT Reserved;
+}CC_BYTE_PAIR, * PCC_BYTE_PAIR;
+
+typedef struct _CC_HW_FIELD
+{
+  VBICODECFILTERING_SCANLINES ScanlinesRequested;
+  ULONG fieldFlags;
+  LONGLONG PictureNumber;
+  CC_BYTE_PAIR Lines[CC_MAX_HW_DECODE_LINES];
+}CC_HW_FIELD, * PCC_HW_FIELD;
+
+ # ifndef PACK_PRAGMAS_NOT_SUPPORTED
+  #  include <pshpack1.h>
+ # endif
+typedef struct _NABTS_BUFFER_LINE
+{
+  BYTE Confidence;
+  BYTE Bytes[NABTS_BYTES_PER_LINE];
+}NABTS_BUFFER_LINE, * PNABTS_BUFFER_LINE;
+
+ # define NABTS_BUFFER_PICTURENUMBER_SUPPORT 1
+typedef struct _NABTS_BUFFER
+{
+  VBICODECFILTERING_SCANLINES ScanlinesRequested;
+  LONGLONG PictureNumber;
+  NABTS_BUFFER_LINE NabtsLines[MAX_NABTS_VBI_LINES_PER_FIELD];
+}NABTS_BUFFER, * PNABTS_BUFFER;
+ # ifndef PACK_PRAGMAS_NOT_SUPPORTED
+  #  include <poppack.h>
+ # endif
+
+ # define WST_TVTUNER_CHANGE_BEGIN_TUNE 0x1000L
+ # define WST_TVTUNER_CHANGE_END_TUNE 0x2000L
+
+ # define MAX_WST_VBI_LINES_PER_FIELD 17
+ # define WST_BYTES_PER_LINE 42
+
+typedef struct _WST_BUFFER_LINE
+{
+  BYTE Confidence;
+  BYTE Bytes[WST_BYTES_PER_LINE];
+}WST_BUFFER_LINE, * PWST_BUFFER_LINE;
+
+typedef struct _WST_BUFFER
+{
+  VBICODECFILTERING_SCANLINES ScanlinesRequested;
+  WST_BUFFER_LINE WstLines[MAX_WST_VBI_LINES_PER_FIELD];
+}WST_BUFFER, * PWST_BUFFER;
+
+typedef struct _VBICODECFILTERING_STATISTICS_COMMON
+{
+  DWORD InputSRBsProcessed;
+  DWORD OutputSRBsProcessed;
+  DWORD SRBsIgnored;
+  DWORD InputSRBsMissing;
+  DWORD OutputSRBsMissing;
+  DWORD OutputFailures;
+  DWORD InternalErrors;
+  DWORD ExternalErrors;
+  DWORD InputDiscontinuities;
+  DWORD DSPFailures;
+  DWORD TvTunerChanges;
+  DWORD VBIHeaderChanges;
+  DWORD LineConfidenceAvg;
+  DWORD BytesOutput;
+}VBICODECFILTERING_STATISTICS_COMMON, * PVBICODECFILTERING_STATISTICS_COMMON;
+
+typedef struct _VBICODECFILTERING_STATISTICS_COMMON_PIN
+{
+  DWORD SRBsProcessed;
+  DWORD SRBsIgnored;
+  DWORD SRBsMissing;
+  DWORD InternalErrors;
+  DWORD ExternalErrors;
+  DWORD Discontinuities;
+  DWORD LineConfidenceAvg;
+  DWORD BytesOutput;
+}VBICODECFILTERING_STATISTICS_COMMON_PIN, * PVBICODECFILTERING_STATISTICS_COMMON_PIN;
+
+typedef struct _VBICODECFILTERING_STATISTICS_NABTS
+{
+  VBICODECFILTERING_STATISTICS_COMMON Common;
+  DWORD FECBundleBadLines;
+  DWORD FECQueueOverflows;
+  DWORD FECCorrectedLines;
+  DWORD FECUncorrectableLines;
+  DWORD BundlesProcessed;
+  DWORD BundlesSent2IP;
+  DWORD FilteredLines;
+}VBICODECFILTERING_STATISTICS_NABTS, * PVBICODECFILTERING_STATISTICS_NABTS;
+
+typedef struct _VBICODECFILTERING_STATISTICS_NABTS_PIN
+{
+  VBICODECFILTERING_STATISTICS_COMMON_PIN Common;
+}VBICODECFILTERING_STATISTICS_NABTS_PIN, * PVBICODECFILTERING_STATISTICS_NABTS_PIN;
+
+typedef struct _VBICODECFILTERING_STATISTICS_CC
+{
+  VBICODECFILTERING_STATISTICS_COMMON Common;
+}VBICODECFILTERING_STATISTICS_CC, * PVBICODECFILTERING_STATISTICS_CC;
+
+typedef struct _VBICODECFILTERING_STATISTICS_CC_PIN
+{
+  VBICODECFILTERING_STATISTICS_COMMON_PIN Common;
+}VBICODECFILTERING_STATISTICS_CC_PIN, * PVBICODECFILTERING_STATISTICS_CC_PIN;
+
+typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT
+{
+  VBICODECFILTERING_STATISTICS_COMMON Common;
+}VBICODECFILTERING_STATISTICS_TELETEXT, * PVBICODECFILTERING_STATISTICS_TELETEXT;
+
+typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT_PIN
+{
+  VBICODECFILTERING_STATISTICS_COMMON_PIN Common;
+}VBICODECFILTERING_STATISTICS_TELETEXT_PIN, * PVBICODECFILTERING_STATISTICS_TELETEXT_PIN;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  VBICODECFILTERING_SCANLINES Scanlines;
+}KSPROPERTY_VBICODECFILTERING_SCANLINES_S, * PKSPROPERTY_VBICODECFILTERING_SCANLINES_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  VBICODECFILTERING_NABTS_SUBSTREAMS Substreams;
+}KSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S, * PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  VBICODECFILTERING_CC_SUBSTREAMS Substreams;
+}KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S, * PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  VBICODECFILTERING_STATISTICS_COMMON Statistics;
+}KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S, * PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  VBICODECFILTERING_STATISTICS_COMMON_PIN Statistics;
+}KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S, * PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  VBICODECFILTERING_STATISTICS_NABTS Statistics;
+}KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S, * PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  VBICODECFILTERING_STATISTICS_NABTS_PIN Statistics;
+}KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S, * PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  VBICODECFILTERING_STATISTICS_CC Statistics;
+}KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S, * PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  VBICODECFILTERING_STATISTICS_CC_PIN Statistics;
+}KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S, * PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S;
+
+ # define STATIC_PINNAME_VIDEO_CAPTURE                    \
+  0xfb6c4281, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+ # define STATIC_PINNAME_CAPTURE STATIC_PINNAME_VIDEO_CAPTURE
+DEFINE_GUIDSTRUCT("FB6C4281-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CAPTURE);
+ # define PINNAME_VIDEO_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CAPTURE)
+ # define PINNAME_CAPTURE PINNAME_VIDEO_CAPTURE
+
+ # define STATIC_PINNAME_VIDEO_CC_CAPTURE                 \
+  0x1aad8061, 0x12d, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
+ # define STATIC_PINNAME_CC_CAPTURE STATIC_PINNAME_VIDEO_CC_CAPTURE
+DEFINE_GUIDSTRUCT("1AAD8061-012D-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_CC_CAPTURE);
+ # define PINNAME_VIDEO_CC_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CC_CAPTURE)
+
+ # define STATIC_PINNAME_VIDEO_NABTS_CAPTURE              \
+  0x29703660, 0x498a, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
+ # define STATIC_PINNAME_NABTS_CAPTURE STATIC_PINNAME_VIDEO_NABTS_CAPTURE
+DEFINE_GUIDSTRUCT("29703660-498A-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_NABTS_CAPTURE);
+ # define PINNAME_VIDEO_NABTS_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS_CAPTURE)
+
+ # define STATIC_PINNAME_VIDEO_PREVIEW                    \
+  0xfb6c4282, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+ # define STATIC_PINNAME_PREVIEW STATIC_PINNAME_VIDEO_PREVIEW
+DEFINE_GUIDSTRUCT("FB6C4282-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_PREVIEW);
+ # define PINNAME_VIDEO_PREVIEW DEFINE_GUIDNAMED(PINNAME_VIDEO_PREVIEW)
+ # define PINNAME_PREVIEW PINNAME_VIDEO_PREVIEW
+
+ # define STATIC_PINNAME_VIDEO_ANALOGVIDEOIN              \
+  0xfb6c4283, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("FB6C4283-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_ANALOGVIDEOIN);
+ # define PINNAME_VIDEO_ANALOGVIDEOIN DEFINE_GUIDNAMED(PINNAME_VIDEO_ANALOGVIDEOIN)
+
+ # define STATIC_PINNAME_VIDEO_VBI                    \
+  0xfb6c4284, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("FB6C4284-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VBI);
+ # define PINNAME_VIDEO_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VBI)
+
+ # define STATIC_PINNAME_VIDEO_VIDEOPORT                  \
+  0xfb6c4285, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("FB6C4285-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT);
+ # define PINNAME_VIDEO_VIDEOPORT DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT)
+
+ # define STATIC_PINNAME_VIDEO_NABTS                  \
+  0xfb6c4286, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("FB6C4286-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_NABTS);
+ # define PINNAME_VIDEO_NABTS DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS)
+
+ # define STATIC_PINNAME_VIDEO_EDS                    \
+  0xfb6c4287, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("FB6C4287-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_EDS);
+ # define PINNAME_VIDEO_EDS DEFINE_GUIDNAMED(PINNAME_VIDEO_EDS)
+
+ # define STATIC_PINNAME_VIDEO_TELETEXT                   \
+  0xfb6c4288, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("FB6C4288-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TELETEXT);
+ # define PINNAME_VIDEO_TELETEXT DEFINE_GUIDNAMED(PINNAME_VIDEO_TELETEXT)
+
+ # define STATIC_PINNAME_VIDEO_CC                     \
+  0xfb6c4289, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("FB6C4289-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CC);
+ # define PINNAME_VIDEO_CC DEFINE_GUIDNAMED(PINNAME_VIDEO_CC)
+
+ # define STATIC_PINNAME_VIDEO_STILL                  \
+  0xfb6c428A, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("FB6C428A-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_STILL);
+ # define PINNAME_VIDEO_STILL DEFINE_GUIDNAMED(PINNAME_VIDEO_STILL)
+
+ # define STATIC_PINNAME_VIDEO_TIMECODE                   \
+  0xfb6c428B, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("FB6C428B-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TIMECODE);
+ # define PINNAME_VIDEO_TIMECODE DEFINE_GUIDNAMED(PINNAME_VIDEO_TIMECODE)
+
+ # define STATIC_PINNAME_VIDEO_VIDEOPORT_VBI              \
+  0xfb6c428C, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("FB6C428C-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT_VBI);
+ # define PINNAME_VIDEO_VIDEOPORT_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT_VBI)
+
+ # define KS_VIDEO_FLAG_FRAME 0x0000L
+ # define KS_VIDEO_FLAG_FIELD1 0x0001L
+ # define KS_VIDEO_FLAG_FIELD2 0x0002L
+
+ # define KS_VIDEO_FLAG_I_FRAME 0x0000L
+ # define KS_VIDEO_FLAG_P_FRAME 0x0010L
+ # define KS_VIDEO_FLAG_B_FRAME 0x0020L
+
+typedef struct tagKS_FRAME_INFO
+{
+  ULONG ExtendedHeaderSize;
+  DWORD dwFrameFlags;
+  LONGLONG PictureNumber;
+  LONGLONG DropCount;
+  HANDLE hDirectDraw;
+  HANDLE hSurfaceHandle;
+  RECT DirectDrawRect;
+
+  DWORD Reserved1;
+  DWORD Reserved2;
+  DWORD Reserved3;
+  DWORD Reserved4;
+}KS_FRAME_INFO, * PKS_FRAME_INFO;
+
+ # define KS_VBI_FLAG_FIELD1 0x0001L
+ # define KS_VBI_FLAG_FIELD2 0x0002L
+
+ # define KS_VBI_FLAG_MV_PRESENT 0x0100L
+ # define KS_VBI_FLAG_MV_HARDWARE 0x0200L
+ # define KS_VBI_FLAG_MV_DETECTED 0x0400L
+
+ # define KS_VBI_FLAG_TVTUNER_CHANGE 0x0010L
+ # define KS_VBI_FLAG_VBIINFOHEADER_CHANGE 0x0020L
+
+typedef struct tagKS_VBI_FRAME_INFO
+{
+  ULONG ExtendedHeaderSize;
+  DWORD dwFrameFlags;
+  LONGLONG PictureNumber;
+  LONGLONG DropCount;
+  DWORD dwSamplingFrequency;
+  KS_TVTUNER_CHANGE_INFO TvTunerChangeInfo;
+  KS_VBIINFOHEADER VBIInfoHeader;
+}KS_VBI_FRAME_INFO, * PKS_VBI_FRAME_INFO;
+
+typedef enum
+{
+  KS_AnalogVideo_None = 0x00000000,
+  KS_AnalogVideo_NTSC_M = 0x00000001,
+  KS_AnalogVideo_NTSC_M_J = 0x00000002,
+  KS_AnalogVideo_NTSC_433 = 0x00000004,
+  KS_AnalogVideo_PAL_B = 0x00000010,
+  KS_AnalogVideo_PAL_D = 0x00000020,
+  KS_AnalogVideo_PAL_G = 0x00000040,
+  KS_AnalogVideo_PAL_H = 0x00000080,
+  KS_AnalogVideo_PAL_I = 0x00000100,
+  KS_AnalogVideo_PAL_M = 0x00000200,
+  KS_AnalogVideo_PAL_N = 0x00000400,
+  KS_AnalogVideo_PAL_60 = 0x00000800,
+  KS_AnalogVideo_SECAM_B = 0x00001000,
+  KS_AnalogVideo_SECAM_D = 0x00002000,
+  KS_AnalogVideo_SECAM_G = 0x00004000,
+  KS_AnalogVideo_SECAM_H = 0x00008000,
+  KS_AnalogVideo_SECAM_K = 0x00010000,
+  KS_AnalogVideo_SECAM_K1 = 0x00020000,
+  KS_AnalogVideo_SECAM_L = 0x00040000,
+  KS_AnalogVideo_SECAM_L1 = 0x00080000,
+  KS_AnalogVideo_PAL_N_COMBO = 0x00100000
+}KS_AnalogVideoStandard;
+
+ # define KS_AnalogVideo_NTSC_Mask 0x00000007
+ # define KS_AnalogVideo_PAL_Mask 0x00100FF0
+ # define KS_AnalogVideo_SECAM_Mask 0x000FF000
+
+ # define STATIC_PROPSETID_ALLOCATOR_CONTROL              \
+  0x53171960, 0x148e, 0x11d2, 0x99, 0x79, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
+DEFINE_GUIDSTRUCT("53171960-148E-11d2-9979-0000C0CC16BA", PROPSETID_ALLOCATOR_CONTROL);
+ # define PROPSETID_ALLOCATOR_CONTROL DEFINE_GUIDNAMED(PROPSETID_ALLOCATOR_CONTROL)
+
+typedef enum
+{
+  KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,
+  KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE,
+  KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS,
+  KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE
+}KSPROPERTY_ALLOCATOR_CONTROL;
+
+typedef struct
+{
+  ULONG CX;
+  ULONG CY;
+}KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S, * PKSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S;
+
+typedef struct
+{
+  ULONG InterleavedCapSupported;
+}KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S, * PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S;
+
+typedef struct
+{
+  ULONG InterleavedCapPossible;
+}KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S, * PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S;
+
+ # define STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP                \
+  0xC6E13360L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("C6E13360-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOPROCAMP);
+ # define PROPSETID_VIDCAP_VIDEOPROCAMP DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOPROCAMP)
+
+typedef enum
+{
+  KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,
+  KSPROPERTY_VIDEOPROCAMP_CONTRAST,
+  KSPROPERTY_VIDEOPROCAMP_HUE,
+  KSPROPERTY_VIDEOPROCAMP_SATURATION,
+  KSPROPERTY_VIDEOPROCAMP_SHARPNESS,
+  KSPROPERTY_VIDEOPROCAMP_GAMMA,
+  KSPROPERTY_VIDEOPROCAMP_COLORENABLE,
+  KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,
+  KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,
+  KSPROPERTY_VIDEOPROCAMP_GAIN,
+  KSPROPERTY_VIDEOPROCAMP_DIGITAL_MULTIPLIER,
+  KSPROPERTY_VIDEOPROCAMP_DIGITAL_MULTIPLIER_LIMIT,
+  KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE_COMPONENT,
+  KSPROPERTY_VIDEOPROCAMP_POWERLINE_FREQUENCY
+}KSPROPERTY_VIDCAP_VIDEOPROCAMP;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  LONG Value;
+  ULONG Flags;
+  ULONG Capabilities;
+}KSPROPERTY_VIDEOPROCAMP_S, * PKSPROPERTY_VIDEOPROCAMP_S;
+
+typedef struct
+{
+  KSP_NODE NodeProperty;
+  LONG Value;
+  ULONG Flags;
+  ULONG Capabilities;
+}KSPROPERTY_VIDEOPROCAMP_NODE_S, * PKSPROPERTY_VIDEOPROCAMP_NODE_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  LONG Value1;
+  ULONG Flags;
+  ULONG Capabilities;
+  LONG Value2;
+}KSPROPERTY_VIDEOPROCAMP_S2, * PKSPROPERTY_VIDEOPROCAMP_S2;
+
+typedef struct
+{
+  KSP_NODE NodeProperty;
+  LONG Value1;
+  ULONG Flags;
+  ULONG Capabilities;
+  LONG Value2;
+}KSPROPERTY_VIDEOPROCAMP_NODE_S2, * PKSPROPERTY_VIDEOPROCAMP_NODE_S2;
+
+ # define KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO 0X0001L
+ # define KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL 0X0002L
+
+ # define STATIC_PROPSETID_VIDCAP_SELECTOR                \
+  0x1ABDAECA, 0x68B6, 0x4F83, 0x93, 0x71, 0xB4, 0x13, 0x90, 0x7C, 0x7B, 0x9F
+DEFINE_GUIDSTRUCT("1ABDAECA-68B6-4F83-9371-B413907C7B9F", PROPSETID_VIDCAP_SELECTOR);
+ # define PROPSETID_VIDCAP_SELECTOR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_SELECTOR)
+
+typedef enum
+{
+  KSPROPERTY_SELECTOR_SOURCE_NODE_ID,
+  KSPROPERTY_SELECTOR_NUM_SOURCES
+}KSPROPERTY_VIDCAP_SELECTOR, * PKSPROPERTY_VIDCAP_SELECTOR;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  LONG Value;
+  ULONG Flags;
+  ULONG Capabilities;
+}KSPROPERTY_SELECTOR_S, * PKSPROPERTY_SELECTOR_S;
+
+typedef struct
+{
+  KSP_NODE NodeProperty;
+  LONG Value;
+  ULONG Flags;
+  ULONG Capabilities;
+}KSPROPERTY_SELECTOR_NODE_S, * PKSPROPERTY_SELECTOR_NODE_S;
+
+ # define STATIC_PROPSETID_TUNER                      \
+  0x6a2e0605L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("6a2e0605-28e4-11d0-a18c-00a0c9118956", PROPSETID_TUNER);
+ # define PROPSETID_TUNER DEFINE_GUIDNAMED(PROPSETID_TUNER)
+
+typedef enum
+{
+  KSPROPERTY_TUNER_CAPS,
+  KSPROPERTY_TUNER_MODE_CAPS,
+  KSPROPERTY_TUNER_MODE,
+  KSPROPERTY_TUNER_STANDARD,
+  KSPROPERTY_TUNER_FREQUENCY,
+  KSPROPERTY_TUNER_INPUT,
+  KSPROPERTY_TUNER_STATUS,
+  KSPROPERTY_TUNER_IF_MEDIUM
+}KSPROPERTY_TUNER;
+
+typedef enum
+{
+  KSPROPERTY_TUNER_MODE_TV = 0X0001,
+  KSPROPERTY_TUNER_MODE_FM_RADIO = 0X0002,
+  KSPROPERTY_TUNER_MODE_AM_RADIO = 0X0004,
+  KSPROPERTY_TUNER_MODE_DSS = 0X0008,
+  KSPROPERTY_TUNER_MODE_ATSC = 0X0010
+}KSPROPERTY_TUNER_MODES;
+
+typedef enum
+{
+  KS_TUNER_TUNING_EXACT = 1,
+  KS_TUNER_TUNING_FINE,
+  KS_TUNER_TUNING_COARSE
+}KS_TUNER_TUNING_FLAGS;
+
+typedef enum
+{
+  KS_TUNER_STRATEGY_PLL = 0X01,
+  KS_TUNER_STRATEGY_SIGNAL_STRENGTH = 0X02,
+  KS_TUNER_STRATEGY_DRIVER_TUNES = 0X04
+}KS_TUNER_STRATEGY;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG ModesSupported;
+  KSPIN_MEDIUM VideoMedium;
+  KSPIN_MEDIUM TVAudioMedium;
+  KSPIN_MEDIUM RadioAudioMedium;
+}KSPROPERTY_TUNER_CAPS_S, * PKSPROPERTY_TUNER_CAPS_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  KSPIN_MEDIUM IFMedium;
+}KSPROPERTY_TUNER_IF_MEDIUM_S, * PKSPROPERTY_TUNER_IF_MEDIUM_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG Mode;
+  ULONG StandardsSupported;
+  ULONG MinFrequency;
+  ULONG MaxFrequency;
+  ULONG TuningGranularity;
+  ULONG NumberOfInputs;
+  ULONG SettlingTime;
+  ULONG Strategy;
+}KSPROPERTY_TUNER_MODE_CAPS_S, * PKSPROPERTY_TUNER_MODE_CAPS_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG Mode;
+}KSPROPERTY_TUNER_MODE_S, * PKSPROPERTY_TUNER_MODE_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG Frequency;
+  ULONG LastFrequency;
+  ULONG TuningFlags;
+  ULONG VideoSubChannel;
+  ULONG AudioSubChannel;
+  ULONG Channel;
+  ULONG Country;
+}KSPROPERTY_TUNER_FREQUENCY_S, * PKSPROPERTY_TUNER_FREQUENCY_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG Standard;
+}KSPROPERTY_TUNER_STANDARD_S, * PKSPROPERTY_TUNER_STANDARD_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG InputIndex;
+}KSPROPERTY_TUNER_INPUT_S, * PKSPROPERTY_TUNER_INPUT_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG CurrentFrequency;
+  ULONG PLLOffset;
+  ULONG SignalStrength;
+  ULONG Busy;
+}KSPROPERTY_TUNER_STATUS_S, * PKSPROPERTY_TUNER_STATUS_S;
+
+ # define STATIC_EVENTSETID_TUNER                     \
+  0x6a2e0606L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("6a2e0606-28e4-11d0-a18c-00a0c9118956", EVENTSETID_TUNER);
+ # define EVENTSETID_TUNER DEFINE_GUIDNAMED(EVENTSETID_TUNER)
+
+typedef enum
+{
+  KSEVENT_TUNER_CHANGED
+}KSEVENT_TUNER;
+
+ # define STATIC_KSNODETYPE_VIDEO_STREAMING               \
+  0xDFF229E1L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("DFF229E1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_STREAMING);
+ # define KSNODETYPE_VIDEO_STREAMING DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_STREAMING)
+
+ # define STATIC_KSNODETYPE_VIDEO_INPUT_TERMINAL              \
+  0xDFF229E2L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("DFF229E2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_INPUT_TERMINAL);
+ # define KSNODETYPE_VIDEO_INPUT_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_INPUT_TERMINAL)
+
+ # define STATIC_KSNODETYPE_VIDEO_OUTPUT_TERMINAL             \
+  0xDFF229E3L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("DFF229E3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_OUTPUT_TERMINAL);
+ # define KSNODETYPE_VIDEO_OUTPUT_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_OUTPUT_TERMINAL)
+
+ # define STATIC_KSNODETYPE_VIDEO_SELECTOR                \
+  0xDFF229E4L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("DFF229E4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_SELECTOR);
+ # define KSNODETYPE_VIDEO_SELECTOR DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_SELECTOR)
+
+ # define STATIC_KSNODETYPE_VIDEO_PROCESSING              \
+  0xDFF229E5L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("DFF229E5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_PROCESSING);
+ # define KSNODETYPE_VIDEO_PROCESSING DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_PROCESSING)
+
+ # define STATIC_KSNODETYPE_VIDEO_CAMERA_TERMINAL             \
+  0xDFF229E6L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("DFF229E6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_CAMERA_TERMINAL);
+ # define KSNODETYPE_VIDEO_CAMERA_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_CAMERA_TERMINAL)
+
+ # define STATIC_KSNODETYPE_VIDEO_INPUT_MTT               \
+  0xDFF229E7L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("DFF229E7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_INPUT_MTT);
+ # define KSNODETYPE_VIDEO_INPUT_MTT DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_INPUT_MTT)
+
+ # define STATIC_KSNODETYPE_VIDEO_OUTPUT_MTT              \
+  0xDFF229E8L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("DFF229E8-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_OUTPUT_MTT);
+ # define KSNODETYPE_VIDEO_OUTPUT_MTT DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_OUTPUT_MTT)
+
+ # define STATIC_PROPSETID_VIDCAP_VIDEOENCODER                \
+  0x6a2e0610L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("6a2e0610-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOENCODER);
+ # define PROPSETID_VIDCAP_VIDEOENCODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOENCODER)
+
+typedef enum
+{
+  KSPROPERTY_VIDEOENCODER_CAPS,
+  KSPROPERTY_VIDEOENCODER_STANDARD,
+  KSPROPERTY_VIDEOENCODER_COPYPROTECTION,
+  KSPROPERTY_VIDEOENCODER_CC_ENABLE
+}KSPROPERTY_VIDCAP_VIDEOENCODER;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  LONG Value;
+  ULONG Flags;
+  ULONG Capabilities;
+}KSPROPERTY_VIDEOENCODER_S, * PKSPROPERTY_VIDEOENCODER_S;
+
+ # define STATIC_PROPSETID_VIDCAP_VIDEODECODER                \
+  0xC6E13350L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("C6E13350-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEODECODER);
+ # define PROPSETID_VIDCAP_VIDEODECODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEODECODER)
+
+typedef enum
+{
+  KSPROPERTY_VIDEODECODER_CAPS,
+  KSPROPERTY_VIDEODECODER_STANDARD,
+  KSPROPERTY_VIDEODECODER_STATUS,
+  KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,
+  KSPROPERTY_VIDEODECODER_VCR_TIMING
+}KSPROPERTY_VIDCAP_VIDEODECODER;
+
+typedef enum
+{
+  KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT = 0X0001,
+  KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING = 0X0002,
+  KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED = 0X0004
+}KS_VIDEODECODER_FLAGS;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG StandardsSupported;
+  ULONG Capabilities;
+  ULONG SettlingTime;
+  ULONG HSyncPerVSync;
+}KSPROPERTY_VIDEODECODER_CAPS_S, * PKSPROPERTY_VIDEODECODER_CAPS_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG NumberOfLines;
+  ULONG SignalLocked;
+}KSPROPERTY_VIDEODECODER_STATUS_S, * PKSPROPERTY_VIDEODECODER_STATUS_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG Value;
+}KSPROPERTY_VIDEODECODER_S, * PKSPROPERTY_VIDEODECODER_S;
+
+ # define STATIC_EVENTSETID_VIDEODECODER                  \
+  0x6a2e0621L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("6a2e0621-28e4-11d0-a18c-00a0c9118956", EVENTSETID_VIDEODECODER);
+ # define EVENTSETID_VIDEODECODER DEFINE_GUIDNAMED(EVENTSETID_VIDEODECODER)
+
+typedef enum
+{
+  KSEVENT_VIDEODECODER_CHANGED
+}KSEVENT_VIDEODECODER;
+
+ # define STATIC_PROPSETID_VIDCAP_CAMERACONTROL               \
+  0xC6E13370L, 0x30AC, 0x11d0, 0xa1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("C6E13370-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_CAMERACONTROL);
+ # define PROPSETID_VIDCAP_CAMERACONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CAMERACONTROL)
+
+typedef enum
+{
+  KSPROPERTY_CAMERACONTROL_PAN,
+  KSPROPERTY_CAMERACONTROL_TILT,
+  KSPROPERTY_CAMERACONTROL_ROLL,
+  KSPROPERTY_CAMERACONTROL_ZOOM,
+  KSPROPERTY_CAMERACONTROL_EXPOSURE,
+  KSPROPERTY_CAMERACONTROL_IRIS,
+  KSPROPERTY_CAMERACONTROL_FOCUS,
+  KSPROPERTY_CAMERACONTROL_SCANMODE,
+  KSPROPERTY_CAMERACONTROL_PRIVACY,
+  KSPROPERTY_CAMERACONTROL_PANTILT,
+  KSPROPERTY_CAMERACONTROL_PAN_RELATIVE,
+  KSPROPERTY_CAMERACONTROL_TILT_RELATIVE,
+  KSPROPERTY_CAMERACONTROL_ROLL_RELATIVE,
+  KSPROPERTY_CAMERACONTROL_ZOOM_RELATIVE,
+  KSPROPERTY_CAMERACONTROL_EXPOSURE_RELATIVE,
+  KSPROPERTY_CAMERACONTROL_IRIS_RELATIVE,
+  KSPROPERTY_CAMERACONTROL_FOCUS_RELATIVE,
+  KSPROPERTY_CAMERACONTROL_PANTILT_RELATIVE,
+  KSPROPERTY_CAMERACONTROL_FOCAL_LENGTH
+}KSPROPERTY_VIDCAP_CAMERACONTROL;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  LONG Value;
+  ULONG Flags;
+  ULONG Capabilities;
+}KSPROPERTY_CAMERACONTROL_S, * PKSPROPERTY_CAMERACONTROL_S;
+
+typedef struct
+{
+  KSP_NODE NodeProperty;
+  LONG Value;
+  ULONG Flags;
+  ULONG Capabilities;
+}KSPROPERTY_CAMERACONTROL_NODE_S, PKSPROPERTY_CAMERACONTROL_NODE_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  LONG Value1;
+  ULONG Flags;
+  ULONG Capabilities;
+  LONG Value2;
+}KSPROPERTY_CAMERACONTROL_S2, * PKSPROPERTY_CAMERACONTROL_S2;
+
+typedef struct
+{
+  KSP_NODE NodeProperty;
+  LONG Value1;
+  ULONG Flags;
+  ULONG Capabilities;
+  LONG Value2;
+}KSPROPERTY_CAMERACONTROL_NODE_S2, * PKSPROPERTY_CAMERACONTROL_NODE_S2;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  LONG lOcularFocalLength;
+  LONG lObjectiveFocalLengthMin;
+  LONG lObjectiveFocalLengthMax;
+}KSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S, * PKSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S;
+
+typedef struct
+{
+  KSNODEPROPERTY NodeProperty;
+  LONG lOcularFocalLength;
+  LONG lObjectiveFocalLengthMin;
+  LONG lObjectiveFocalLengthMax;
+}KSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S, * PKSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S;
+
+ # define KSPROPERTY_CAMERACONTROL_FLAGS_AUTO 0X0001L
+ # define KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL 0X0002L
+
+ # define KSPROPERTY_CAMERACONTROL_FLAGS_ABSOLUTE 0X0000L
+ # define KSPROPERTY_CAMERACONTROL_FLAGS_RELATIVE 0X0010L
+
+ # ifndef __EDevCtrl__
+  #  define __EDevCtrl__
+
+  #  define STATIC_PROPSETID_EXT_DEVICE                 \
+  0xB5730A90L, 0x1A2C, 0x11cf, 0x8c, 0x23, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
+DEFINE_GUIDSTRUCT("B5730A90-1A2C-11cf-8C23-00AA006B6814", PROPSETID_EXT_DEVICE);
+  #  define PROPSETID_EXT_DEVICE DEFINE_GUIDNAMED(PROPSETID_EXT_DEVICE)
+
+typedef enum
+{
+  KSPROPERTY_EXTDEVICE_ID,
+  KSPROPERTY_EXTDEVICE_VERSION,
+  KSPROPERTY_EXTDEVICE_POWER_STATE,
+  KSPROPERTY_EXTDEVICE_PORT,
+  KSPROPERTY_EXTDEVICE_CAPABILITIES
+}KSPROPERTY_EXTDEVICE;
+
+typedef struct tagDEVCAPS
+{
+  LONG CanRecord;
+  LONG CanRecordStrobe;
+  LONG HasAudio;
+  LONG HasVideo;
+  LONG UsesFiles;
+  LONG CanSave;
+  LONG DeviceType;
+  LONG TCRead;
+  LONG TCWrite;
+  LONG CTLRead;
+  LONG IndexRead;
+  LONG Preroll;
+  LONG Postroll;
+  LONG SyncAcc;
+  LONG NormRate;
+  LONG CanPreview;
+  LONG CanMonitorSrc;
+  LONG CanTest;
+  LONG VideoIn;
+  LONG AudioIn;
+  LONG Calibrate;
+  LONG SeekType;
+  LONG SimulatedHardware;
+}DEVCAPS, * PDEVCAPS;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  union
+  {
+    DEVCAPS Capabilities;
+    ULONG DevPort;
+    ULONG PowerState;
+    WCHAR pawchString[MAX_PATH];
+    DWORD NodeUniqueID[2];
+  }u;
+}KSPROPERTY_EXTDEVICE_S, * PKSPROPERTY_EXTDEVICE_S;
+
+  #  define STATIC_PROPSETID_EXT_TRANSPORT                  \
+  0xA03CD5F0L, 0x3045, 0x11cf, 0x8c, 0x44, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
+DEFINE_GUIDSTRUCT("A03CD5F0-3045-11cf-8C44-00AA006B6814", PROPSETID_EXT_TRANSPORT);
+  #  define PROPSETID_EXT_TRANSPORT DEFINE_GUIDNAMED(PROPSETID_EXT_TRANSPORT)
+
+typedef enum
+{
+  KSPROPERTY_EXTXPORT_CAPABILITIES,
+  KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,
+  KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE,
+  KSPROPERTY_EXTXPORT_LOAD_MEDIUM,
+  KSPROPERTY_EXTXPORT_MEDIUM_INFO,
+  KSPROPERTY_EXTXPORT_STATE,
+  KSPROPERTY_EXTXPORT_STATE_NOTIFY,
+  KSPROPERTY_EXTXPORT_TIMECODE_SEARCH,
+  KSPROPERTY_EXTXPORT_ATN_SEARCH,
+  KSPROPERTY_EXTXPORT_RTC_SEARCH,
+  KSPROPERTY_RAW_AVC_CMD
+}KSPROPERTY_EXTXPORT;
+
+typedef struct tagTRANSPORTSTATUS
+{
+  LONG Mode;
+  LONG LastError;
+  LONG RecordInhibit;
+  LONG ServoLock;
+  LONG MediaPresent;
+  LONG MediaLength;
+  LONG MediaSize;
+  LONG MediaTrackCount;
+  LONG MediaTrackLength;
+  LONG MediaTrackSide;
+  LONG MediaType;
+  LONG LinkMode;
+  LONG NotifyOn;
+}TRANSPORTSTATUS, * PTRANSPORTSTATUS;
+
+typedef struct tagTRANSPORTBASICPARMS
+{
+  LONG TimeFormat;
+  LONG TimeReference;
+  LONG Superimpose;
+  LONG EndStopAction;
+  LONG RecordFormat;
+  LONG StepFrames;
+  LONG SetpField;
+  LONG Preroll;
+  LONG RecPreroll;
+  LONG Postroll;
+  LONG EditDelay;
+  LONG PlayTCDelay;
+  LONG RecTCDelay;
+  LONG EditField;
+  LONG FrameServo;
+  LONG ColorFrameServo;
+  LONG ServoRef;
+  LONG WarnGenlock;
+  LONG SetTracking;
+  TCHAR VolumeName[40];
+  LONG Ballistic[20];
+  LONG Speed;
+  LONG CounterFormat;
+  LONG TunerChannel;
+  LONG TunerNumber;
+  LONG TimerEvent;
+  LONG TimerStartDay;
+  LONG TimerStartTime;
+  LONG TimerStopDay;
+  LONG TimerStopTime;
+}TRANSPORTBASICPARMS, * PTRANSPORTBASICPARMS;
+
+typedef struct tagTRANSPORTVIDEOPARMS
+{
+  LONG OutputMode;
+  LONG Input;
+}TRANSPORTVIDEOPARMS, * PTRANSPORTVIDEOPARMS;
+
+typedef struct tagTRANSPORTAUDIOPARMS
+{
+  LONG EnableOutput;
+  LONG EnableRecord;
+  LONG EnableSelsync;
+  LONG Input;
+  LONG MonitorSource;
+}TRANSPORTAUDIOPARMS, * PTRANSPORTAUDIOPARMS;
+
+typedef struct
+{
+  WINBOOL MediaPresent;
+  ULONG MediaType;
+  WINBOOL RecordInhibit;
+}MEDIUM_INFO, * PMEDIUM_INFO;
+
+typedef struct
+{
+  ULONG Mode;
+  ULONG State;
+}TRANSPORT_STATE, * PTRANSPORT_STATE;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  union
+  {
+    ULONG Capabilities;
+    ULONG SignalMode;
+    ULONG LoadMedium;
+    MEDIUM_INFO MediumInfo;
+    TRANSPORT_STATE XPrtState;
+    struct
+    {
+      BYTE frame;
+      BYTE second;
+      BYTE minute;
+      BYTE hour;
+    }Timecode;
+    DWORD dwTimecode;
+    DWORD dwAbsTrackNumber;
+    struct
+    {
+      ULONG PayloadSize;
+      BYTE Payload[512];
+    }RawAVC;
+  }u;
+}KSPROPERTY_EXTXPORT_S, * PKSPROPERTY_EXTXPORT_S;
+
+typedef struct
+{
+  KSP_NODE NodeProperty;
+  union
+  {
+    ULONG Capabilities;
+    ULONG SignalMode;
+    ULONG LoadMedium;
+    MEDIUM_INFO MediumInfo;
+    TRANSPORT_STATE XPrtState;
+    struct
+    {
+      BYTE frame;
+      BYTE second;
+      BYTE minute;
+      BYTE hour;
+    }Timecode;
+    DWORD dwTimecode;
+    DWORD dwAbsTrackNumber;
+    struct
+    {
+      ULONG PayloadSize;
+      BYTE Payload[512];
+    }RawAVC;
+  }u;
+}KSPROPERTY_EXTXPORT_NODE_S, * PKSPROPERTY_EXTXPORT_NODE_S;
+
+  #  define STATIC_PROPSETID_TIMECODE_READER                \
+  0x9B496CE1L, 0x811B, 0x11cf, 0x8C, 0x77, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
+DEFINE_GUIDSTRUCT("9B496CE1-811B-11cf-8C77-00AA006B6814", PROPSETID_TIMECODE_READER);
+  #  define PROPSETID_TIMECODE_READER DEFINE_GUIDNAMED(PROPSETID_TIMECODE_READER)
+
+typedef enum
+{
+  KSPROPERTY_TIMECODE_READER,
+  KSPROPERTY_ATN_READER,
+  KSPROPERTY_RTC_READER
+}KSPROPERTY_TIMECODE;
+
+  #  ifndef TIMECODE_DEFINED
+   #   define TIMECODE_DEFINED
+typedef union _timecode
+{
+  struct
+  {
+    WORD wFrameRate;
+    WORD wFrameFract;
+    DWORD dwFrames;
+  };
+  DWORDLONG qw;
+}TIMECODE;
+typedef TIMECODE* PTIMECODE;
+
+typedef struct tagTIMECODE_SAMPLE
+{
+  LONGLONG qwTick;
+  TIMECODE timecode;
+  DWORD dwUser;
+  DWORD dwFlags;
+}TIMECODE_SAMPLE;
+
+typedef TIMECODE_SAMPLE* PTIMECODE_SAMPLE;
+  #  endif /* TIMECODE_DEFINED */
+
+typedef struct
+{
+  KSPROPERTY Property;
+  TIMECODE_SAMPLE TimecodeSamp;
+}KSPROPERTY_TIMECODE_S, * PKSPROPERTY_TIMECODE_S;
+
+typedef struct
+{
+  KSP_NODE NodeProperty;
+  TIMECODE_SAMPLE TimecodeSamp;
+}KSPROPERTY_TIMECODE_NODE_S, * PKSPROPERTY_TIMECODE_NODE_S;
+
+  #  define STATIC_KSEVENTSETID_EXTDEV_Command              \
+  0x109c7988L, 0xb3cb, 0x11d2, 0xb4, 0x8e, 0x00, 0x60, 0x97, 0xb3, 0x39, 0x1b
+DEFINE_GUIDSTRUCT("109c7988-b3cb-11d2-b48e-006097b3391b", KSEVENTSETID_EXTDEV_Command);
+  #  define KSEVENTSETID_EXTDEV_Command DEFINE_GUIDNAMED(KSEVENTSETID_EXTDEV_Command)
+
+typedef enum
+{
+  KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,
+  KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,
+  KSEVENT_EXTDEV_COMMAND_BUSRESET,
+  KSEVENT_EXTDEV_TIMECODE_UPDATE,
+  KSEVENT_EXTDEV_OPERATION_MODE_UPDATE,
+  KSEVENT_EXTDEV_TRANSPORT_STATE_UPDATE,
+  KSEVENT_EXTDEV_NOTIFY_REMOVAL,
+  KSEVENT_EXTDEV_NOTIFY_MEDIUM_CHANGE
+}KSEVENT_DEVCMD;
+ # endif /* __EDevCtrl__ */
+
+ # define STATIC_PROPSETID_VIDCAP_CROSSBAR                \
+  0x6a2e0640L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("6a2e0640-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_CROSSBAR);
+ # define PROPSETID_VIDCAP_CROSSBAR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CROSSBAR)
+
+typedef enum
+{
+  KSPROPERTY_CROSSBAR_CAPS,
+  KSPROPERTY_CROSSBAR_PININFO,
+  KSPROPERTY_CROSSBAR_CAN_ROUTE,
+  KSPROPERTY_CROSSBAR_ROUTE
+}KSPROPERTY_VIDCAP_CROSSBAR;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG NumberOfInputs;
+  ULONG NumberOfOutputs;
+}KSPROPERTY_CROSSBAR_CAPS_S, * PKSPROPERTY_CROSSBAR_CAPS_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  KSPIN_DATAFLOW Direction;
+  ULONG Index;
+  ULONG PinType;
+  ULONG RelatedPinIndex;
+  KSPIN_MEDIUM Medium;
+}KSPROPERTY_CROSSBAR_PININFO_S, * PKSPROPERTY_CROSSBAR_PININFO_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG IndexInputPin;
+  ULONG IndexOutputPin;
+  ULONG CanRoute;
+}KSPROPERTY_CROSSBAR_ROUTE_S, * PKSPROPERTY_CROSSBAR_ROUTE_S;
+
+ # define STATIC_EVENTSETID_CROSSBAR                  \
+  0x6a2e0641L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("6a2e0641-28e4-11d0-a18c-00a0c9118956", EVENTSETID_CROSSBAR);
+ # define EVENTSETID_CROSSBAR DEFINE_GUIDNAMED(EVENTSETID_CROSSBAR)
+
+typedef enum
+{
+  KSEVENT_CROSSBAR_CHANGED
+}KSEVENT_CROSSBAR;
+
+typedef enum
+{
+  KS_PhysConn_Video_Tuner = 1,
+  KS_PhysConn_Video_Composite,
+  KS_PhysConn_Video_SVideo,
+  KS_PhysConn_Video_RGB,
+  KS_PhysConn_Video_YRYBY,
+  KS_PhysConn_Video_SerialDigital,
+  KS_PhysConn_Video_ParallelDigital,
+  KS_PhysConn_Video_SCSI,
+  KS_PhysConn_Video_AUX,
+  KS_PhysConn_Video_1394,
+  KS_PhysConn_Video_USB,
+  KS_PhysConn_Video_VideoDecoder,
+  KS_PhysConn_Video_VideoEncoder,
+  KS_PhysConn_Video_SCART,
+  KS_PhysConn_Audio_Tuner = 4096,
+  KS_PhysConn_Audio_Line,
+  KS_PhysConn_Audio_Mic,
+  KS_PhysConn_Audio_AESDigital,
+  KS_PhysConn_Audio_SPDIFDigital,
+  KS_PhysConn_Audio_SCSI,
+  KS_PhysConn_Audio_AUX,
+  KS_PhysConn_Audio_1394,
+  KS_PhysConn_Audio_USB,
+  KS_PhysConn_Audio_AudioDecoder
+}KS_PhysicalConnectorType;
+
+ # define STATIC_PROPSETID_VIDCAP_TVAUDIO                 \
+  0x6a2e0650L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("6a2e0650-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_TVAUDIO);
+ # define PROPSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(PROPSETID_VIDCAP_TVAUDIO)
+
+typedef enum
+{
+  KSPROPERTY_TVAUDIO_CAPS,
+  KSPROPERTY_TVAUDIO_MODE,
+  KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES
+}KSPROPERTY_VIDCAP_TVAUDIO;
+
+ # define KS_TVAUDIO_MODE_MONO 0x0001
+ # define KS_TVAUDIO_MODE_STEREO 0x0002
+ # define KS_TVAUDIO_MODE_LANG_A 0x0010
+ # define KS_TVAUDIO_MODE_LANG_B 0x0020
+ # define KS_TVAUDIO_MODE_LANG_C 0x0040
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG Capabilities;
+  KSPIN_MEDIUM InputMedium;
+  KSPIN_MEDIUM OutputMedium;
+}KSPROPERTY_TVAUDIO_CAPS_S, * PKSPROPERTY_TVAUDIO_CAPS_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG Mode;
+}KSPROPERTY_TVAUDIO_S, * PKSPROPERTY_TVAUDIO_S;
+
+ # define STATIC_KSEVENTSETID_VIDCAP_TVAUDIO              \
+  0x6a2e0651L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("6a2e0651-28e4-11d0-a18c-00a0c9118956", KSEVENTSETID_VIDCAP_TVAUDIO);
+ # define KSEVENTSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAP_TVAUDIO)
+
+typedef enum
+{
+  KSEVENT_TVAUDIO_CHANGED
+}KSEVENT_TVAUDIO;
+
+ # define STATIC_PROPSETID_VIDCAP_VIDEOCOMPRESSION            \
+  0xC6E13343L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("C6E13343-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOCOMPRESSION);
+ # define PROPSETID_VIDCAP_VIDEOCOMPRESSION DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCOMPRESSION)
+
+typedef enum
+{
+  KSPROPERTY_VIDEOCOMPRESSION_GETINFO,
+  KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,
+  KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME,
+  KSPROPERTY_VIDEOCOMPRESSION_QUALITY,
+  KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_KEYFRAME,
+  KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_FRAME_SIZE,
+  KSPROPERTY_VIDEOCOMPRESSION_WINDOWSIZE
+}KSPROPERTY_VIDCAP_VIDEOCOMPRESSION;
+
+typedef enum
+{
+  KS_CompressionCaps_CanQuality = 1,
+  KS_CompressionCaps_CanCrunch = 2,
+  KS_CompressionCaps_CanKeyFrame = 4,
+  KS_CompressionCaps_CanBFrame = 8,
+  KS_CompressionCaps_CanWindow = 0x10
+}KS_CompressionCaps;
+
+typedef enum
+{
+  KS_StreamingHint_FrameInterval = 0x0100,
+  KS_StreamingHint_KeyFrameRate = 0x0200,
+  KS_StreamingHint_PFrameRate = 0x0400,
+  KS_StreamingHint_CompQuality = 0x0800,
+  KS_StreamingHint_CompWindowSize = 0x1000
+}KS_VideoStreamingHints;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG StreamIndex;
+  LONG DefaultKeyFrameRate;
+  LONG DefaultPFrameRate;
+  LONG DefaultQuality;
+  LONG NumberOfQualitySettings;
+  LONG Capabilities;
+}KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S, * PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG StreamIndex;
+  LONG Value;
+}KSPROPERTY_VIDEOCOMPRESSION_S, * PKSPROPERTY_VIDEOCOMPRESSION_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG StreamIndex;
+  LONG Value;
+  ULONG Flags;
+}KSPROPERTY_VIDEOCOMPRESSION_S1, * PKSPROPERTY_VIDEOCOMPRESSION_S1;
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_OVERLAY             \
+  0xe436eb7fL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
+DEFINE_GUIDSTRUCT("e436eb7f-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_OVERLAY);
+ # define KSDATAFORMAT_SUBTYPE_OVERLAY DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_OVERLAY)
+
+ # define STATIC_KSPROPSETID_OverlayUpdate                \
+  0x490EA5CFL, 0x7681, 0x11D1, 0xA2, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("490EA5CF-7681-11D1-A21C-00A0C9223196", KSPROPSETID_OverlayUpdate);
+ # define KSPROPSETID_OverlayUpdate DEFINE_GUIDNAMED(KSPROPSETID_OverlayUpdate)
+
+typedef enum
+{
+  KSPROPERTY_OVERLAYUPDATE_INTERESTS,
+  KSPROPERTY_OVERLAYUPDATE_CLIPLIST = 0x1,
+  KSPROPERTY_OVERLAYUPDATE_PALETTE = 0x2,
+  KSPROPERTY_OVERLAYUPDATE_COLORKEY = 0x4,
+  KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION = 0x8,
+  KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE = 0x10,
+  KSPROPERTY_OVERLAYUPDATE_COLORREF = 0x10000000
+}KSPROPERTY_OVERLAYUPDATE;
+
+typedef struct
+{
+  ULONG PelsWidth;
+  ULONG PelsHeight;
+  ULONG BitsPerPel;
+  WCHAR DeviceID[1];
+}KSDISPLAYCHANGE, * PKSDISPLAYCHANGE;
+
+ # define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_INTERESTS(Handler)     \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_OVERLAYUPDATE_INTERESTS, \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(ULONG),              \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_PALETTE(Handler)       \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_OVERLAYUPDATE_PALETTE,   \
+    NULL,                   \
+    sizeof(KSPROPERTY),         \
+    0,                  \
+    (Handler),              \
+    NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORKEY(Handler)      \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_OVERLAYUPDATE_COLORKEY,  \
+    NULL,                   \
+    sizeof(KSPROPERTY),         \
+    sizeof(COLORKEY),           \
+    (Handler),              \
+    NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_CLIPLIST(Handler)      \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_OVERLAYUPDATE_CLIPLIST,  \
+    NULL,                   \
+    sizeof(KSPROPERTY),         \
+    2 * sizeof(RECT) + sizeof(RGNDATAHEADER), \
+    (Handler),              \
+    NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_VIDEOPOSITION(Handler) \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION, \
+    NULL,                   \
+    sizeof(KSPROPERTY),         \
+    2 * sizeof(RECT),            \
+    (Handler),              \
+    NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_DISPLAYCHANGE(Handler) \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE, \
+    NULL,                   \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSDISPLAYCHANGE),        \
+    (Handler),              \
+    NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORREF(Handler)      \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_OVERLAYUPDATE_COLORREF,  \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(COLORREF),           \
+    NULL,                   \
+    NULL, 0, NULL, NULL, 0)
+
+ # define STATIC_PROPSETID_VIDCAP_VIDEOCONTROL                \
+  0x6a2e0670L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("6a2e0670-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOCONTROL);
+ # define PROPSETID_VIDCAP_VIDEOCONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCONTROL)
+
+typedef enum
+{
+  KSPROPERTY_VIDEOCONTROL_CAPS,
+  KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,
+  KSPROPERTY_VIDEOCONTROL_FRAME_RATES,
+  KSPROPERTY_VIDEOCONTROL_MODE
+}KSPROPERTY_VIDCAP_VIDEOCONTROL;
+
+typedef enum
+{
+  KS_VideoControlFlag_FlipHorizontal = 0x0001,
+  KS_VideoControlFlag_FlipVertical = 0x0002,
+  KS_Obsolete_VideoControlFlag_ExternalTriggerEnable = 0x0010,
+  KS_Obsolete_VideoControlFlag_Trigger = 0x0020,
+  KS_VideoControlFlag_ExternalTriggerEnable = 0x0004,
+  KS_VideoControlFlag_Trigger = 0x0008
+}KS_VideoControlFlags;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG StreamIndex;
+  ULONG VideoControlCaps;
+}KSPROPERTY_VIDEOCONTROL_CAPS_S, * PKSPROPERTY_VIDEOCONTROL_CAPS_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG StreamIndex;
+  LONG Mode;
+}KSPROPERTY_VIDEOCONTROL_MODE_S, * PKSPROPERTY_VIDEOCONTROL_MODE_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG StreamIndex;
+  ULONG RangeIndex;
+  SIZE Dimensions;
+  LONGLONG CurrentActualFrameRate;
+  LONGLONG CurrentMaxAvailableFrameRate;
+}KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S, * PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG StreamIndex;
+  ULONG RangeIndex;
+  SIZE Dimensions;
+}KSPROPERTY_VIDEOCONTROL_FRAME_RATES_S, * PKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S;
+
+ # define STATIC_PROPSETID_VIDCAP_DROPPEDFRAMES               \
+  0xC6E13344L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
+DEFINE_GUIDSTRUCT("C6E13344-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_DROPPEDFRAMES);
+ # define PROPSETID_VIDCAP_DROPPEDFRAMES DEFINE_GUIDNAMED(PROPSETID_VIDCAP_DROPPEDFRAMES)
+
+typedef enum
+{
+  KSPROPERTY_DROPPEDFRAMES_CURRENT
+}KSPROPERTY_VIDCAP_DROPPEDFRAMES;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  LONGLONG PictureNumber;
+  LONGLONG DropCount;
+  ULONG AverageFrameSize;
+}KSPROPERTY_DROPPEDFRAMES_CURRENT_S, * PKSPROPERTY_DROPPEDFRAMES_CURRENT_S;
+
+ # define STATIC_KSPROPSETID_VPConfig                 \
+  0xbc29a660L, 0x30e3, 0x11d0, 0x9e, 0x69, 0x00, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b
+DEFINE_GUIDSTRUCT("bc29a660-30e3-11d0-9e69-00c04fd7c15b", KSPROPSETID_VPConfig);
+ # define KSPROPSETID_VPConfig DEFINE_GUIDNAMED(KSPROPSETID_VPConfig)
+
+ # define STATIC_KSPROPSETID_VPVBIConfig                  \
+  0xec529b00L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
+DEFINE_GUIDSTRUCT("ec529b00-1a1f-11d1-bad9-00609744111a", KSPROPSETID_VPVBIConfig);
+ # define KSPROPSETID_VPVBIConfig DEFINE_GUIDNAMED(KSPROPSETID_VPVBIConfig)
+
+typedef enum
+{
+  KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
+  KSPROPERTY_VPCONFIG_GETCONNECTINFO,
+  KSPROPERTY_VPCONFIG_SETCONNECTINFO,
+  KSPROPERTY_VPCONFIG_VPDATAINFO,
+  KSPROPERTY_VPCONFIG_MAXPIXELRATE,
+  KSPROPERTY_VPCONFIG_INFORMVPINPUT,
+  KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
+  KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
+  KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
+  KSPROPERTY_VPCONFIG_INVERTPOLARITY,
+  KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,
+  KSPROPERTY_VPCONFIG_SCALEFACTOR,
+  KSPROPERTY_VPCONFIG_DDRAWHANDLE,
+  KSPROPERTY_VPCONFIG_VIDEOPORTID,
+  KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
+  KSPROPERTY_VPCONFIG_SURFACEPARAMS
+}KSPROPERTY_VPCONFIG;
+
+ # define STATIC_CLSID_KsIBasicAudioInterfaceHandler          \
+  0xb9f8ac3e, 0x0f71, 0x11d2, 0xb7, 0x2c, 0x00, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d
+DEFINE_GUIDSTRUCT("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d", CLSID_KsIBasicAudioInterfaceHandler);
+ # define CLSID_KsIBasicAudioInterfaceHandler DEFINE_GUIDNAMED(CLSID_KsIBasicAudioInterfaceHandler)
+
+ # ifdef __IVPType__
+typedef struct
+{
+  AMVPSIZE Size;
+  DWORD MaxPixelsPerSecond;
+  DWORD Reserved;
+}KSVPMAXPIXELRATE, * PKSVPMAXPIXELRATE;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  AMVPSIZE Size;
+}KSVPSIZE_PROP, * PKSVPSIZE_PROP;
+
+typedef struct
+{
+  DWORD dwPitch;
+  DWORD dwXOrigin;
+  DWORD dwYOrigin;
+}KSVPSURFACEPARAMS, * PKSVPSURFACEPARAMS;
+ # else /* __IVPType__ */
+
+  #  ifndef __DDRAW_INCLUDED__
+   #   define DDPF_FOURCC 0x00000004l
+
+typedef struct _DDPIXELFORMAT
+{
+  DWORD dwSize;
+  DWORD dwFlags;
+  DWORD dwFourCC;
+  __MINGW_EXTENSION union
+  {
+    DWORD dwRGBBitCount;
+    DWORD dwYUVBitCount;
+    DWORD dwZBufferBitDepth;
+    DWORD dwAlphaBitDepth;
+  };
+  __MINGW_EXTENSION union
+  {
+    DWORD dwRBitMask;
+    DWORD dwYBitMask;
+  };
+  __MINGW_EXTENSION union
+  {
+    DWORD dwGBitMask;
+    DWORD dwUBitMask;
+  };
+  __MINGW_EXTENSION union
+  {
+    DWORD dwBBitMask;
+    DWORD dwVBitMask;
+  };
+  __MINGW_EXTENSION union
+  {
+    DWORD dwRGBAlphaBitMask;
+    DWORD dwYUVAlphaBitMask;
+    DWORD dwRGBZBitMask;
+    DWORD dwYUVZBitMask;
+  };
+}DDPIXELFORMAT, * LPDDPIXELFORMAT;
+  #  endif /* __DDRAW_INCLUDED__ */
+
+  #  ifndef __DVP_INCLUDED__
+typedef struct _DDVIDEOPORTCONNECT
+{
+  DWORD dwSize;
+  DWORD dwPortWidth;
+  GUID guidTypeID;
+  DWORD dwFlags;
+  ULONG_PTR dwReserved1;
+}DDVIDEOPORTCONNECT, * LPDDVIDEOPORTCONNECT;
+
+   #   define DDVPTYPE_E_HREFH_VREFH                      \
+  0x54F39980L, 0xDA60, 0x11CF, 0x9B, 0x06, 0x00, 0xA0, 0xC9, 0x03, 0xA3, 0xB8
+
+   #   define DDVPTYPE_E_HREFL_VREFL                      \
+  0xE09C77E0L, 0xDA60, 0x11CF, 0x9B, 0x06, 0x00, 0xA0, 0xC9, 0x03, 0xA3, 0xB8
+  #  endif /* __DVP_INCLUDED__ */
+
+typedef enum
+{
+  KS_PixAspectRatio_NTSC4x3,
+  KS_PixAspectRatio_NTSC16x9,
+  KS_PixAspectRatio_PAL4x3,
+  KS_PixAspectRatio_PAL16x9
+}KS_AMPixAspectRatio;
+
+typedef enum
+{
+  KS_AMVP_DO_NOT_CARE,
+  KS_AMVP_BEST_BANDWIDTH,
+  KS_AMVP_INPUT_SAME_AS_OUTPUT
+}KS_AMVP_SELECTFORMATBY;
+
+typedef enum
+{
+  KS_AMVP_MODE_WEAVE,
+  KS_AMVP_MODE_BOBINTERLEAVED,
+  KS_AMVP_MODE_BOBNONINTERLEAVED,
+  KS_AMVP_MODE_SKIPEVEN,
+  KS_AMVP_MODE_SKIPODD
+}KS_AMVP_MODE;
+
+typedef struct tagKS_AMVPDIMINFO
+{
+  DWORD dwFieldWidth;
+  DWORD dwFieldHeight;
+  DWORD dwVBIWidth;
+  DWORD dwVBIHeight;
+  RECT rcValidRegion;
+}KS_AMVPDIMINFO, * PKS_AMVPDIMINFO;
+
+typedef struct tagKS_AMVPDATAINFO
+{
+  DWORD dwSize;
+  DWORD dwMicrosecondsPerField;
+  KS_AMVPDIMINFO amvpDimInfo;
+  DWORD dwPictAspectRatioX;
+  DWORD dwPictAspectRatioY;
+  WINBOOL bEnableDoubleClock;
+  WINBOOL bEnableVACT;
+  WINBOOL bDataIsInterlaced;
+  LONG lHalfLinesOdd;
+  WINBOOL bFieldPolarityInverted;
+  DWORD dwNumLinesInVREF;
+  LONG lHalfLinesEven;
+  DWORD dwReserved1;
+}KS_AMVPDATAINFO, * PKS_AMVPDATAINFO;
+
+typedef struct tagKS_AMVPSIZE
+{
+  DWORD dwWidth;
+  DWORD dwHeight;
+}KS_AMVPSIZE, * PKS_AMVPSIZE;
+
+typedef struct
+{
+  KS_AMVPSIZE Size;
+  DWORD MaxPixelsPerSecond;
+  DWORD Reserved;
+}KSVPMAXPIXELRATE, * PKSVPMAXPIXELRATE;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  KS_AMVPSIZE Size;
+}KSVPSIZE_PROP, * PKSVPSIZE_PROP;
+
+typedef struct
+{
+  DWORD dwPitch;
+  DWORD dwXOrigin;
+  DWORD dwYOrigin;
+}KSVPSURFACEPARAMS, * PKSVPSURFACEPARAMS;
+ # endif /* __IVPType__ */
+
+ # define STATIC_KSEVENTSETID_VPNotify                    \
+  0x20c5598eL, 0xd3c8, 0x11d0, 0x8d, 0xfc, 0x00, 0xc0, 0x4f, 0xd7, 0xc0, 0x8b
+DEFINE_GUIDSTRUCT("20c5598e-d3c8-11d0-8dfc-00c04fd7c08b", KSEVENTSETID_VPNotify);
+ # define KSEVENTSETID_VPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VPNotify)
+
+typedef enum
+{
+  KSEVENT_VPNOTIFY_FORMATCHANGE
+}KSEVENT_VPNOTIFY;
+
+ # define STATIC_KSEVENTSETID_VIDCAPTOSTI                 \
+  0xdb47de20, 0xf628, 0x11d1, 0xba, 0x41, 0x0, 0xa0, 0xc9, 0xd, 0x2b, 0x5
+DEFINE_GUIDSTRUCT("DB47DE20-F628-11d1-BA41-00A0C90D2B05", KSEVENTSETID_VIDCAPTOSTI);
+ # define KSEVENTSETID_VIDCAPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAPTOSTI)
+
+typedef enum
+{
+  KSEVENT_VIDCAPTOSTI_EXT_TRIGGER,
+  KSEVENT_VIDCAP_AUTO_UPDATE,
+  KSEVENT_VIDCAP_SEARCH
+}KSEVENT_VIDCAPTOSTI;
+
+typedef enum
+{
+  KSPROPERTY_EXTENSION_UNIT_INFO,
+  KSPROPERTY_EXTENSION_UNIT_CONTROL,
+  KSPROPERTY_EXTENSION_UNIT_PASS_THROUGH = 0xffff
+}KSPROPERTY_EXTENSION_UNIT, * PKSPROPERTY_EXTENSION_UNIT;
+
+ # define STATIC_KSEVENTSETID_VPVBINotify                 \
+  0xec529b01L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
+DEFINE_GUIDSTRUCT("ec529b01-1a1f-11d1-bad9-00609744111a", KSEVENTSETID_VPVBINotify);
+ # define KSEVENTSETID_VPVBINotify DEFINE_GUIDNAMED(KSEVENTSETID_VPVBINotify)
+
+typedef enum
+{
+  KSEVENT_VPVBINOTIFY_FORMATCHANGE
+}KSEVENT_VPVBINOTIFY;
+
+ # define STATIC_KSDATAFORMAT_TYPE_AUXLine21Data              \
+  0x670aea80L, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
+DEFINE_GUIDSTRUCT("670aea80-3a82-11d0-b79b-00aa003767a7", KSDATAFORMAT_TYPE_AUXLine21Data);
+ # define KSDATAFORMAT_TYPE_AUXLine21Data DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUXLine21Data)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_Line21_BytePair         \
+  0x6e8d4a22L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
+DEFINE_GUIDSTRUCT("6e8d4a22-310c-11d0-b79a-00aa003767a7", KSDATAFORMAT_SUBTYPE_Line21_BytePair);
+ # define KSDATAFORMAT_SUBTYPE_Line21_BytePair DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_BytePair)
+
+ # define STATIC_KSDATAFORMAT_SUBTYPE_Line21_GOPPacket            \
+  0x6e8d4a23L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
+DEFINE_GUIDSTRUCT("6e8d4a23-310c-11d0-b79a-00aa003767a7", KSDATAFORMAT_SUBTYPE_Line21_GOPPacket);
+ # define KSDATAFORMAT_SUBTYPE_Line21_GOPPacket DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_GOPPacket)
+
+typedef struct _KSGOP_USERDATA
+{
+  ULONG sc;
+  ULONG reserved1;
+  BYTE cFields;
+  CHAR l21Data[3];
+}KSGOP_USERDATA, * PKSGOP_USERDATA;
+
+ # define STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK         \
+  0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x4f, 0xc3, 0x1d, 0x60
+DEFINE_GUIDSTRUCT("ed0b916a-044d-11d1-aa78-00c04fc31d60", KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK);
+ # define KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK)
+
+ # define KS_AM_UseNewCSSKey 0x1
+
+ # define STATIC_KSPROPSETID_TSRateChange                 \
+  0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0
+DEFINE_GUIDSTRUCT("A503C5C0-1D1D-11D1-AD80-444553540000", KSPROPSETID_TSRateChange);
+ # define KSPROPSETID_TSRateChange DEFINE_GUIDNAMED(KSPROPSETID_TSRateChange)
+
+typedef enum
+{
+  KS_AM_RATE_SimpleRateChange = 1,
+  KS_AM_RATE_ExactRateChange = 2,
+  KS_AM_RATE_MaxFullDataRate = 3,
+  KS_AM_RATE_Step = 4
+}KS_AM_PROPERTY_TS_RATE_CHANGE;
+
+typedef struct
+{
+  REFERENCE_TIME StartTime;
+  LONG Rate;
+}KS_AM_SimpleRateChange, * PKS_AM_SimpleRateChange;
+
+typedef struct
+{
+  REFERENCE_TIME OutputZeroTime;
+  LONG Rate;
+}KS_AM_ExactRateChange, * PKS_AM_ExactRateChange;
+
+typedef LONG KS_AM_MaxFullDataRate;
+typedef DWORD KS_AM_Step;
+
+ # define STATIC_KSCATEGORY_ENCODER                   \
+  0x19689bf6, 0xc384, 0x48fd, 0xad, 0x51, 0x90, 0xe5, 0x8c, 0x79, 0xf7, 0xb
+DEFINE_GUIDSTRUCT("19689BF6-C384-48fd-AD51-90E58C79F70B", KSCATEGORY_ENCODER);
+ # define KSCATEGORY_ENCODER DEFINE_GUIDNAMED(KSCATEGORY_ENCODER)
+
+ # define STATIC_KSCATEGORY_MULTIPLEXER                   \
+  0x7a5de1d3, 0x1a1, 0x452c, 0xb4, 0x81, 0x4f, 0xa2, 0xb9, 0x62, 0x71, 0xe8
+DEFINE_GUIDSTRUCT("7A5DE1D3-01A1-452c-B481-4FA2B96271E8", KSCATEGORY_MULTIPLEXER);
+ # define KSCATEGORY_MULTIPLEXER DEFINE_GUIDNAMED(KSCATEGORY_MULTIPLEXER)
+
+ # ifndef __ENCODER_API_GUIDS__
+  #  define __ENCODER_API_GUIDS__
+
+  #  define STATIC_ENCAPIPARAM_BITRATE                  \
+  0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf
+DEFINE_GUIDSTRUCT("49CC4C43-CA83-4ad4-A9AF-F3696AF666DF", ENCAPIPARAM_BITRATE);
+  #  define ENCAPIPARAM_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE)
+
+  #  define STATIC_ENCAPIPARAM_PEAK_BITRATE                 \
+  0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19
+DEFINE_GUIDSTRUCT("703F16A9-3D48-44a1-B077-018DFF915D19", ENCAPIPARAM_PEAK_BITRATE);
+  #  define ENCAPIPARAM_PEAK_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_PEAK_BITRATE)
+
+  #  define STATIC_ENCAPIPARAM_BITRATE_MODE                 \
+  0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf
+DEFINE_GUIDSTRUCT("EE5FB25C-C713-40d1-9D58-C0D7241E250F", ENCAPIPARAM_BITRATE_MODE);
+  #  define ENCAPIPARAM_BITRATE_MODE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE_MODE)
+
+  #  define STATIC_CODECAPI_CHANGELISTS                 \
+  0x62b12acf, 0xf6b0, 0x47d9, 0x94, 0x56, 0x96, 0xf2, 0x2c, 0x4e, 0x0b, 0x9d
+DEFINE_GUIDSTRUCT("62B12ACF-F6B0-47D9-9456-96F22C4E0B9D", CODECAPI_CHANGELISTS);
+  #  define CODECAPI_CHANGELISTS DEFINE_GUIDNAMED(CODECAPI_CHANGELISTS)
+
+  #  define STATIC_CODECAPI_VIDEO_ENCODER                   \
+  0x7112e8e1, 0x3d03, 0x47ef, 0x8e, 0x60, 0x03, 0xf1, 0xcf, 0x53, 0x73, 0x01
+DEFINE_GUIDSTRUCT("7112E8E1-3D03-47EF-8E60-03F1CF537301", CODECAPI_VIDEO_ENCODER);
+  #  define CODECAPI_VIDEO_ENCODER DEFINE_GUIDNAMED(CODECAPI_VIDEO_ENCODER)
+
+  #  define STATIC_CODECAPI_AUDIO_ENCODER                   \
+  0xb9d19a3e, 0xf897, 0x429c, 0xbc, 0x46, 0x81, 0x38, 0xb7, 0x27, 0x2b, 0x2d
+DEFINE_GUIDSTRUCT("B9D19A3E-F897-429C-BC46-8138B7272B2D", CODECAPI_AUDIO_ENCODER);
+  #  define CODECAPI_AUDIO_ENCODER DEFINE_GUIDNAMED(CODECAPI_AUDIO_ENCODER)
+
+  #  define STATIC_CODECAPI_SETALLDEFAULTS                  \
+  0x6c5e6a7c, 0xacf8, 0x4f55, 0xa9, 0x99, 0x1a, 0x62, 0x81, 0x09, 0x05, 0x1b
+DEFINE_GUIDSTRUCT("6C5E6A7C-ACF8-4F55-A999-1A628109051B", CODECAPI_SETALLDEFAULTS);
+  #  define CODECAPI_SETALLDEFAULTS DEFINE_GUIDNAMED(CODECAPI_SETALLDEFAULTS)
+
+  #  define STATIC_CODECAPI_ALLSETTINGS                 \
+  0x6a577e92, 0x83e1, 0x4113, 0xad, 0xc2, 0x4f, 0xce, 0xc3, 0x2f, 0x83, 0xa1
+DEFINE_GUIDSTRUCT("6A577E92-83E1-4113-ADC2-4FCEC32F83A1", CODECAPI_ALLSETTINGS);
+  #  define CODECAPI_ALLSETTINGS DEFINE_GUIDNAMED(CODECAPI_ALLSETTINGS)
+
+  #  define STATIC_CODECAPI_SUPPORTSEVENTS                  \
+  0x0581af97, 0x7693, 0x4dbd, 0x9d, 0xca, 0x3f, 0x9e, 0xbd, 0x65, 0x85, 0xa1
+DEFINE_GUIDSTRUCT("0581AF97-7693-4DBD-9DCA-3F9EBD6585A1", CODECAPI_SUPPORTSEVENTS);
+  #  define CODECAPI_SUPPORTSEVENTS DEFINE_GUIDNAMED(CODECAPI_SUPPORTSEVENTS)
+
+  #  define STATIC_CODECAPI_CURRENTCHANGELIST               \
+  0x1cb14e83, 0x7d72, 0x4657, 0x83, 0xfd, 0x47, 0xa2, 0xc5, 0xb9, 0xd1, 0x3d
+DEFINE_GUIDSTRUCT("1CB14E83-7D72-4657-83FD-47A2C5B9D13D", CODECAPI_CURRENTCHANGELIST);
+  #  define CODECAPI_CURRENTCHANGELIST DEFINE_GUIDNAMED(CODECAPI_CURRENTCHANGELIST)
+ # endif /* __ENCODER_API_GUIDS__ */
+
+ # ifndef __ENCODER_API_DEFINES__
+  #  define __ENCODER_API_DEFINES__
+typedef enum
+{
+  ConstantBitRate = 0,
+  VariableBitRateAverage,
+  VariableBitRatePeak
+}VIDEOENCODER_BITRATE_MODE;
+ # endif /* __ENCODER_API_DEFINES__ */
+
+ # define STATIC_KSPROPSETID_Jack \
+  0x4509f757, 0x2d46, 0x4637, 0x8e, 0x62, 0xce, 0x7d, 0xb9, 0x44, 0xf5, 0x7b
+DEFINE_GUIDSTRUCT("4509F757-2D46-4637-8E62-CE7DB944F57B", KSPROPSETID_Jack);
+ # define KSPROPSETID_Jack DEFINE_GUIDNAMED(KSPROPSETID_Jack)
+
+typedef enum
+{
+  KSPROPERTY_JACK_DESCRIPTION = 1,
+  KSPROPERTY_JACK_DESCRIPTION2,
+  KSPROPERTY_JACK_SINK_INFO
+}KSPROPERTY_JACK;
+
+typedef enum
+{
+  eConnTypeUnknown,
+  eConnType3Point5mm,
+  eConnTypeQuarter,
+  eConnTypeAtapiInternal,
+  eConnTypeRCA,
+  eConnTypeOptical,
+  eConnTypeOtherDigital,
+  eConnTypeOtherAnalog,
+  eConnTypeMultichannelAnalogDIN,
+  eConnTypeXlrProfessional,
+  eConnTypeRJ11Modem,
+  eConnTypeCombination
+}EPcxConnectionType;
+
+typedef enum
+{
+  eGeoLocRear = 0x1,
+  eGeoLocFront,
+  eGeoLocLeft,
+  eGeoLocRight,
+  eGeoLocTop,
+  eGeoLocBottom,
+  eGeoLocRearPanel,
+  eGeoLocRiser,
+  eGeoLocInsideMobileLid,
+  eGeoLocDrivebay,
+  eGeoLocHDMI,
+  eGeoLocOutsideMobileLid,
+  eGeoLocATAPI,
+  eGeoLocReserved5,
+  eGeoLocReserved6,
+  EPcxGeoLocation_enum_count
+}EPcxGeoLocation;
+
+typedef enum
+{
+  eGenLocPrimaryBox = 0,
+  eGenLocInternal,
+  eGenLocSeparate,
+  eGenLocOther,
+  EPcxGenLocation_enum_count
+}EPcxGenLocation;
+
+typedef enum
+{
+  ePortConnJack = 0,
+  ePortConnIntegratedDevice,
+  ePortConnBothIntegratedAndJack,
+  ePortConnUnknown
+}EPxcPortConnection;
+
+typedef struct
+{
+  DWORD ChannelMapping;
+  COLORREF Color;
+  EPcxConnectionType ConnectionType;
+  EPcxGeoLocation GeoLocation;
+  EPcxGenLocation GenLocation;
+  EPxcPortConnection PortConnection;
+  BOOL IsConnected;
+}KSJACK_DESCRIPTION, * PKSJACK_DESCRIPTION;
+
+typedef enum
+{
+  KSJACK_SINK_CONNECTIONTYPE_HDMI = 0,
+  KSJACK_SINK_CONNECTIONTYPE_DISPLAYPORT,
+}KSJACK_SINK_CONNECTIONTYPE;
+
+ # define MAX_SINK_DESCRIPTION_NAME_LENGTH 32
+typedef struct _tagKSJACK_SINK_INFORMATION
+{
+  KSJACK_SINK_CONNECTIONTYPE ConnType;
+  WORD ManufacturerId;
+  WORD ProductId;
+  WORD AudioLatency;
+  BOOL HDCPCapable;
+  BOOL AICapable;
+  UCHAR SinkDescriptionLength;
+  WCHAR SinkDescription[MAX_SINK_DESCRIPTION_NAME_LENGTH];
+  LUID PortId;
+}KSJACK_SINK_INFORMATION, * PKSJACK_SINK_INFORMATION;
+
+ # define JACKDESC2_PRESENCE_DETECT_CAPABILITY 0x00000001
+ # define JACKDESC2_DYNAMIC_FORMAT_CHANGE_CAPABILITY 0x00000002
+
+typedef struct _tagKSJACK_DESCRIPTION2
+{
+  DWORD DeviceStateInfo;
+  DWORD JackCapabilities;
+}KSJACK_DESCRIPTION2, * PKSJACK_DESCRIPTION2;
+
+#endif /* _KSMEDIA_ */
+
--- /dev/null
+++ giada-0.7.2/src/rtmidi/include/ks.h
@@ -0,0 +1,3577 @@
+/**
+ * This file has no copyright assigned and is placed in the Public Domain.
+ * This file is part of the w64 mingw-runtime package.
+ * No warranty is given.
+ */
+#ifndef _KS_
+#define _KS_
+
+#include <winioctl.h>
+
+#if __GNUC__ >= 3
+ # pragma GCC system_header
+#endif
+
+#ifndef __MINGW_EXTENSION
+ # if defined(__GNUC__) || defined(__GNUG__)
+  #  define __MINGW_EXTENSION __extension__
+ # else
+  #  define __MINGW_EXTENSION
+ # endif
+#endif
+
+#ifdef __TCS__
+ # define _KS_NO_ANONYMOUS_STRUCTURES_ 1
+#endif
+
+#ifdef  _KS_NO_ANONYMOUS_STRUCTURES_
+ # define _KS_ANON_STRUCT(X) struct X
+#else
+ # define _KS_ANON_STRUCT(X) __MINGW_EXTENSION struct
+#endif
+
+#ifndef _NTRTL_
+ # ifndef DEFINE_GUIDEX
+  #  define DEFINE_GUIDEX(name) EXTERN_C const GUID name
+ # endif
+ # ifndef STATICGUIDOF
+  #  define STATICGUIDOF(guid) STATIC_ ## guid
+ # endif
+#endif /* _NTRTL_ */
+
+#ifndef SIZEOF_ARRAY
+ # define SIZEOF_ARRAY(ar) (sizeof(ar) / sizeof((ar)[0]))
+#endif
+
+#define DEFINE_GUIDSTRUCT(g, n) DEFINE_GUIDEX(n)
+#define DEFINE_GUIDNAMED(n) n
+
+#define STATIC_GUID_NULL                        \
+  0x00000000L, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
+
+DEFINE_GUIDSTRUCT("00000000-0000-0000-0000-000000000000", GUID_NULL);
+#define GUID_NULL DEFINE_GUIDNAMED(GUID_NULL)
+
+#define IOCTL_KS_PROPERTY CTL_CODE(FILE_DEVICE_KS, 0x000, METHOD_NEITHER, FILE_ANY_ACCESS)
+#define IOCTL_KS_ENABLE_EVENT CTL_CODE(FILE_DEVICE_KS, 0x001, METHOD_NEITHER, FILE_ANY_ACCESS)
+#define IOCTL_KS_DISABLE_EVENT CTL_CODE(FILE_DEVICE_KS, 0x002, METHOD_NEITHER, FILE_ANY_ACCESS)
+#define IOCTL_KS_METHOD CTL_CODE(FILE_DEVICE_KS, 0x003, METHOD_NEITHER, FILE_ANY_ACCESS)
+#define IOCTL_KS_WRITE_STREAM CTL_CODE(FILE_DEVICE_KS, 0x004, METHOD_NEITHER, FILE_WRITE_ACCESS)
+#define IOCTL_KS_READ_STREAM CTL_CODE(FILE_DEVICE_KS, 0x005, METHOD_NEITHER, FILE_READ_ACCESS)
+#define IOCTL_KS_RESET_STATE CTL_CODE(FILE_DEVICE_KS, 0x006, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+typedef enum
+{
+  KSRESET_BEGIN,
+  KSRESET_END
+}KSRESET;
+
+typedef enum
+{
+  KSSTATE_STOP,
+  KSSTATE_ACQUIRE,
+  KSSTATE_PAUSE,
+  KSSTATE_RUN
+}KSSTATE, * PKSSTATE;
+
+#define KSPRIORITY_LOW 0x00000001
+#define KSPRIORITY_NORMAL 0x40000000
+#define KSPRIORITY_HIGH 0x80000000
+#define KSPRIORITY_EXCLUSIVE 0xFFFFFFFF
+
+typedef struct
+{
+  ULONG PriorityClass;
+  ULONG PrioritySubClass;
+}KSPRIORITY, * PKSPRIORITY;
+
+typedef struct
+{
+  __MINGW_EXTENSION union
+  {
+    _KS_ANON_STRUCT(_IDENTIFIER)
+    {
+      GUID Set;
+      ULONG Id;
+      ULONG Flags;
+    };
+    LONGLONG Alignment;
+  };
+}KSIDENTIFIER, * PKSIDENTIFIER;
+
+typedef KSIDENTIFIER KSPROPERTY, * PKSPROPERTY, KSMETHOD, * PKSMETHOD, KSEVENT, * PKSEVENT;
+
+#define KSMETHOD_TYPE_NONE 0x00000000
+#define KSMETHOD_TYPE_READ 0x00000001
+#define KSMETHOD_TYPE_WRITE 0x00000002
+#define KSMETHOD_TYPE_MODIFY 0x00000003
+#define KSMETHOD_TYPE_SOURCE 0x00000004
+
+#define KSMETHOD_TYPE_SEND 0x00000001
+#define KSMETHOD_TYPE_SETSUPPORT 0x00000100
+#define KSMETHOD_TYPE_BASICSUPPORT 0x00000200
+
+#define KSMETHOD_TYPE_TOPOLOGY 0x10000000
+
+#define KSPROPERTY_TYPE_GET 0x00000001
+#define KSPROPERTY_TYPE_SET 0x00000002
+#define KSPROPERTY_TYPE_SETSUPPORT 0x00000100
+#define KSPROPERTY_TYPE_BASICSUPPORT 0x00000200
+#define KSPROPERTY_TYPE_RELATIONS 0x00000400
+#define KSPROPERTY_TYPE_SERIALIZESET 0x00000800
+#define KSPROPERTY_TYPE_UNSERIALIZESET 0x00001000
+#define KSPROPERTY_TYPE_SERIALIZERAW 0x00002000
+#define KSPROPERTY_TYPE_UNSERIALIZERAW 0x00004000
+#define KSPROPERTY_TYPE_SERIALIZESIZE 0x00008000
+#define KSPROPERTY_TYPE_DEFAULTVALUES 0x00010000
+
+#define KSPROPERTY_TYPE_TOPOLOGY 0x10000000
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG NodeId;
+  ULONG Reserved;
+}KSP_NODE, * PKSP_NODE;
+
+typedef struct
+{
+  KSMETHOD Method;
+  ULONG NodeId;
+  ULONG Reserved;
+}KSM_NODE, * PKSM_NODE;
+
+typedef struct
+{
+  KSEVENT Event;
+  ULONG NodeId;
+  ULONG Reserved;
+}KSE_NODE, * PKSE_NODE;
+
+#define STATIC_KSPROPTYPESETID_General                  \
+  0x97E99BA0L, 0xBDEA, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("97E99BA0-BDEA-11CF-A5D6-28DB04C10000", KSPROPTYPESETID_General);
+#define KSPROPTYPESETID_General DEFINE_GUIDNAMED(KSPROPTYPESETID_General)
+
+typedef struct
+{
+  ULONG Size;
+  ULONG Count;
+}KSMULTIPLE_ITEM, * PKSMULTIPLE_ITEM;
+
+typedef struct
+{
+  ULONG AccessFlags;
+  ULONG DescriptionSize;
+  KSIDENTIFIER PropTypeSet;
+  ULONG MembersListCount;
+  ULONG Reserved;
+}KSPROPERTY_DESCRIPTION, * PKSPROPERTY_DESCRIPTION;
+
+#define KSPROPERTY_MEMBER_RANGES 0x00000001
+#define KSPROPERTY_MEMBER_STEPPEDRANGES 0x00000002
+#define KSPROPERTY_MEMBER_VALUES 0x00000003
+
+#define KSPROPERTY_MEMBER_FLAG_DEFAULT 0x00000001
+#define KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL 0x00000002
+#define KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM 0x00000004
+
+typedef struct
+{
+  ULONG MembersFlags;
+  ULONG MembersSize;
+  ULONG MembersCount;
+  ULONG Flags;
+}KSPROPERTY_MEMBERSHEADER, * PKSPROPERTY_MEMBERSHEADER;
+
+typedef union
+{
+  _KS_ANON_STRUCT(_SIGNED)
+  {
+    LONG SignedMinimum;
+    LONG SignedMaximum;
+  };
+  _KS_ANON_STRUCT(_UNSIGNED)
+  {
+    ULONG UnsignedMinimum;
+    ULONG UnsignedMaximum;
+  };
+}KSPROPERTY_BOUNDS_LONG, * PKSPROPERTY_BOUNDS_LONG;
+
+typedef union
+{
+  _KS_ANON_STRUCT(_SIGNED64)
+  {
+    LONGLONG SignedMinimum;
+    LONGLONG SignedMaximum;
+  };
+  _KS_ANON_STRUCT(_UNSIGNED64)
+  {
+    DWORDLONG UnsignedMinimum;
+    DWORDLONG UnsignedMaximum;
+  };
+}KSPROPERTY_BOUNDS_LONGLONG, * PKSPROPERTY_BOUNDS_LONGLONG;
+
+typedef struct
+{
+  ULONG SteppingDelta;
+  ULONG Reserved;
+  KSPROPERTY_BOUNDS_LONG Bounds;
+}KSPROPERTY_STEPPING_LONG, * PKSPROPERTY_STEPPING_LONG;
+
+typedef struct
+{
+  DWORDLONG SteppingDelta;
+  KSPROPERTY_BOUNDS_LONGLONG Bounds;
+}KSPROPERTY_STEPPING_LONGLONG, * PKSPROPERTY_STEPPING_LONGLONG;
+
+#if defined(_NTDDK_)
+typedef struct _KSDEVICE_DESCRIPTOR KSDEVICE_DESCRIPTOR, * PKSDEVICE_DESCRIPTOR;
+typedef struct _KSDEVICE_DISPATCH KSDEVICE_DISPATCH, * PKSDEVICE_DISPATCH;
+typedef struct _KSDEVICE KSDEVICE, * PKSDEVICE;
+typedef struct _KSFILTERFACTORY KSFILTERFACTORY, * PKSFILTERFACTORY;
+typedef struct _KSFILTER_DESCRIPTOR KSFILTER_DESCRIPTOR, * PKSFILTER_DESCRIPTOR;
+typedef struct _KSFILTER_DISPATCH KSFILTER_DISPATCH, * PKSFILTER_DISPATCH;
+typedef struct _KSFILTER KSFILTER, * PKSFILTER;
+typedef struct _KSPIN_DESCRIPTOR_EX KSPIN_DESCRIPTOR_EX, * PKSPIN_DESCRIPTOR_EX;
+typedef struct _KSPIN_DISPATCH KSPIN_DISPATCH, * PKSPIN_DISPATCH;
+typedef struct _KSCLOCK_DISPATCH KSCLOCK_DISPATCH, * PKSCLOCK_DISPATCH;
+typedef struct _KSALLOCATOR_DISPATCH KSALLOCATOR_DISPATCH, * PKSALLOCATOR_DISPATCH;
+typedef struct _KSPIN KSPIN, * PKSPIN;
+typedef struct _KSNODE_DESCRIPTOR KSNODE_DESCRIPTOR, * PKSNODE_DESCRIPTOR;
+typedef struct _KSSTREAM_POINTER_OFFSET KSSTREAM_POINTER_OFFSET, * PKSSTREAM_POINTER_OFFSET;
+typedef struct _KSSTREAM_POINTER KSSTREAM_POINTER, * PKSSTREAM_POINTER;
+typedef struct _KSMAPPING KSMAPPING, * PKSMAPPING;
+typedef struct _KSPROCESSPIN KSPROCESSPIN, * PKSPROCESSPIN;
+typedef struct _KSPROCESSPIN_INDEXENTRY KSPROCESSPIN_INDEXENTRY, * PKSPROCESSPIN_INDEXENTRY;
+#endif /* _NTDDK_ */
+
+typedef PVOID PKSWORKER;
+
+typedef struct
+{
+  ULONG NotificationType;
+  __MINGW_EXTENSION union
+  {
+    struct
+    {
+      HANDLE Event;
+      ULONG_PTR Reserved[2];
+    }EventHandle;
+    struct
+    {
+      HANDLE Semaphore;
+      ULONG Reserved;
+      LONG Adjustment;
+    }SemaphoreHandle;
+#if defined(_NTDDK_)
+    struct
+    {
+      PVOID Event;
+      KPRIORITY Increment;
+      ULONG_PTR Reserved;
+    }EventObject;
+    struct
+    {
+      PVOID Semaphore;
+      KPRIORITY Increment;
+      LONG Adjustment;
+    }SemaphoreObject;
+    struct
+    {
+      PKDPC Dpc;
+      ULONG ReferenceCount;
+      ULONG_PTR Reserved;
+    }Dpc;
+    struct
+    {
+      PWORK_QUEUE_ITEM WorkQueueItem;
+      WORK_QUEUE_TYPE WorkQueueType;
+      ULONG_PTR Reserved;
+    }WorkItem;
+    struct
+    {
+      PWORK_QUEUE_ITEM WorkQueueItem;
+      PKSWORKER KsWorkerObject;
+      ULONG_PTR Reserved;
+    }KsWorkItem;
+#endif /* _NTDDK_ */
+    struct
+    {
+      PVOID Unused;
+      LONG_PTR Alignment[2];
+    }Alignment;
+  };
+}KSEVENTDATA, * PKSEVENTDATA;
+
+#define KSEVENTF_EVENT_HANDLE 0x00000001
+#define KSEVENTF_SEMAPHORE_HANDLE 0x00000002
+#if defined(_NTDDK_)
+ # define KSEVENTF_EVENT_OBJECT 0x00000004
+ # define KSEVENTF_SEMAPHORE_OBJECT 0x00000008
+ # define KSEVENTF_DPC 0x00000010
+ # define KSEVENTF_WORKITEM 0x00000020
+ # define KSEVENTF_KSWORKITEM 0x00000080
+#endif /* _NTDDK_ */
+
+#define KSEVENT_TYPE_ENABLE 0x00000001
+#define KSEVENT_TYPE_ONESHOT 0x00000002
+#define KSEVENT_TYPE_ENABLEBUFFERED 0x00000004
+#define KSEVENT_TYPE_SETSUPPORT 0x00000100
+#define KSEVENT_TYPE_BASICSUPPORT 0x00000200
+#define KSEVENT_TYPE_QUERYBUFFER 0x00000400
+
+#define KSEVENT_TYPE_TOPOLOGY 0x10000000
+
+typedef struct
+{
+  KSEVENT Event;
+  PKSEVENTDATA EventData;
+  PVOID Reserved;
+}KSQUERYBUFFER, * PKSQUERYBUFFER;
+
+typedef struct
+{
+  ULONG Size;
+  ULONG Flags;
+  __MINGW_EXTENSION union
+  {
+    HANDLE ObjectHandle;
+    PVOID ObjectPointer;
+  };
+  PVOID Reserved;
+  KSEVENT Event;
+  KSEVENTDATA EventData;
+}KSRELATIVEEVENT;
+
+#define KSRELATIVEEVENT_FLAG_HANDLE 0x00000001
+#define KSRELATIVEEVENT_FLAG_POINTER 0x00000002
+
+typedef struct
+{
+  KSEVENTDATA EventData;
+  LONGLONG MarkTime;
+}KSEVENT_TIME_MARK, * PKSEVENT_TIME_MARK;
+
+typedef struct
+{
+  KSEVENTDATA EventData;
+  LONGLONG TimeBase;
+  LONGLONG Interval;
+}KSEVENT_TIME_INTERVAL, * PKSEVENT_TIME_INTERVAL;
+
+typedef struct
+{
+  LONGLONG TimeBase;
+  LONGLONG Interval;
+}KSINTERVAL, * PKSINTERVAL;
+
+#define STATIC_KSPROPSETID_General                  \
+  0x1464EDA5L, 0x6A8F, 0x11D1, 0x9A, 0xA7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("1464EDA5-6A8F-11D1-9AA7-00A0C9223196", KSPROPSETID_General);
+#define KSPROPSETID_General DEFINE_GUIDNAMED(KSPROPSETID_General)
+
+typedef enum
+{
+  KSPROPERTY_GENERAL_COMPONENTID
+}KSPROPERTY_GENERAL;
+
+typedef struct
+{
+  GUID Manufacturer;
+  GUID Product;
+  GUID Component;
+  GUID Name;
+  ULONG Version;
+  ULONG Revision;
+}KSCOMPONENTID, * PKSCOMPONENTID;
+
+#define DEFINE_KSPROPERTY_ITEM_GENERAL_COMPONENTID(Handler)     \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_GENERAL_COMPONENTID,     \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSCOMPONENTID),          \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define STATIC_KSMETHODSETID_StreamIo   \
+  0x65D003CAL, 0x1523, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("65D003CA-1523-11D2-B27A-00A0C9223196", KSMETHODSETID_StreamIo);
+#define KSMETHODSETID_StreamIo DEFINE_GUIDNAMED(KSMETHODSETID_StreamIo)
+
+typedef enum
+{
+  KSMETHOD_STREAMIO_READ,
+  KSMETHOD_STREAMIO_WRITE
+}KSMETHOD_STREAMIO;
+
+#define DEFINE_KSMETHOD_ITEM_STREAMIO_READ(Handler)         \
+  DEFINE_KSMETHOD_ITEM(                       \
+    KSMETHOD_STREAMIO_READ,         \
+    KSMETHOD_TYPE_WRITE,            \
+    (Handler),              \
+    sizeof(KSMETHOD),           \
+    0,                  \
+    NULL)
+
+#define DEFINE_KSMETHOD_ITEM_STREAMIO_WRITE(Handler)            \
+  DEFINE_KSMETHOD_ITEM(                       \
+    KSMETHOD_STREAMIO_WRITE,        \
+    KSMETHOD_TYPE_READ,         \
+    (Handler),              \
+    sizeof(KSMETHOD),           \
+    0,                  \
+    NULL)
+
+#define STATIC_KSPROPSETID_MediaSeeking                 \
+  0xEE904F0CL, 0xD09B, 0x11D0, 0xAB, 0xE9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("EE904F0C-D09B-11D0-ABE9-00A0C9223196", KSPROPSETID_MediaSeeking);
+#define KSPROPSETID_MediaSeeking DEFINE_GUIDNAMED(KSPROPSETID_MediaSeeking)
+
+typedef enum
+{
+  KSPROPERTY_MEDIASEEKING_CAPABILITIES,
+  KSPROPERTY_MEDIASEEKING_FORMATS,
+  KSPROPERTY_MEDIASEEKING_TIMEFORMAT,
+  KSPROPERTY_MEDIASEEKING_POSITION,
+  KSPROPERTY_MEDIASEEKING_STOPPOSITION,
+  KSPROPERTY_MEDIASEEKING_POSITIONS,
+  KSPROPERTY_MEDIASEEKING_DURATION,
+  KSPROPERTY_MEDIASEEKING_AVAILABLE,
+  KSPROPERTY_MEDIASEEKING_PREROLL,
+  KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT
+}KSPROPERTY_MEDIASEEKING;
+
+typedef enum
+{
+  KS_SEEKING_NoPositioning,
+  KS_SEEKING_AbsolutePositioning,
+  KS_SEEKING_RelativePositioning,
+  KS_SEEKING_IncrementalPositioning,
+  KS_SEEKING_PositioningBitsMask = 0x3,
+  KS_SEEKING_SeekToKeyFrame,
+  KS_SEEKING_ReturnTime = 0x8
+}KS_SEEKING_FLAGS;
+
+typedef enum
+{
+  KS_SEEKING_CanSeekAbsolute = 0x1,
+  KS_SEEKING_CanSeekForwards = 0x2,
+  KS_SEEKING_CanSeekBackwards = 0x4,
+  KS_SEEKING_CanGetCurrentPos = 0x8,
+  KS_SEEKING_CanGetStopPos = 0x10,
+  KS_SEEKING_CanGetDuration = 0x20,
+  KS_SEEKING_CanPlayBackwards = 0x40
+}KS_SEEKING_CAPABILITIES;
+
+typedef struct
+{
+  LONGLONG Current;
+  LONGLONG Stop;
+  KS_SEEKING_FLAGS CurrentFlags;
+  KS_SEEKING_FLAGS StopFlags;
+}KSPROPERTY_POSITIONS, * PKSPROPERTY_POSITIONS;
+
+typedef struct
+{
+  LONGLONG Earliest;
+  LONGLONG Latest;
+}KSPROPERTY_MEDIAAVAILABLE, * PKSPROPERTY_MEDIAAVAILABLE;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  GUID SourceFormat;
+  GUID TargetFormat;
+  LONGLONG Time;
+}KSP_TIMEFORMAT, * PKSP_TIMEFORMAT;
+
+#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CAPABILITIES(Handler)   \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_MEDIASEEKING_CAPABILITIES,   \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KS_SEEKING_CAPABILITIES),    \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_FORMATS(Handler)        \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_MEDIASEEKING_FORMATS,    \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_TIMEFORMAT(GetHandler, SetHandler) \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_MEDIASEEKING_TIMEFORMAT, \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(GUID),               \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITION(Handler)       \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_MEDIASEEKING_POSITION,   \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(LONGLONG),           \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_STOPPOSITION(Handler)   \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_MEDIASEEKING_STOPPOSITION,   \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(LONGLONG),           \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITIONS(Handler)      \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_MEDIASEEKING_POSITIONS,  \
+    NULL,                   \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSPROPERTY_POSITIONS),       \
+    (Handler),              \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_DURATION(Handler)       \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_MEDIASEEKING_DURATION,   \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(LONGLONG),           \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_AVAILABLE(Handler)      \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_MEDIASEEKING_AVAILABLE,  \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSPROPERTY_MEDIAAVAILABLE),  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_PREROLL(Handler)        \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_MEDIASEEKING_PREROLL,    \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(LONGLONG),           \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CONVERTTIMEFORMAT(Handler)  \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT, \
+    (Handler),              \
+    sizeof(KSP_TIMEFORMAT),         \
+    sizeof(LONGLONG),           \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define STATIC_KSPROPSETID_Topology                 \
+  0x720D4AC0L, 0x7533, 0x11D0, { 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00 }
+DEFINE_GUIDSTRUCT("720D4AC0-7533-11D0-A5D6-28DB04C10000", KSPROPSETID_Topology);
+#define KSPROPSETID_Topology DEFINE_GUIDNAMED(KSPROPSETID_Topology)
+
+typedef enum
+{
+  KSPROPERTY_TOPOLOGY_CATEGORIES,
+  KSPROPERTY_TOPOLOGY_NODES,
+  KSPROPERTY_TOPOLOGY_CONNECTIONS,
+  KSPROPERTY_TOPOLOGY_NAME
+}KSPROPERTY_TOPOLOGY;
+
+#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler)     \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_TOPOLOGY_CATEGORIES,     \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NODES(Handler)          \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_TOPOLOGY_NODES,      \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler)        \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_TOPOLOGY_CONNECTIONS,    \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)           \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_TOPOLOGY_NAME,       \
+    (Handler),              \
+    sizeof(KSP_NODE),           \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_TOPOLOGYSET(TopologySet, Handler)      \
+  DEFINE_KSPROPERTY_TABLE(TopologySet) {                  \
+    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler),        \
+    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NODES(Handler),         \
+    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler),       \
+    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)           \
+  }
+
+#define STATIC_KSCATEGORY_BRIDGE                    \
+  0x085AFF00L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("085AFF00-62CE-11CF-A5D6-28DB04C10000", KSCATEGORY_BRIDGE);
+#define KSCATEGORY_BRIDGE DEFINE_GUIDNAMED(KSCATEGORY_BRIDGE)
+
+#define STATIC_KSCATEGORY_CAPTURE                   \
+  0x65E8773DL, 0x8F56, 0x11D0, { 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96 }
+DEFINE_GUIDSTRUCT("65E8773D-8F56-11D0-A3B9-00A0C9223196", KSCATEGORY_CAPTURE);
+#define KSCATEGORY_CAPTURE DEFINE_GUIDNAMED(KSCATEGORY_CAPTURE)
+
+#define STATIC_KSCATEGORY_RENDER                    \
+  0x65E8773EL, 0x8F56, 0x11D0, { 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96 }
+DEFINE_GUIDSTRUCT("65E8773E-8F56-11D0-A3B9-00A0C9223196", KSCATEGORY_RENDER);
+#define KSCATEGORY_RENDER DEFINE_GUIDNAMED(KSCATEGORY_RENDER)
+
+#define STATIC_KSCATEGORY_MIXER                     \
+  0xAD809C00L, 0x7B88, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("AD809C00-7B88-11D0-A5D6-28DB04C10000", KSCATEGORY_MIXER);
+#define KSCATEGORY_MIXER DEFINE_GUIDNAMED(KSCATEGORY_MIXER)
+
+#define STATIC_KSCATEGORY_SPLITTER                  \
+  0x0A4252A0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("0A4252A0-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_SPLITTER);
+#define KSCATEGORY_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_SPLITTER)
+
+#define STATIC_KSCATEGORY_DATACOMPRESSOR                \
+  0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("1E84C900-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATACOMPRESSOR);
+#define KSCATEGORY_DATACOMPRESSOR DEFINE_GUIDNAMED(KSCATEGORY_DATACOMPRESSOR)
+
+#define STATIC_KSCATEGORY_DATADECOMPRESSOR              \
+  0x2721AE20L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("2721AE20-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATADECOMPRESSOR);
+#define KSCATEGORY_DATADECOMPRESSOR DEFINE_GUIDNAMED(KSCATEGORY_DATADECOMPRESSOR)
+
+#define STATIC_KSCATEGORY_DATATRANSFORM                 \
+  0x2EB07EA0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("2EB07EA0-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATATRANSFORM);
+#define KSCATEGORY_DATATRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_DATATRANSFORM)
+
+#define STATIC_KSCATEGORY_COMMUNICATIONSTRANSFORM           \
+  0xCF1DDA2CL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("CF1DDA2C-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_COMMUNICATIONSTRANSFORM);
+#define KSCATEGORY_COMMUNICATIONSTRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_COMMUNICATIONSTRANSFORM)
+
+#define STATIC_KSCATEGORY_INTERFACETRANSFORM                \
+  0xCF1DDA2DL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("CF1DDA2D-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_INTERFACETRANSFORM);
+#define KSCATEGORY_INTERFACETRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_INTERFACETRANSFORM)
+
+#define STATIC_KSCATEGORY_MEDIUMTRANSFORM               \
+  0xCF1DDA2EL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("CF1DDA2E-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_MEDIUMTRANSFORM);
+#define KSCATEGORY_MEDIUMTRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_MEDIUMTRANSFORM)
+
+#define STATIC_KSCATEGORY_FILESYSTEM                    \
+  0x760FED5EL, 0x9357, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("760FED5E-9357-11D0-A3CC-00A0C9223196", KSCATEGORY_FILESYSTEM);
+#define KSCATEGORY_FILESYSTEM DEFINE_GUIDNAMED(KSCATEGORY_FILESYSTEM)
+
+#define STATIC_KSCATEGORY_CLOCK                     \
+  0x53172480L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000", KSCATEGORY_CLOCK);
+#define KSCATEGORY_CLOCK DEFINE_GUIDNAMED(KSCATEGORY_CLOCK)
+
+#define STATIC_KSCATEGORY_PROXY                     \
+  0x97EBAACAL, 0x95BD, 0x11D0, 0xA3, 0xEA, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("97EBAACA-95BD-11D0-A3EA-00A0C9223196", KSCATEGORY_PROXY);
+#define KSCATEGORY_PROXY DEFINE_GUIDNAMED(KSCATEGORY_PROXY)
+
+#define STATIC_KSCATEGORY_QUALITY                   \
+  0x97EBAACBL, 0x95BD, 0x11D0, 0xA3, 0xEA, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("97EBAACB-95BD-11D0-A3EA-00A0C9223196", KSCATEGORY_QUALITY);
+#define KSCATEGORY_QUALITY DEFINE_GUIDNAMED(KSCATEGORY_QUALITY)
+
+typedef struct
+{
+  ULONG FromNode;
+  ULONG FromNodePin;
+  ULONG ToNode;
+  ULONG ToNodePin;
+}KSTOPOLOGY_CONNECTION, * PKSTOPOLOGY_CONNECTION;
+
+typedef struct
+{
+  ULONG CategoriesCount;
+  const GUID* Categories;
+  ULONG TopologyNodesCount;
+  const GUID* TopologyNodes;
+  ULONG TopologyConnectionsCount;
+  const KSTOPOLOGY_CONNECTION* TopologyConnections;
+  const GUID* TopologyNodesNames;
+  ULONG Reserved;
+}KSTOPOLOGY, * PKSTOPOLOGY;
+
+#define KSFILTER_NODE ((ULONG)-1)
+#define KSALL_NODES ((ULONG)-1)
+
+typedef struct
+{
+  ULONG CreateFlags;
+  ULONG Node;
+}KSNODE_CREATE, * PKSNODE_CREATE;
+
+#define STATIC_KSTIME_FORMAT_NONE STATIC_GUID_NULL
+#define KSTIME_FORMAT_NONE GUID_NULL
+
+#define STATIC_KSTIME_FORMAT_FRAME                  \
+  0x7b785570L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
+DEFINE_GUIDSTRUCT("7b785570-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_FRAME);
+#define KSTIME_FORMAT_FRAME DEFINE_GUIDNAMED(KSTIME_FORMAT_FRAME)
+
+#define STATIC_KSTIME_FORMAT_BYTE                   \
+  0x7b785571L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
+DEFINE_GUIDSTRUCT("7b785571-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_BYTE);
+#define KSTIME_FORMAT_BYTE DEFINE_GUIDNAMED(KSTIME_FORMAT_BYTE)
+
+#define STATIC_KSTIME_FORMAT_SAMPLE                 \
+  0x7b785572L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
+DEFINE_GUIDSTRUCT("7b785572-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_SAMPLE);
+#define KSTIME_FORMAT_SAMPLE DEFINE_GUIDNAMED(KSTIME_FORMAT_SAMPLE)
+
+#define STATIC_KSTIME_FORMAT_FIELD                  \
+  0x7b785573L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
+DEFINE_GUIDSTRUCT("7b785573-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_FIELD);
+#define KSTIME_FORMAT_FIELD DEFINE_GUIDNAMED(KSTIME_FORMAT_FIELD)
+
+#define STATIC_KSTIME_FORMAT_MEDIA_TIME                 \
+  0x7b785574L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
+DEFINE_GUIDSTRUCT("7b785574-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_MEDIA_TIME);
+#define KSTIME_FORMAT_MEDIA_TIME DEFINE_GUIDNAMED(KSTIME_FORMAT_MEDIA_TIME)
+
+typedef KSIDENTIFIER KSPIN_INTERFACE, * PKSPIN_INTERFACE;
+
+#define STATIC_KSINTERFACESETID_Standard                \
+  0x1A8766A0L, 0x62CE, 0x11CF, { 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00 }
+DEFINE_GUIDSTRUCT("1A8766A0-62CE-11CF-A5D6-28DB04C10000", KSINTERFACESETID_Standard);
+#define KSINTERFACESETID_Standard DEFINE_GUIDNAMED(KSINTERFACESETID_Standard)
+
+typedef enum
+{
+  KSINTERFACE_STANDARD_STREAMING,
+  KSINTERFACE_STANDARD_LOOPED_STREAMING,
+  KSINTERFACE_STANDARD_CONTROL
+}KSINTERFACE_STANDARD;
+
+#define STATIC_KSINTERFACESETID_FileIo                  \
+  0x8C6F932CL, 0xE771, 0x11D0, 0xB8, 0xFF, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("8C6F932C-E771-11D0-B8FF-00A0C9223196", KSINTERFACESETID_FileIo);
+#define KSINTERFACESETID_FileIo DEFINE_GUIDNAMED(KSINTERFACESETID_FileIo)
+
+typedef enum
+{
+  KSINTERFACE_FILEIO_STREAMING
+}KSINTERFACE_FILEIO;
+
+#define KSMEDIUM_TYPE_ANYINSTANCE 0
+
+#define STATIC_KSMEDIUMSETID_Standard                   \
+  0x4747B320L, 0x62CE, 0x11CF, { 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00 }
+DEFINE_GUIDSTRUCT("4747B320-62CE-11CF-A5D6-28DB04C10000", KSMEDIUMSETID_Standard);
+#define KSMEDIUMSETID_Standard DEFINE_GUIDNAMED(KSMEDIUMSETID_Standard)
+
+#define KSMEDIUM_STANDARD_DEVIO KSMEDIUM_TYPE_ANYINSTANCE
+
+#define STATIC_KSPROPSETID_Pin                      \
+  0x8C134960L, 0x51AD, 0x11CF, { 0x87, 0x8A, 0x94, 0xF8, 0x01, 0xC1, 0x00, 0x00 }
+DEFINE_GUIDSTRUCT("8C134960-51AD-11CF-878A-94F801C10000", KSPROPSETID_Pin);
+#define KSPROPSETID_Pin DEFINE_GUIDNAMED(KSPROPSETID_Pin)
+
+typedef enum
+{
+  KSPROPERTY_PIN_CINSTANCES,
+  KSPROPERTY_PIN_CTYPES,
+  KSPROPERTY_PIN_DATAFLOW,
+  KSPROPERTY_PIN_DATARANGES,
+  KSPROPERTY_PIN_DATAINTERSECTION,
+  KSPROPERTY_PIN_INTERFACES,
+  KSPROPERTY_PIN_MEDIUMS,
+  KSPROPERTY_PIN_COMMUNICATION,
+  KSPROPERTY_PIN_GLOBALCINSTANCES,
+  KSPROPERTY_PIN_NECESSARYINSTANCES,
+  KSPROPERTY_PIN_PHYSICALCONNECTION,
+  KSPROPERTY_PIN_CATEGORY,
+  KSPROPERTY_PIN_NAME,
+  KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
+  KSPROPERTY_PIN_PROPOSEDATAFORMAT
+}KSPROPERTY_PIN;
+
+typedef struct
+{
+  KSPROPERTY Property;
+  ULONG PinId;
+  ULONG Reserved;
+}KSP_PIN, * PKSP_PIN;
+
+#define KSINSTANCE_INDETERMINATE ((ULONG)-1)
+
+typedef struct
+{
+  ULONG PossibleCount;
+  ULONG CurrentCount;
+}KSPIN_CINSTANCES, * PKSPIN_CINSTANCES;
+
+typedef enum
+{
+  KSPIN_DATAFLOW_IN = 1,
+  KSPIN_DATAFLOW_OUT
+}KSPIN_DATAFLOW, * PKSPIN_DATAFLOW;
+
+#define KSDATAFORMAT_BIT_TEMPORAL_COMPRESSION 0
+#define KSDATAFORMAT_TEMPORAL_COMPRESSION (1 << KSDATAFORMAT_BIT_TEMPORAL_COMPRESSION)
+#define KSDATAFORMAT_BIT_ATTRIBUTES 1
+#define KSDATAFORMAT_ATTRIBUTES (1 << KSDATAFORMAT_BIT_ATTRIBUTES)
+
+#define KSDATARANGE_BIT_ATTRIBUTES 1
+#define KSDATARANGE_ATTRIBUTES (1 << KSDATARANGE_BIT_ATTRIBUTES)
+#define KSDATARANGE_BIT_REQUIRED_ATTRIBUTES 2
+#define KSDATARANGE_REQUIRED_ATTRIBUTES (1 << KSDATARANGE_BIT_REQUIRED_ATTRIBUTES)
+
+typedef union
+{
+  __MINGW_EXTENSION struct
+  {
+    ULONG FormatSize;
+    ULONG Flags;
+    ULONG SampleSize;
+    ULONG Reserved;
+    GUID MajorFormat;
+    GUID SubFormat;
+    GUID Specifier;
+  };
+  LONGLONG Alignment;
+}KSDATAFORMAT, * PKSDATAFORMAT, KSDATARANGE, * PKSDATARANGE;
+
+#define KSATTRIBUTE_REQUIRED 0x00000001
+
+typedef struct
+{
+  ULONG Size;
+  ULONG Flags;
+  GUID Attribute;
+}KSATTRIBUTE, * PKSATTRIBUTE;
+
+#if defined(_NTDDK_)
+typedef struct
+{
+  ULONG Count;
+  PKSATTRIBUTE* Attributes;
+}KSATTRIBUTE_LIST, * PKSATTRIBUTE_LIST;
+#endif /* _NTDDK_ */
+
+typedef enum
+{
+  KSPIN_COMMUNICATION_NONE,
+  KSPIN_COMMUNICATION_SINK,
+  KSPIN_COMMUNICATION_SOURCE,
+  KSPIN_COMMUNICATION_BOTH,
+  KSPIN_COMMUNICATION_BRIDGE
+}KSPIN_COMMUNICATION, * PKSPIN_COMMUNICATION;
+
+typedef KSIDENTIFIER KSPIN_MEDIUM, * PKSPIN_MEDIUM;
+
+typedef struct
+{
+  KSPIN_INTERFACE Interface;
+  KSPIN_MEDIUM Medium;
+  ULONG PinId;
+  HANDLE PinToHandle;
+  KSPRIORITY Priority;
+}KSPIN_CONNECT, * PKSPIN_CONNECT;
+
+typedef struct
+{
+  ULONG Size;
+  ULONG Pin;
+  WCHAR SymbolicLinkName[1];
+}KSPIN_PHYSICALCONNECTION, * PKSPIN_PHYSICALCONNECTION;
+
+#if defined(_NTDDK_)
+typedef NTSTATUS (*PFNKSINTERSECTHANDLER)(PIRP Irp, PKSP_PIN Pin,
+                                          PKSDATARANGE DataRange,
+                                          PVOID Data);
+typedef NTSTATUS (*PFNKSINTERSECTHANDLEREX)(PVOID Context, PIRP Irp,
+                                            PKSP_PIN Pin,
+                                            PKSDATARANGE DataRange,
+                                            PKSDATARANGE MatchingDataRange,
+                                            ULONG DataBufferSize,
+                                            PVOID Data,
+                                            PULONG DataSize);
+#endif /* _NTDDK_ */
+
+#define DEFINE_KSPIN_INTERFACE_TABLE(tablename)             \
+  const KSPIN_INTERFACE tablename[] =
+
+#define DEFINE_KSPIN_INTERFACE_ITEM(guid, _interFace)            \
+  {                               \
+    STATICGUIDOF(guid),                 \
+    (_interFace),                       \
+    0                           \
+  }
+
+#define DEFINE_KSPIN_MEDIUM_TABLE(tablename)                \
+  const KSPIN_MEDIUM tablename[] =
+
+#define DEFINE_KSPIN_MEDIUM_ITEM(guid, medium)               \
+  DEFINE_KSPIN_INTERFACE_ITEM(guid, medium)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(Handler)          \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_CINSTANCES,      \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    sizeof(KSPIN_CINSTANCES),       \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(Handler)          \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_CTYPES,          \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(ULONG),              \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(Handler)            \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_DATAFLOW,        \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    sizeof(KSPIN_DATAFLOW),         \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(Handler)          \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_DATARANGES,      \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(Handler)        \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_DATAINTERSECTION,    \
+    (Handler),              \
+    sizeof(KSP_PIN) + sizeof(KSMULTIPLE_ITEM), \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(Handler)          \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_INTERFACES,      \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(Handler)         \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_MEDIUMS,         \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(Handler)       \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_COMMUNICATION,       \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    sizeof(KSPIN_COMMUNICATION),        \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(Handler)        \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_GLOBALCINSTANCES,    \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    sizeof(KSPIN_CINSTANCES),       \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(Handler)      \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_NECESSARYINSTANCES,  \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    sizeof(ULONG),              \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(Handler)      \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_PHYSICALCONNECTION,  \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(Handler)            \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_CATEGORY,        \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    sizeof(GUID),               \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_NAME(Handler)            \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_NAME,            \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(Handler)   \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_CONSTRAINEDDATARANGES,   \
+    (Handler),              \
+    sizeof(KSP_PIN),            \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_PIN_PROPOSEDATAFORMAT(Handler)       \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_PIN_PROPOSEDATAFORMAT,   \
+    NULL,                   \
+    sizeof(KSP_PIN),            \
+    sizeof(KSDATAFORMAT),           \
+    (Handler), NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_PINSET(PinSet, PropGeneral, PropInstances, PropIntersection) \
+  DEFINE_KSPROPERTY_TABLE(PinSet) {                   \
+    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),       \
+    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),         \
+    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),       \
+    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),     \
+    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),  \
+    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),     \
+    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),        \
+    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),      \
+    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),       \
+    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropGeneral)            \
+  }
+
+#define DEFINE_KSPROPERTY_PINSETCONSTRAINED(PinSet, PropGeneral, PropInstances, PropIntersection) \
+  DEFINE_KSPROPERTY_TABLE(PinSet) {                   \
+    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),       \
+    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),         \
+    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),       \
+    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),     \
+    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),  \
+    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),     \
+    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),        \
+    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),      \
+    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),       \
+    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropGeneral),           \
+    DEFINE_KSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(PropGeneral)   \
+  }
+
+#define STATIC_KSNAME_Filter                        \
+  0x9b365890L, 0x165f, 0x11d0, 0xa1, 0x95, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
+DEFINE_GUIDSTRUCT("9b365890-165f-11d0-a195-0020afd156e4", KSNAME_Filter);
+#define KSNAME_Filter DEFINE_GUIDNAMED(KSNAME_Filter)
+
+#define KSSTRING_Filter L"{9B365890-165F-11D0-A195-0020AFD156E4}"
+
+#define STATIC_KSNAME_Pin                       \
+  0x146F1A80L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("146F1A80-4791-11D0-A5D6-28DB04C10000", KSNAME_Pin);
+#define KSNAME_Pin DEFINE_GUIDNAMED(KSNAME_Pin)
+
+#define KSSTRING_Pin L"{146F1A80-4791-11D0-A5D6-28DB04C10000}"
+
+#define STATIC_KSNAME_Clock                     \
+  0x53172480L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000", KSNAME_Clock);
+#define KSNAME_Clock DEFINE_GUIDNAMED(KSNAME_Clock)
+
+#define KSSTRING_Clock L"{53172480-4791-11D0-A5D6-28DB04C10000}"
+
+#define STATIC_KSNAME_Allocator                     \
+  0x642F5D00L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("642F5D00-4791-11D0-A5D6-28DB04C10000", KSNAME_Allocator);
+#define KSNAME_Allocator DEFINE_GUIDNAMED(KSNAME_Allocator)
+
+#define KSSTRING_Allocator L"{642F5D00-4791-11D0-A5D6-28DB04C10000}"
+
+#define KSSTRING_AllocatorEx L"{091BB63B-603F-11D1-B067-00A0C9062802}"
+
+#define STATIC_KSNAME_TopologyNode                  \
+  0x0621061AL, 0xEE75, 0x11D0, 0xB9, 0x15, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("0621061A-EE75-11D0-B915-00A0C9223196", KSNAME_TopologyNode);
+#define KSNAME_TopologyNode DEFINE_GUIDNAMED(KSNAME_TopologyNode)
+
+#define KSSTRING_TopologyNode L"{0621061A-EE75-11D0-B915-00A0C9223196}"
+
+#if defined(_NTDDK_)
+typedef struct
+{
+  ULONG InterfacesCount;
+  const KSPIN_INTERFACE* Interfaces;
+  ULONG MediumsCount;
+  const KSPIN_MEDIUM* Mediums;
+  ULONG DataRangesCount;
+  const PKSDATARANGE* DataRanges;
+  KSPIN_DATAFLOW DataFlow;
+  KSPIN_COMMUNICATION Communication;
+  const GUID* Category;
+  const GUID* Name;
+  __MINGW_EXTENSION union
+  {
+    LONGLONG Reserved;
+    __MINGW_EXTENSION struct
+    {
+      ULONG ConstrainedDataRangesCount;
+      PKSDATARANGE* ConstrainedDataRanges;
+    };
+  };
+}KSPIN_DESCRIPTOR, * PKSPIN_DESCRIPTOR;
+typedef const KSPIN_DESCRIPTOR* PCKSPIN_DESCRIPTOR;
+
+ # define DEFINE_KSPIN_DESCRIPTOR_TABLE(tablename)            \
+  const KSPIN_DESCRIPTOR tablename[] =
+
+ # define DEFINE_KSPIN_DESCRIPTOR_ITEM(InterfacesCount, Interfaces, MediumsCount, Mediums, DataRangesCount, DataRanges, DataFlow, Communication) \
+  {                                   \
+    InterfacesCount, Interfaces, MediumsCount, Mediums, \
+    DataRangesCount, DataRanges, DataFlow, Communication,   \
+    NULL, NULL, 0                       \
+  }
+
+ # define DEFINE_KSPIN_DESCRIPTOR_ITEMEX(InterfacesCount, Interfaces, MediumsCount, Mediums, DataRangesCount, DataRanges, DataFlow, Communication, Category, Name) \
+  {                                   \
+    InterfacesCount, Interfaces, MediumsCount, Mediums, \
+    DataRangesCount, DataRanges, DataFlow, Communication,   \
+    Category, Name, 0                   \
+  }
+#endif /* _NTDDK_ */
+
+#define STATIC_KSDATAFORMAT_TYPE_WILDCARD STATIC_GUID_NULL
+#define KSDATAFORMAT_TYPE_WILDCARD GUID_NULL
+
+#define STATIC_KSDATAFORMAT_SUBTYPE_WILDCARD STATIC_GUID_NULL
+#define KSDATAFORMAT_SUBTYPE_WILDCARD GUID_NULL
+
+#define STATIC_KSDATAFORMAT_TYPE_STREAM                 \
+  0xE436EB83L, 0x524F, 0x11CE, 0x9F, 0x53, 0x00, 0x20, 0xAF, 0x0B, 0xA7, 0x70
+DEFINE_GUIDSTRUCT("E436EB83-524F-11CE-9F53-0020AF0BA770", KSDATAFORMAT_TYPE_STREAM);
+#define KSDATAFORMAT_TYPE_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STREAM)
+
+#define STATIC_KSDATAFORMAT_SUBTYPE_NONE                \
+  0xE436EB8EL, 0x524F, 0x11CE, 0x9F, 0x53, 0x00, 0x20, 0xAF, 0x0B, 0xA7, 0x70
+DEFINE_GUIDSTRUCT("E436EB8E-524F-11CE-9F53-0020AF0BA770", KSDATAFORMAT_SUBTYPE_NONE);
+#define KSDATAFORMAT_SUBTYPE_NONE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NONE)
+
+#define STATIC_KSDATAFORMAT_SPECIFIER_WILDCARD STATIC_GUID_NULL
+#define KSDATAFORMAT_SPECIFIER_WILDCARD GUID_NULL
+
+#define STATIC_KSDATAFORMAT_SPECIFIER_FILENAME              \
+  0xAA797B40L, 0xE974, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("AA797B40-E974-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SPECIFIER_FILENAME);
+#define KSDATAFORMAT_SPECIFIER_FILENAME DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_FILENAME)
+
+#define STATIC_KSDATAFORMAT_SPECIFIER_FILEHANDLE            \
+  0x65E8773CL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUIDSTRUCT("65E8773C-8F56-11D0-A3B9-00A0C9223196", KSDATAFORMAT_SPECIFIER_FILEHANDLE);
+#define KSDATAFORMAT_SPECIFIER_FILEHANDLE DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_FILEHANDLE)
+
+#define STATIC_KSDATAFORMAT_SPECIFIER_NONE              \
+  0x0F6417D6L, 0xC318, 0x11D0, { 0xA4, 0x3F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96 }
+DEFINE_GUIDSTRUCT("0F6417D6-C318-11D0-A43F-00A0C9223196", KSDATAFORMAT_SPECIFIER_NONE);
+#define KSDATAFORMAT_SPECIFIER_NONE DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_NONE)
+
+#define STATIC_KSPROPSETID_Quality                  \
+  0xD16AD380L, 0xAC1A, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("D16AD380-AC1A-11CF-A5D6-28DB04C10000", KSPROPSETID_Quality);
+#define KSPROPSETID_Quality DEFINE_GUIDNAMED(KSPROPSETID_Quality)
+
+typedef enum
+{
+  KSPROPERTY_QUALITY_REPORT,
+  KSPROPERTY_QUALITY_ERROR
+}KSPROPERTY_QUALITY;
+
+#define DEFINE_KSPROPERTY_ITEM_QUALITY_REPORT(GetHandler, SetHandler)    \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_QUALITY_REPORT,      \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSQUALITY),          \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_QUALITY_ERROR(GetHandler, SetHandler) \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_QUALITY_ERROR,       \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSERROR),            \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define STATIC_KSPROPSETID_Connection                   \
+  0x1D58C920L, 0xAC9B, 0x11CF, { 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00 }
+DEFINE_GUIDSTRUCT("1D58C920-AC9B-11CF-A5D6-28DB04C10000", KSPROPSETID_Connection);
+#define KSPROPSETID_Connection DEFINE_GUIDNAMED(KSPROPSETID_Connection)
+
+typedef enum
+{
+  KSPROPERTY_CONNECTION_STATE,
+  KSPROPERTY_CONNECTION_PRIORITY,
+  KSPROPERTY_CONNECTION_DATAFORMAT,
+  KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
+  KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,
+  KSPROPERTY_CONNECTION_ACQUIREORDERING,
+  KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,
+  KSPROPERTY_CONNECTION_STARTAT
+}KSPROPERTY_CONNECTION;
+
+#define DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(GetHandler, SetHandler)  \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CONNECTION_STATE,        \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSSTATE),            \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_CONNECTION_PRIORITY(GetHandler, SetHandler) \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CONNECTION_PRIORITY,     \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSPRIORITY),         \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(GetHandler, SetHandler) \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CONNECTION_DATAFORMAT,   \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    0,                  \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(Handler) \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CONNECTION_ALLOCATORFRAMING, \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSALLOCATOR_FRAMING),        \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING_EX(Handler)  \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX, \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    0,                  \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_CONNECTION_PROPOSEDATAFORMAT(Handler)    \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT, \
+    NULL,                   \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSDATAFORMAT),           \
+    (Handler),              \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ACQUIREORDERING(Handler)  \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CONNECTION_ACQUIREORDERING,  \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(int),                \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_CONNECTION_STARTAT(Handler)      \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CONNECTION_STARTAT,      \
+    NULL,                   \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSRELATIVEEVENT),        \
+    (Handler),              \
+    NULL, 0, NULL, NULL, 0)
+
+#define KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER 0x00000001
+#define KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY 0x00000002
+#define KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY 0x00000004
+#define KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE 0x00000008
+#define KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY 0x80000000
+
+#define KSALLOCATOR_OPTIONF_COMPATIBLE 0x00000001
+#define KSALLOCATOR_OPTIONF_SYSTEM_MEMORY 0x00000002
+#define KSALLOCATOR_OPTIONF_VALID 0x00000003
+
+#define KSALLOCATOR_FLAG_PARTIAL_READ_SUPPORT 0x00000010
+#define KSALLOCATOR_FLAG_DEVICE_SPECIFIC 0x00000020
+#define KSALLOCATOR_FLAG_CAN_ALLOCATE 0x00000040
+#define KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO 0x00000080
+#define KSALLOCATOR_FLAG_NO_FRAME_INTEGRITY 0x00000100
+#define KSALLOCATOR_FLAG_MULTIPLE_OUTPUT 0x00000200
+#define KSALLOCATOR_FLAG_CYCLE 0x00000400
+#define KSALLOCATOR_FLAG_ALLOCATOR_EXISTS 0x00000800
+#define KSALLOCATOR_FLAG_INDEPENDENT_RANGES 0x00001000
+#define KSALLOCATOR_FLAG_ATTENTION_STEPPING 0x00002000
+
+typedef struct
+{
+  __MINGW_EXTENSION union
+  {
+    ULONG OptionsFlags;
+    ULONG RequirementsFlags;
+  };
+#if defined(_NTDDK_)
+  POOL_TYPE PoolType;
+#else
+  ULONG PoolType;
+#endif /* _NTDDK_ */
+  ULONG Frames;
+  ULONG FrameSize;
+  ULONG FileAlignment;
+  ULONG Reserved;
+}KSALLOCATOR_FRAMING, * PKSALLOCATOR_FRAMING;
+
+#if defined(_NTDDK_)
+typedef PVOID (*PFNKSDEFAULTALLOCATE)(PVOID Context);
+typedef VOID (*PFNKSDEFAULTFREE)(PVOID Context, PVOID Buffer);
+typedef NTSTATUS (*PFNKSINITIALIZEALLOCATOR)(PVOID InitialContext,
+                                             PKSALLOCATOR_FRAMING AllocatorFraming,
+                                             PVOID* Context);
+typedef VOID (*PFNKSDELETEALLOCATOR)(PVOID Context);
+#endif /* _NTDDK_ */
+
+typedef struct
+{
+  ULONG MinFrameSize;
+  ULONG MaxFrameSize;
+  ULONG Stepping;
+}KS_FRAMING_RANGE, * PKS_FRAMING_RANGE;
+
+typedef struct
+{
+  KS_FRAMING_RANGE Range;
+  ULONG InPlaceWeight;
+  ULONG NotInPlaceWeight;
+}KS_FRAMING_RANGE_WEIGHTED, * PKS_FRAMING_RANGE_WEIGHTED;
+
+typedef struct
+{
+  ULONG RatioNumerator;
+  ULONG RatioDenominator;
+  ULONG RatioConstantMargin;
+}KS_COMPRESSION, * PKS_COMPRESSION;
+
+typedef struct
+{
+  GUID MemoryType;
+  GUID BusType;
+  ULONG MemoryFlags;
+  ULONG BusFlags;
+  ULONG Flags;
+  ULONG Frames;
+  ULONG FileAlignment;
+  ULONG MemoryTypeWeight;
+  KS_FRAMING_RANGE PhysicalRange;
+  KS_FRAMING_RANGE_WEIGHTED FramingRange;
+}KS_FRAMING_ITEM, * PKS_FRAMING_ITEM;
+
+typedef struct
+{
+  ULONG CountItems;
+  ULONG PinFlags;
+  KS_COMPRESSION OutputCompression;
+  ULONG PinWeight;
+  KS_FRAMING_ITEM FramingItem[1];
+}KSALLOCATOR_FRAMING_EX, * PKSALLOCATOR_FRAMING_EX;
+
+#define KSMEMORY_TYPE_WILDCARD GUID_NULL
+#define STATIC_KSMEMORY_TYPE_WILDCARD STATIC_GUID_NULL
+
+#define KSMEMORY_TYPE_DONT_CARE GUID_NULL
+#define STATIC_KSMEMORY_TYPE_DONT_CARE STATIC_GUID_NULL
+
+#define KS_TYPE_DONT_CARE GUID_NULL
+#define STATIC_KS_TYPE_DONT_CARE STATIC_GUID_NULL
+
+#define STATIC_KSMEMORY_TYPE_SYSTEM                 \
+  0x091bb638L, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
+DEFINE_GUIDSTRUCT("091bb638-603f-11d1-b067-00a0c9062802", KSMEMORY_TYPE_SYSTEM);
+#define KSMEMORY_TYPE_SYSTEM DEFINE_GUIDNAMED(KSMEMORY_TYPE_SYSTEM)
+
+#define STATIC_KSMEMORY_TYPE_USER                   \
+  0x8cb0fc28L, 0x7893, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
+DEFINE_GUIDSTRUCT("8cb0fc28-7893-11d1-b069-00a0c9062802", KSMEMORY_TYPE_USER);
+#define KSMEMORY_TYPE_USER DEFINE_GUIDNAMED(KSMEMORY_TYPE_USER)
+
+#define STATIC_KSMEMORY_TYPE_KERNEL_PAGED               \
+  0xd833f8f8L, 0x7894, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
+DEFINE_GUIDSTRUCT("d833f8f8-7894-11d1-b069-00a0c9062802", KSMEMORY_TYPE_KERNEL_PAGED);
+#define KSMEMORY_TYPE_KERNEL_PAGED DEFINE_GUIDNAMED(KSMEMORY_TYPE_KERNEL_PAGED)
+
+#define STATIC_KSMEMORY_TYPE_KERNEL_NONPAGED                \
+  0x4a6d5fc4L, 0x7895, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
+DEFINE_GUIDSTRUCT("4a6d5fc4-7895-11d1-b069-00a0c9062802", KSMEMORY_TYPE_KERNEL_NONPAGED);
+#define KSMEMORY_TYPE_KERNEL_NONPAGED DEFINE_GUIDNAMED(KSMEMORY_TYPE_KERNEL_NONPAGED)
+
+#define STATIC_KSMEMORY_TYPE_DEVICE_UNKNOWN             \
+  0x091bb639L, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
+DEFINE_GUIDSTRUCT("091bb639-603f-11d1-b067-00a0c9062802", KSMEMORY_TYPE_DEVICE_UNKNOWN);
+#define KSMEMORY_TYPE_DEVICE_UNKNOWN DEFINE_GUIDNAMED(KSMEMORY_TYPE_DEVICE_UNKNOWN)
+
+#define DECLARE_SIMPLE_FRAMING_EX(FramingExName, MemoryType, Flags, Frames, Alignment, MinFrameSize, MaxFrameSize) \
+  const KSALLOCATOR_FRAMING_EX FramingExName =                \
+  {                                   \
+    1,                              \
+    0,                              \
+    {                               \
+      1,                          \
+      1,                          \
+      0                           \
+    },                              \
+    0,                              \
+    {                               \
+      {                           \
+        MemoryType,                 \
+        STATIC_KS_TYPE_DONT_CARE,           \
+        0,                      \
+        0,                      \
+        Flags,                      \
+        Frames,                     \
+        Alignment,                  \
+        0,                      \
+        {                       \
+          0,                  \
+          (ULONG)-1,              \
+          1                   \
+        },                      \
+        {                       \
+          {                   \
+            MinFrameSize,           \
+            MaxFrameSize,           \
+            1               \
+          },                  \
+          0,                  \
+          0                   \
+        }                       \
+      }                           \
+    }                               \
+  }
+
+#define SetDefaultKsCompression(KsCompressionPointer)           \
+  {                                   \
+    KsCompressionPointer->RatioNumerator = 1;           \
+    KsCompressionPointer->RatioDenominator = 1;         \
+    KsCompressionPointer->RatioConstantMargin = 0;          \
+  }
+
+#define SetDontCareKsFramingRange(KsFramingRangePointer)        \
+  {                                   \
+    KsFramingRangePointer->MinFrameSize = 0;            \
+    KsFramingRangePointer->MaxFrameSize = (ULONG)-1;       \
+    KsFramingRangePointer->Stepping = 1;                \
+  }
+
+#define SetKsFramingRange(KsFramingRangePointer, P_MinFrameSize, P_MaxFrameSize) \
+  {                                   \
+    KsFramingRangePointer->MinFrameSize = P_MinFrameSize;       \
+    KsFramingRangePointer->MaxFrameSize = P_MaxFrameSize;       \
+    KsFramingRangePointer->Stepping = 1;                \
+  }
+
+#define SetKsFramingRangeWeighted(KsFramingRangeWeightedPointer, P_MinFrameSize, P_MaxFrameSize) \
+  {                                   \
+    KS_FRAMING_RANGE* KsFramingRange =              \
+      &KsFramingRangeWeightedPointer->Range;  \
+    SetKsFramingRange(KsFramingRange, P_MinFrameSize, P_MaxFrameSize); \
+    KsFramingRangeWeightedPointer->InPlaceWeight = 0;       \
+    KsFramingRangeWeightedPointer->NotInPlaceWeight = 0;        \
+  }
+
+#define INITIALIZE_SIMPLE_FRAMING_EX(FramingExPointer, P_MemoryType, P_Flags, P_Frames, P_Alignment, P_MinFrameSize, P_MaxFrameSize) \
+  {                                   \
+    KS_COMPRESSION* KsCompression =                 \
+      &FramingExPointer->OutputCompression;       \
+    KS_FRAMING_RANGE* KsFramingRange =              \
+      &FramingExPointer->FramingItem[0].PhysicalRange; \
+    KS_FRAMING_RANGE_WEIGHTED* KsFramingRangeWeighted =     \
+      &FramingExPointer->FramingItem[0].FramingRange; \
+    FramingExPointer->CountItems = 1;               \
+    FramingExPointer->PinFlags = 0;                 \
+    SetDefaultKsCompression(KsCompression);             \
+    FramingExPointer->PinWeight = 0;                \
+    FramingExPointer->FramingItem[0].MemoryType = P_MemoryType; \
+    FramingExPointer->FramingItem[0].BusType = KS_TYPE_DONT_CARE;   \
+    FramingExPointer->FramingItem[0].MemoryFlags = 0;       \
+    FramingExPointer->FramingItem[0].BusFlags = 0;          \
+    FramingExPointer->FramingItem[0].Flags = P_Flags;       \
+    FramingExPointer->FramingItem[0].Frames = P_Frames;     \
+    FramingExPointer->FramingItem[0].FileAlignment = P_Alignment;   \
+    FramingExPointer->FramingItem[0].MemoryTypeWeight = 0;      \
+    SetDontCareKsFramingRange(KsFramingRange);          \
+    SetKsFramingRangeWeighted(KsFramingRangeWeighted,       \
+                              P_MinFrameSize, P_MaxFrameSize);   \
+  }
+
+#define STATIC_KSEVENTSETID_StreamAllocator             \
+  0x75d95571L, 0x073c, 0x11d0, 0xa1, 0x61, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
+DEFINE_GUIDSTRUCT("75d95571-073c-11d0-a161-0020afd156e4", KSEVENTSETID_StreamAllocator);
+#define KSEVENTSETID_StreamAllocator DEFINE_GUIDNAMED(KSEVENTSETID_StreamAllocator)
+
+typedef enum
+{
+  KSEVENT_STREAMALLOCATOR_INTERNAL_FREEFRAME,
+  KSEVENT_STREAMALLOCATOR_FREEFRAME
+}KSEVENT_STREAMALLOCATOR;
+
+#define STATIC_KSMETHODSETID_StreamAllocator                \
+  0xcf6e4341L, 0xec87, 0x11cf, 0xa1, 0x30, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
+DEFINE_GUIDSTRUCT("cf6e4341-ec87-11cf-a130-0020afd156e4", KSMETHODSETID_StreamAllocator);
+#define KSMETHODSETID_StreamAllocator DEFINE_GUIDNAMED(KSMETHODSETID_StreamAllocator)
+
+typedef enum
+{
+  KSMETHOD_STREAMALLOCATOR_ALLOC,
+  KSMETHOD_STREAMALLOCATOR_FREE
+}KSMETHOD_STREAMALLOCATOR;
+
+#define DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(Handler)     \
+  DEFINE_KSMETHOD_ITEM(                       \
+    KSMETHOD_STREAMALLOCATOR_ALLOC,     \
+    KSMETHOD_TYPE_WRITE,            \
+    (Handler),              \
+    sizeof(KSMETHOD),           \
+    sizeof(PVOID),              \
+    NULL)
+
+#define DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_FREE(Handler)      \
+  DEFINE_KSMETHOD_ITEM(                       \
+    KSMETHOD_STREAMALLOCATOR_FREE,      \
+    KSMETHOD_TYPE_READ,         \
+    (Handler),              \
+    sizeof(KSMETHOD),           \
+    sizeof(PVOID),              \
+    NULL)
+
+#define DEFINE_KSMETHOD_ALLOCATORSET(AllocatorSet, MethodAlloc, MethodFree) \
+  DEFINE_KSMETHOD_TABLE(AllocatorSet) {                   \
+    DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(MethodAlloc),    \
+    DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_FREE(MethodFree)       \
+  }
+
+#define STATIC_KSPROPSETID_StreamAllocator              \
+  0xcf6e4342L, 0xec87, 0x11cf, 0xa1, 0x30, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
+DEFINE_GUIDSTRUCT("cf6e4342-ec87-11cf-a130-0020afd156e4", KSPROPSETID_StreamAllocator);
+#define KSPROPSETID_StreamAllocator DEFINE_GUIDNAMED(KSPROPSETID_StreamAllocator)
+
+#if defined(_NTDDK_)
+typedef enum
+{
+  KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,
+  KSPROPERTY_STREAMALLOCATOR_STATUS
+}KSPROPERTY_STREAMALLOCATOR;
+
+ # define DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(Handler)   \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE, \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSSTREAMALLOCATOR_FUNCTIONTABLE), \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(Handler)      \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAMALLOCATOR_STATUS,  \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSSTREAMALLOCATOR_STATUS),   \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ALLOCATORSET(AllocatorSet, PropFunctionTable, PropStatus) \
+  DEFINE_KSPROPERTY_TABLE(AllocatorSet) {                 \
+    DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(PropStatus),  \
+    DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(PropFunctionTable) \
+  }
+
+typedef NTSTATUS (*PFNALLOCATOR_ALLOCATEFRAME)(PFILE_OBJECT FileObject,
+                                               PVOID* Frame);
+typedef VOID (*PFNALLOCATOR_FREEFRAME)(PFILE_OBJECT FileObject, PVOID Frame);
+
+typedef struct
+{
+  PFNALLOCATOR_ALLOCATEFRAME AllocateFrame;
+  PFNALLOCATOR_FREEFRAME FreeFrame;
+}KSSTREAMALLOCATOR_FUNCTIONTABLE, * PKSSTREAMALLOCATOR_FUNCTIONTABLE;
+#endif /* _NTDDK_ */
+
+typedef struct
+{
+  KSALLOCATOR_FRAMING Framing;
+  ULONG AllocatedFrames;
+  ULONG Reserved;
+}KSSTREAMALLOCATOR_STATUS, * PKSSTREAMALLOCATOR_STATUS;
+
+typedef struct
+{
+  KSALLOCATOR_FRAMING_EX Framing;
+  ULONG AllocatedFrames;
+  ULONG Reserved;
+}KSSTREAMALLOCATOR_STATUS_EX, * PKSSTREAMALLOCATOR_STATUS_EX;
+
+#define KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT 0x00000001
+#define KSSTREAM_HEADER_OPTIONSF_PREROLL 0x00000002
+#define KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY 0x00000004
+#define KSSTREAM_HEADER_OPTIONSF_TYPECHANGED 0x00000008
+#define KSSTREAM_HEADER_OPTIONSF_TIMEVALID 0x00000010
+#define KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY 0x00000040
+#define KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE 0x00000080
+#define KSSTREAM_HEADER_OPTIONSF_DURATIONVALID 0x00000100
+#define KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM 0x00000200
+#define KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA 0x80000000
+
+typedef struct
+{
+  LONGLONG Time;
+  ULONG Numerator;
+  ULONG Denominator;
+}KSTIME, * PKSTIME;
+
+typedef struct
+{
+  ULONG Size;
+  ULONG TypeSpecificFlags;
+  KSTIME PresentationTime;
+  LONGLONG Duration;
+  ULONG FrameExtent;
+  ULONG DataUsed;
+  PVOID Data;
+  ULONG OptionsFlags;
+#ifdef _WIN64
+  ULONG Reserved;
+#endif
+}KSSTREAM_HEADER, * PKSSTREAM_HEADER;
+
+#define STATIC_KSPROPSETID_StreamInterface              \
+  0x1fdd8ee1L, 0x9cd3, 0x11d0, 0x82, 0xaa, 0x00, 0x00, 0xf8, 0x22, 0xfe, 0x8a
+DEFINE_GUIDSTRUCT("1fdd8ee1-9cd3-11d0-82aa-0000f822fe8a", KSPROPSETID_StreamInterface);
+#define KSPROPSETID_StreamInterface DEFINE_GUIDNAMED(KSPROPSETID_StreamInterface)
+
+typedef enum
+{
+  KSPROPERTY_STREAMINTERFACE_HEADERSIZE
+}KSPROPERTY_STREAMINTERFACE;
+
+#define DEFINE_KSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE(GetHandler)   \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAMINTERFACE_HEADERSIZE,  \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(ULONG),              \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_STREAMINTERFACESET(StreamInterfaceSet, HeaderSizeHandler) \
+  DEFINE_KSPROPERTY_TABLE(StreamInterfaceSet) {               \
+    DEFINE_KSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE(HeaderSizeHandler) \
+  }
+
+#define STATIC_KSPROPSETID_Stream                   \
+  0x65aaba60L, 0x98ae, 0x11cf, 0xa1, 0x0d, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
+DEFINE_GUIDSTRUCT("65aaba60-98ae-11cf-a10d-0020afd156e4", KSPROPSETID_Stream);
+#define KSPROPSETID_Stream DEFINE_GUIDNAMED(KSPROPSETID_Stream)
+
+typedef enum
+{
+  KSPROPERTY_STREAM_ALLOCATOR,
+  KSPROPERTY_STREAM_QUALITY,
+  KSPROPERTY_STREAM_DEGRADATION,
+  KSPROPERTY_STREAM_MASTERCLOCK,
+  KSPROPERTY_STREAM_TIMEFORMAT,
+  KSPROPERTY_STREAM_PRESENTATIONTIME,
+  KSPROPERTY_STREAM_PRESENTATIONEXTENT,
+  KSPROPERTY_STREAM_FRAMETIME,
+  KSPROPERTY_STREAM_RATECAPABILITY,
+  KSPROPERTY_STREAM_RATE,
+  KSPROPERTY_STREAM_PIPE_ID
+}KSPROPERTY_STREAM;
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(GetHandler, SetHandler)  \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_ALLOCATOR,        \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(HANDLE),             \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_QUALITY(Handler)          \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_QUALITY,      \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSQUALITY_MANAGER),      \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_DEGRADATION(GetHandler, SetHandler) \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_DEGRADATION,      \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    0,                  \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(GetHandler, SetHandler) \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_MASTERCLOCK,      \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(HANDLE),             \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_TIMEFORMAT(Handler)       \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_TIMEFORMAT,       \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(GUID),               \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(GetHandler, SetHandler) \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_PRESENTATIONTIME, \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSTIME),             \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(Handler)   \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_PRESENTATIONEXTENT,   \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(LONGLONG),           \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_FRAMETIME(Handler)        \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_FRAMETIME,        \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSFRAMETIME),            \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_RATECAPABILITY(Handler)       \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_RATECAPABILITY,   \
+    (Handler),              \
+    sizeof(KSRATE_CAPABILITY),      \
+    sizeof(KSRATE),             \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_RATE(GetHandler, SetHandler)   \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_RATE,         \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSRATE),             \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+#define DEFINE_KSPROPERTY_ITEM_STREAM_PIPE_ID(GetHandler, SetHandler)    \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_STREAM_PIPE_ID,      \
+    (GetHandler),               \
+    sizeof(KSPROPERTY),         \
+    sizeof(HANDLE),             \
+    (SetHandler),               \
+    NULL, 0, NULL, NULL, 0)
+
+typedef struct
+{
+  HANDLE QualityManager;
+  PVOID Context;
+}KSQUALITY_MANAGER, * PKSQUALITY_MANAGER;
+
+typedef struct
+{
+  LONGLONG Duration;
+  ULONG FrameFlags;
+  ULONG Reserved;
+}KSFRAMETIME, * PKSFRAMETIME;
+
+#define KSFRAMETIME_VARIABLESIZE 0x00000001
+
+typedef struct
+{
+  LONGLONG PresentationStart;
+  LONGLONG Duration;
+  KSPIN_INTERFACE Interface;
+  LONG Rate;
+  ULONG Flags;
+}KSRATE, * PKSRATE;
+
+#define KSRATE_NOPRESENTATIONSTART 0x00000001
+#define KSRATE_NOPRESENTATIONDURATION 0x00000002
+
+typedef struct
+{
+  KSPROPERTY Property;
+  KSRATE Rate;
+}KSRATE_CAPABILITY, * PKSRATE_CAPABILITY;
+
+#define STATIC_KSPROPSETID_Clock                    \
+  0xDF12A4C0L, 0xAC17, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("DF12A4C0-AC17-11CF-A5D6-28DB04C10000", KSPROPSETID_Clock);
+#define KSPROPSETID_Clock DEFINE_GUIDNAMED(KSPROPSETID_Clock)
+
+#define NANOSECONDS 10000000
+#define KSCONVERT_PERFORMANCE_TIME(Frequency, PerformanceTime)       \
+  ((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS / (Frequency)) << 32) +    \
+   ((((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS) % (Frequency)) << 32) + \
+     ((ULONGLONG)(PerformanceTime).LowPart * NANOSECONDS)) / (Frequency)))
+
+typedef struct
+{
+  ULONG CreateFlags;
+}KSCLOCK_CREATE, * PKSCLOCK_CREATE;
+
+typedef struct
+{
+  LONGLONG Time;
+  LONGLONG SystemTime;
+}KSCORRELATED_TIME, * PKSCORRELATED_TIME;
+
+typedef struct
+{
+  LONGLONG Granularity;
+  LONGLONG Error;
+}KSRESOLUTION, * PKSRESOLUTION;
+
+typedef enum
+{
+  KSPROPERTY_CLOCK_TIME,
+  KSPROPERTY_CLOCK_PHYSICALTIME,
+  KSPROPERTY_CLOCK_CORRELATEDTIME,
+  KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,
+  KSPROPERTY_CLOCK_RESOLUTION,
+  KSPROPERTY_CLOCK_STATE,
+#if defined(_NTDDK_)
+  KSPROPERTY_CLOCK_FUNCTIONTABLE
+#endif /* _NTDDK_ */
+}KSPROPERTY_CLOCK;
+
+#if defined(_NTDDK_)
+typedef LONGLONG (FASTCALL * PFNKSCLOCK_GETTIME)(PFILE_OBJECT FileObject);
+typedef LONGLONG (FASTCALL * PFNKSCLOCK_CORRELATEDTIME)(PFILE_OBJECT FileObject,
+                                                        PLONGLONG SystemTime);
+
+typedef struct
+{
+  PFNKSCLOCK_GETTIME GetTime;
+  PFNKSCLOCK_GETTIME GetPhysicalTime;
+  PFNKSCLOCK_CORRELATEDTIME GetCorrelatedTime;
+  PFNKSCLOCK_CORRELATEDTIME GetCorrelatedPhysicalTime;
+}KSCLOCK_FUNCTIONTABLE, * PKSCLOCK_FUNCTIONTABLE;
+
+typedef BOOLEAN (*PFNKSSETTIMER)(PVOID Context, PKTIMER Timer,
+                                 LARGE_INTEGER DueTime, PKDPC Dpc);
+typedef BOOLEAN (*PFNKSCANCELTIMER)(PVOID Context, PKTIMER Timer);
+typedef LONGLONG (FASTCALL * PFNKSCORRELATEDTIME)(PVOID Context,
+                                                  PLONGLONG SystemTime);
+
+typedef PVOID PKSDEFAULTCLOCK;
+
+ # define DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(Handler)          \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CLOCK_TIME,          \
+    (Handler),              \
+    sizeof(KSPROPERTY), sizeof(LONGLONG),   \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(Handler)      \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CLOCK_PHYSICALTIME,      \
+    (Handler),              \
+    sizeof(KSPROPERTY), sizeof(LONGLONG),   \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(Handler)        \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CLOCK_CORRELATEDTIME,    \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSCORRELATED_TIME),      \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(Handler)    \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME, \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSCORRELATED_TIME),      \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(Handler)        \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CLOCK_RESOLUTION,        \
+    (Handler),              \
+    sizeof(KSPROPERTY), sizeof(KSRESOLUTION), \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(Handler)         \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CLOCK_STATE,         \
+    (Handler),              \
+    sizeof(KSPROPERTY), sizeof(KSSTATE),    \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(Handler)     \
+  DEFINE_KSPROPERTY_ITEM(                     \
+    KSPROPERTY_CLOCK_FUNCTIONTABLE,     \
+    (Handler),              \
+    sizeof(KSPROPERTY),         \
+    sizeof(KSCLOCK_FUNCTIONTABLE),      \
+    NULL, NULL, 0, NULL, NULL, 0)
+
+ # define DEFINE_KSPROPERTY_CLOCKSET(ClockSet, PropTime, PropPhysicalTime, PropCorrelatedTime, PropCorrelatedPhysicalTime, PropResolution, PropState, PropFunctionTable) \
+  DEFINE_KSPROPERTY_TABLE(ClockSet) {                 \
+    DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(PropTime),            \
+    DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(PropPhysicalTime),    \
+    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(PropCorrelatedTime), \
+    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(PropCorrelatedPhysicalTime), \
+    DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(PropResolution),    \
+    DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(PropState),          \
+    DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(PropFunctionTable),  \
+  }
+#endif /* _NTDDK_ */
+
+#define STATIC_KSEVENTSETID_Clock                   \
+  0x364D8E20L, 0x62C7, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("364D8E20-62C7-11CF-A5D6-28DB04C10000", KSEVENTSETID_Clock);
+#define KSEVENTSETID_Clock DEFINE_GUIDNAMED(KSEVENTSETID_Clock)
+
+typedef enum
+{
+  KSEVENT_CLOCK_INTERVAL_MARK,
+  KSEVENT_CLOCK_POSITION_MARK
+}KSEVENT_CLOCK_POSITION;
+
+#define STATIC_KSEVENTSETID_Connection                  \
+  0x7f4bcbe0L, 0x9ea5, 0x11cf, 0xa5, 0xd6, 0x28, 0xdb, 0x04, 0xc1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("7f4bcbe0-9ea5-11cf-a5d6-28db04c10000", KSEVENTSETID_Connection);
+#define KSEVENTSETID_Connection DEFINE_GUIDNAMED(KSEVENTSETID_Connection)
+
+typedef enum
+{
+  KSEVENT_CONNECTION_POSITIONUPDATE,
+  KSEVENT_CONNECTION_DATADISCONTINUITY,
+  KSEVENT_CONNECTION_TIMEDISCONTINUITY,
+  KSEVENT_CONNECTION_PRIORITY,
+  KSEVENT_CONNECTION_ENDOFSTREAM
+}KSEVENT_CONNECTION;
+
+typedef struct
+{
+  PVOID Context;
+  ULONG Proportion;
+  LONGLONG DeltaTime;
+}KSQUALITY, * PKSQUALITY;
+
+typedef struct
+{
+  PVOID Context;
+  ULONG Status;
+}KSERROR, * PKSERROR;
+
+typedef KSIDENTIFIER KSDEGRADE, * PKSDEGRADE;
+
+#define STATIC_KSDEGRADESETID_Standard                  \
+  0x9F564180L, 0x704C, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
+DEFINE_GUIDSTRUCT("9F564180-704C-11D0-A5D6-28DB04C10000", KSDEGRADESETID_Standard);
+#define KSDEGRADESETID_Standard DEFINE_GUIDNAMED(KSDEGRADESETID_Standard)
+
+typedef enum
+{
+  KSDEGRADE_STANDARD_SAMPLE,
+  KSDEGRADE_STANDARD_QUALITY,
+  KSDEGRADE_STANDARD_COMPUTATION,
+  KSDEGRADE_STANDARD_SKIP
+}KSDEGRADE_STANDARD;
+
+#if defined(_NTDDK_)
+
+ # define KSPROBE_STREAMREAD 0x00000000
+ # define KSPROBE_STREAMWRITE 0x00000001
+ # define KSPROBE_ALLOCATEMDL 0x00000010
+ # define KSPROBE_PROBEANDLOCK 0x00000020
+ # define KSPROBE_SYSTEMADDRESS 0x00000040
+ # define KSPROBE_MODIFY 0x00000200
+ # define KSPROBE_STREAMWRITEMODIFY (KSPROBE_MODIFY | KSPROBE_STREAMWRITE)
+ # define KSPROBE_ALLOWFORMATCHANGE 0x00000080
+ # define KSSTREAM_READ KSPROBE_STREAMREAD
+ # define KSSTREAM_WRITE KSPROBE_STREAMWRITE
+ # define KSSTREAM_PAGED_DATA 0x00000000
+ # define KSSTREAM_NONPAGED_DATA 0x00000100
+ # define KSSTREAM_SYNCHRONOUS 0x00001000
+ # define KSSTREAM_FAILUREEXCEPTION 0x00002000
+
+typedef NTSTATUS (*PFNKSCONTEXT_DISPATCH)(PVOID Context, PIRP Irp);
+typedef NTSTATUS (*PFNKSHANDLER)(PIRP Irp, PKSIDENTIFIER Request, PVOID Data);
+typedef BOOLEAN (*PFNKSFASTHANDLER)(PFILE_OBJECT FileObject,
+                                    PKSIDENTIFIER Request,
+                                    ULONG RequestLength, PVOID Data,
+                                    ULONG DataLength,
+                                    PIO_STATUS_BLOCK IoStatus);
+typedef NTSTATUS (*PFNKSALLOCATOR)(PIRP Irp, ULONG BufferSize,
+                                   BOOLEAN InputOperation);
+
+typedef struct
+{
+  KSPROPERTY_MEMBERSHEADER MembersHeader;
+  const VOID* Members;
+}KSPROPERTY_MEMBERSLIST, * PKSPROPERTY_MEMBERSLIST;
+
+typedef struct
+{
+  KSIDENTIFIER PropTypeSet;
+  ULONG MembersListCount;
+  const KSPROPERTY_MEMBERSLIST* MembersList;
+}KSPROPERTY_VALUES, * PKSPROPERTY_VALUES;
+
+ # define DEFINE_KSPROPERTY_TABLE(tablename)              \
+  const KSPROPERTY_ITEM tablename[] =
+
+ # define DEFINE_KSPROPERTY_ITEM(PropertyId, GetHandler, MinProperty, MinData, SetHandler, Values, RelationsCount, Relations, SupportHandler, SerializedSize) \
+  {                                   \
+    PropertyId, (PFNKSHANDLER)GetHandler,       \
+    MinProperty, MinData,               \
+    (PFNKSHANDLER)SetHandler,           \
+    (PKSPROPERTY_VALUES)Values, RelationsCount, \
+    (PKSPROPERTY)Relations,             \
+    (PFNKSHANDLER)SupportHandler,           \
+    (ULONG)SerializedSize               \
+  }
+
+typedef struct
+{
+  ULONG PropertyId;
+  __MINGW_EXTENSION union
+  {
+    PFNKSHANDLER GetPropertyHandler;
+    BOOLEAN GetSupported;
+  };
+  ULONG MinProperty;
+  ULONG MinData;
+  __MINGW_EXTENSION union
+  {
+    PFNKSHANDLER SetPropertyHandler;
+    BOOLEAN SetSupported;
+  };
+  const KSPROPERTY_VALUES* Values;
+  ULONG RelationsCount;
+  const KSPROPERTY* Relations;
+  PFNKSHANDLER SupportHandler;
+  ULONG SerializedSize;
+}KSPROPERTY_ITEM, * PKSPROPERTY_ITEM;
+
+ # define DEFINE_KSFASTPROPERTY_ITEM(PropertyId, GetHandler, SetHandler)  \
+  {                                   \
+    PropertyId, (PFNKSFASTHANDLER)GetHandler,   \
+    (PFNKSFASTHANDLER)SetHandler, 0         \
+  }
+
+typedef struct
+{
+  ULONG PropertyId;
+  __MINGW_EXTENSION union
+  {
+    PFNKSFASTHANDLER GetPropertyHandler;
+    BOOLEAN GetSupported;
+  };
+  __MINGW_EXTENSION union
+  {
+    PFNKSFASTHANDLER SetPropertyHandler;
+    BOOLEAN SetSupported;
+  };
+  ULONG Reserved;
+}KSFASTPROPERTY_ITEM, * PKSFASTPROPERTY_ITEM;
+
+ # define DEFINE_KSPROPERTY_SET(Set, PropertiesCount, PropertyItem, FastIoCount, FastIoTable) \
+  {                                   \
+    Set,                        \
+    PropertiesCount, PropertyItem,          \
+    FastIoCount, FastIoTable            \
+  }
+
+ # define DEFINE_KSPROPERTY_SET_TABLE(tablename)              \
+  const KSPROPERTY_SET tablename[] =
+
+typedef struct
+{
+  const GUID* Set;
+  ULONG PropertiesCount;
+  const KSPROPERTY_ITEM* PropertyItem;
+  ULONG FastIoCount;
+  const KSFASTPROPERTY_ITEM* FastIoTable;
+}KSPROPERTY_SET, * PKSPROPERTY_SET;
+
+ # define DEFINE_KSMETHOD_TABLE(tablename)                \
+  const KSMETHOD_ITEM tablename[] =
+
+ # define DEFINE_KSMETHOD_ITEM(MethodId, Flags, MethodHandler, MinMethod, MinData, SupportHandler) \
+  {                                   \
+    MethodId, (PFNKSHANDLER)MethodHandler,      \
+    MinMethod, MinData,             \
+    SupportHandler, Flags               \
+  }
+
+typedef struct
+{
+  ULONG MethodId;
+  __MINGW_EXTENSION union
+  {
+    PFNKSHANDLER MethodHandler;
+    BOOLEAN MethodSupported;
+  };
+  ULONG MinMethod;
+  ULONG MinData;
+  PFNKSHANDLER SupportHandler;
+  ULONG Flags;
+}KSMETHOD_ITEM, * PKSMETHOD_ITEM;
+
+ # define DEFINE_KSFASTMETHOD_ITEM(MethodId, MethodHandler)        \
+  {                                   \
+    MethodId, (PFNKSFASTHANDLER)MethodHandler   \
+  }
+
+typedef struct
+{
+  ULONG MethodId;
+  __MINGW_EXTENSION union
+  {
+    PFNKSFASTHANDLER MethodHandler;
+    BOOLEAN MethodSupported;
+  };
+}KSFASTMETHOD_ITEM, * PKSFASTMETHOD_ITEM;
+
+ # define DEFINE_KSMETHOD_SET(Set, MethodsCount, MethodItem, FastIoCount, FastIoTable) \
+  {                                   \
+    Set,                        \
+    MethodsCount, MethodItem,           \
+    FastIoCount, FastIoTable            \
+  }
+
+ # define DEFINE_KSMETHOD_SET_TABLE(tablename)                \
+  const KSMETHOD_SET tablename[] =
+
+typedef struct
+{
+  const GUID* Set;
+  ULONG MethodsCount;
+  const KSMETHOD_ITEM* MethodItem;
+  ULONG FastIoCount;
+  const KSFASTMETHOD_ITEM* FastIoTable;
+}KSMETHOD_SET, * PKSMETHOD_SET;
+
+typedef struct _KSEVENT_ENTRY KSEVENT_ENTRY, * PKSEVENT_ENTRY;
+typedef NTSTATUS (*PFNKSADDEVENT)(PIRP Irp, PKSEVENTDATA EventData,
+                                  struct _KSEVENT_ENTRY* EventEntry);
+typedef VOID (*PFNKSREMOVEEVENT)(PFILE_OBJECT FileObject,
+                                 struct _KSEVENT_ENTRY* EventEntry);
+
+ # define DEFINE_KSEVENT_TABLE(tablename)                 \
+  const KSEVENT_ITEM tablename[] =
+
+ # define DEFINE_KSEVENT_ITEM(EventId, DataInput, ExtraEntryData, AddHandler, RemoveHandler, SupportHandler) \
+  {                                   \
+    EventId, DataInput, ExtraEntryData,     \
+    AddHandler, RemoveHandler, SupportHandler   \
+  }
+
+typedef struct
+{
+  ULONG EventId;
+  ULONG DataInput;
+  ULONG ExtraEntryData;
+  PFNKSADDEVENT AddHandler;
+  PFNKSREMOVEEVENT RemoveHandler;
+  PFNKSHANDLER SupportHandler;
+}KSEVENT_ITEM, * PKSEVENT_ITEM;
+
+ # define DEFINE_KSEVENT_SET(Set, EventsCount, EventItem)           \
+  {                                   \
+    Set, EventsCount, EventItem         \
+  }
+
+ # define DEFINE_KSEVENT_SET_TABLE(tablename)             \
+  const KSEVENT_SET tablename[] =
+
+typedef struct
+{
+  const GUID* Set;
+  ULONG EventsCount;
+  const KSEVENT_ITEM* EventItem;
+}KSEVENT_SET, * PKSEVENT_SET;
+
+typedef struct
+{
+  KDPC Dpc;
+  ULONG ReferenceCount;
+  KSPIN_LOCK AccessLock;
+}KSDPC_ITEM, * PKSDPC_ITEM;
+
+typedef struct
+{
+  KSDPC_ITEM DpcItem;
+  LIST_ENTRY BufferList;
+}KSBUFFER_ITEM, * PKSBUFFER_ITEM;
+
+ # define KSEVENT_ENTRY_DELETED 1
+ # define KSEVENT_ENTRY_ONESHOT 2
+ # define KSEVENT_ENTRY_BUFFERED 4
+
+struct _KSEVENT_ENTRY
+{
+  LIST_ENTRY ListEntry;
+  PVOID Object;
+  __MINGW_EXTENSION union
+  {
+    PKSDPC_ITEM DpcItem;
+    PKSBUFFER_ITEM BufferItem;
+  };
+  PKSEVENTDATA EventData;
+  ULONG NotificationType;
+  const KSEVENT_SET* EventSet;
+  const KSEVENT_ITEM* EventItem;
+  PFILE_OBJECT FileObject;
+  ULONG SemaphoreAdjustment;
+  ULONG Reserved;
+  ULONG Flags;
+};
+
+typedef enum
+{
+  KSEVENTS_NONE,
+  KSEVENTS_SPINLOCK,
+  KSEVENTS_MUTEX,
+  KSEVENTS_FMUTEX,
+  KSEVENTS_FMUTEXUNSAFE,
+  KSEVENTS_INTERRUPT,
+  KSEVENTS_ERESOURCE
+}KSEVENTS_LOCKTYPE;
+
+ # define KSDISPATCH_FASTIO 0x80000000
+
+typedef struct
+{
+  PDRIVER_DISPATCH Create;
+  PVOID Context;
+  UNICODE_STRING ObjectClass;
+  PSECURITY_DESCRIPTOR SecurityDescriptor;
+  ULONG Flags;
+}KSOBJECT_CREATE_ITEM, * PKSOBJECT_CREATE_ITEM;
+
+typedef VOID (*PFNKSITEMFREECALLBACK)(PKSOBJECT_CREATE_ITEM CreateItem);
+
+ # define KSCREATE_ITEM_SECURITYCHANGED 0x00000001
+ # define KSCREATE_ITEM_WILDCARD 0x00000002
+ # define KSCREATE_ITEM_NOPARAMETERS 0x00000004
+ # define KSCREATE_ITEM_FREEONSTOP 0x00000008
+
+ # define DEFINE_KSCREATE_DISPATCH_TABLE(tablename)         \
+  KSOBJECT_CREATE_ITEM tablename[] =
+
+ # define DEFINE_KSCREATE_ITEM(DispatchCreate, TypeName, Context)       \
+  {                                   \
+    (DispatchCreate), (PVOID)(Context),     \
+    {                       \
+      sizeof(TypeName) - sizeof(UNICODE_NULL), \
+      sizeof(TypeName),           \
+      (PWCHAR)(TypeName)          \
+    },                      \
+    NULL, 0                     \
+  }
+
+ # define DEFINE_KSCREATE_ITEMEX(DispatchCreate, TypeName, Context, Flags)   \
+  {                                   \
+    (DispatchCreate),               \
+    (PVOID)(Context),               \
+    {                       \
+      sizeof(TypeName) - sizeof(UNICODE_NULL), \
+      sizeof(TypeName),           \
+      (PWCHAR)(TypeName)          \
+    },                      \
+    NULL, (Flags)                   \
+  }
+
+ # define DEFINE_KSCREATE_ITEMNULL(DispatchCreate, Context)        \
+  {                                   \
+    DispatchCreate, Context,            \
+    {                       \
+      0, 0, NULL,             \
+    },                      \
+    NULL, 0                     \
+  }
+
+typedef struct
+{
+  ULONG CreateItemsCount;
+  PKSOBJECT_CREATE_ITEM CreateItemsList;
+}KSOBJECT_CREATE, * PKSOBJECT_CREATE;
+
+typedef struct
+{
+  PDRIVER_DISPATCH DeviceIoControl;
+  PDRIVER_DISPATCH Read;
+  PDRIVER_DISPATCH Write;
+  PDRIVER_DISPATCH Flush;
+  PDRIVER_DISPATCH Close;
+  PDRIVER_DISPATCH QuerySecurity;
+  PDRIVER_DISPATCH SetSecurity;
+  PFAST_IO_DEVICE_CONTROL FastDeviceIoControl;
+  PFAST_IO_READ FastRead;
+  PFAST_IO_WRITE FastWrite;
+}KSDISPATCH_TABLE, * PKSDISPATCH_TABLE;
+
+ # define DEFINE_KSDISPATCH_TABLE(tablename, DeviceIoControl, Read, Write, Flush, Close, QuerySecurity, SetSecurity, FastDeviceIoControl, FastRead, FastWrite) \
+  const KSDISPATCH_TABLE tablename =              \
+  {                               \
+    DeviceIoControl,                    \
+    Read,                           \
+    Write,                          \
+    Flush,                          \
+    Close,                          \
+    QuerySecurity,                      \
+    SetSecurity,                        \
+    FastDeviceIoControl,                    \
+    FastRead,                       \
+    FastWrite,                      \
+  }
+
+ # define KSCREATE_ITEM_IRP_STORAGE(Irp)                  \
+  (*(PKSOBJECT_CREATE_ITEM*)&(Irp)->Tail.Overlay.DriverContext[0])
+ # define KSEVENT_SET_IRP_STORAGE(Irp)                    \
+  (*(const KSEVENT_SET**)&(Irp)->Tail.Overlay.DriverContext[0])
+ # define KSEVENT_ITEM_IRP_STORAGE(Irp)                   \
+  (*(const KSEVENT_ITEM**)&(Irp)->Tail.Overlay.DriverContext[3])
+ # define KSEVENT_ENTRY_IRP_STORAGE(Irp)                  \
+  (*(PKSEVENT_ENTRY*)&(Irp)->Tail.Overlay.DriverContext[0])
+ # define KSMETHOD_SET_IRP_STORAGE(Irp)                   \
+  (*(const KSMETHOD_SET**)&(Irp)->Tail.Overlay.DriverContext[0])
+ # define KSMETHOD_ITEM_IRP_STORAGE(Irp)                  \
+  (*(const KSMETHOD_ITEM**)&(Irp)->Tail.Overlay.DriverContext[3])
+ # define KSMETHOD_TYPE_IRP_STORAGE(Irp)                  \
+  (*(ULONG_PTR*)(&(Irp)->Tail.Overlay.DriverContext[2]))
+ # define KSQUEUE_SPINLOCK_IRP_STORAGE(Irp)               \
+  (*(PKSPIN_LOCK*)&(Irp)->Tail.Overlay.DriverContext[1])
+ # define KSPROPERTY_SET_IRP_STORAGE(Irp)                 \
+  (*(const KSPROPERTY_SET**)&(Irp)->Tail.Overlay.DriverContext[0])
+ # define KSPROPERTY_ITEM_IRP_STORAGE(Irp)                \
+  (*(const KSPROPERTY_ITEM**)&(Irp)->Tail.Overlay.DriverContext[3])
+ # define KSPROPERTY_ATTRIBUTES_IRP_STORAGE(Irp)              \
+  (*(PKSATTRIBUTE_LIST*)&(Irp)->Tail.Overlay.DriverContext[2])
+
+typedef PVOID KSDEVICE_HEADER, KSOBJECT_HEADER;
+
+typedef enum
+{
+  KsInvokeOnSuccess = 1,
+  KsInvokeOnError = 2,
+  KsInvokeOnCancel = 4
+}KSCOMPLETION_INVOCATION;
+
+typedef enum
+{
+  KsListEntryTail,
+  KsListEntryHead
+}KSLIST_ENTRY_LOCATION;
+
+typedef enum
+{
+  KsAcquireOnly,
+  KsAcquireAndRemove,
+  KsAcquireOnlySingleItem,
+  KsAcquireAndRemoveOnlySingleItem
+}KSIRP_REMOVAL_OPERATION;
+
+typedef enum
+{
+  KsStackCopyToNewLocation,
+  KsStackReuseCurrentLocation,
+  KsStackUseNewLocation
+}KSSTACK_USE;
+
+typedef enum
+{
+  KSTARGET_STATE_DISABLED,
+  KSTARGET_STATE_ENABLED
+}KSTARGET_STATE;
+
+typedef NTSTATUS (*PFNKSIRPLISTCALLBACK)(PIRP Irp, PVOID Context);
+typedef VOID (*PFNREFERENCEDEVICEOBJECT)(PVOID Context);
+typedef VOID (*PFNDEREFERENCEDEVICEOBJECT)(PVOID Context);
+typedef NTSTATUS (*PFNQUERYREFERENCESTRING)(PVOID Context, PWCHAR* String);
+
+ # define BUS_INTERFACE_REFERENCE_VERSION 0x100
+
+typedef struct
+{
+  INTERFACE Interface;
+
+  PFNREFERENCEDEVICEOBJECT ReferenceDeviceObject;
+  PFNDEREFERENCEDEVICEOBJECT DereferenceDeviceObject;
+  PFNQUERYREFERENCESTRING QueryReferenceString;
+}BUS_INTERFACE_REFERENCE, * PBUS_INTERFACE_REFERENCE;
+
+ # define STATIC_REFERENCE_BUS_INTERFACE STATIC_KSMEDIUMSETID_Standard
+ # define REFERENCE_BUS_INTERFACE KSMEDIUMSETID_Standard
+
+#endif /* _NTDDK_ */
+
+#ifndef PACK_PRAGMAS_NOT_SUPPORTED
+ # include <pshpack1.h>
+#endif
+
+typedef struct
+{
+  GUID PropertySet;
+  ULONG Count;
+}KSPROPERTY_SERIALHDR, * PKSPROPERTY_SERIALHDR;
+
+#ifndef PACK_PRAGMAS_NOT_SUPPORTED
+ # include <poppack.h>
+#endif
+
+typedef struct
+{
+  KSIDENTIFIER PropTypeSet;
+  ULONG Id;
+  ULONG PropertyLength;
+}KSPROPERTY_SERIAL, * PKSPROPERTY_SERIAL;
+
+#if defined(_NTDDK_)
+
+ # define IOCTL_KS_HANDSHAKE                      \
+  CTL_CODE(FILE_DEVICE_KS, 0x007, METHOD_NEITHER, FILE_ANY_ACCESS)
+
+typedef struct
+{
+  GUID ProtocolId;
+  PVOID Argument1;
+  PVOID Argument2;
+}KSHANDSHAKE, * PKSHANDSHAKE;
+
+typedef struct _KSGATE KSGATE, * PKSGATE;
+
+struct _KSGATE
+{
+  LONG Count;
+  PKSGATE NextGate;
+};
+
+typedef PVOID KSOBJECT_BAG;
+
+typedef BOOLEAN (*PFNKSGENERATEEVENTCALLBACK)(PVOID Context,
+                                              PKSEVENT_ENTRY EventEntry);
+
+typedef NTSTATUS (*PFNKSDEVICECREATE)(PKSDEVICE Device);
+
+typedef NTSTATUS (*PFNKSDEVICEPNPSTART)(PKSDEVICE Device, PIRP Irp,
+                                        PCM_RESOURCE_LIST TranslatedResourceList,
+                                        PCM_RESOURCE_LIST UntranslatedResourceList);
+
+typedef NTSTATUS (*PFNKSDEVICE)(PKSDEVICE Device);
+
+typedef NTSTATUS (*PFNKSDEVICEIRP)(PKSDEVICE Device, PIRP Irp);
+
+typedef void (*PFNKSDEVICEIRPVOID)(PKSDEVICE Device, PIRP Irp);
+
+typedef NTSTATUS (*PFNKSDEVICEQUERYCAPABILITIES)(PKSDEVICE Device, PIRP Irp,
+                                                 PDEVICE_CAPABILITIES Capabilities);
+
+typedef NTSTATUS (*PFNKSDEVICEQUERYPOWER)(PKSDEVICE Device, PIRP Irp,
+                                          DEVICE_POWER_STATE DeviceTo,
+                                          DEVICE_POWER_STATE DeviceFrom,
+                                          SYSTEM_POWER_STATE SystemTo,
+                                          SYSTEM_POWER_STATE SystemFrom,
+                                          POWER_ACTION Action);
+
+typedef void (*PFNKSDEVICESETPOWER)(PKSDEVICE Device, PIRP Irp,
+                                    DEVICE_POWER_STATE To,
+                                    DEVICE_POWER_STATE From);
+
+typedef NTSTATUS (*PFNKSFILTERFACTORYVOID)(PKSFILTERFACTORY FilterFactory);
+
+typedef void (*PFNKSFILTERFACTORYPOWER)(PKSFILTERFACTORY FilterFactory,
+                                        DEVICE_POWER_STATE State);
+
+typedef NTSTATUS (*PFNKSFILTERIRP)(PKSFILTER Filter, PIRP Irp);
+
+typedef NTSTATUS (*PFNKSFILTERPROCESS)(PKSFILTER Filter,
+                                       PKSPROCESSPIN_INDEXENTRY Index);
+
+typedef NTSTATUS (*PFNKSFILTERVOID)(PKSFILTER Filter);
+
+typedef void (*PFNKSFILTERPOWER)(PKSFILTER Filter, DEVICE_POWER_STATE State);
+
+typedef NTSTATUS (*PFNKSPINIRP)(PKSPIN Pin, PIRP Irp);
+
+typedef NTSTATUS (*PFNKSPINSETDEVICESTATE)(PKSPIN Pin, KSSTATE ToState,
+                                           KSSTATE FromState);
+
+typedef NTSTATUS (*PFNKSPINSETDATAFORMAT)(PKSPIN Pin, PKSDATAFORMAT OldFormat,
+                                          PKSMULTIPLE_ITEM OldAttributeList,
+                                          const KSDATARANGE* DataRange,
+                                          const KSATTRIBUTE_LIST* AttributeRange);
+
+typedef NTSTATUS (*PFNKSPINHANDSHAKE)(PKSPIN Pin, PKSHANDSHAKE In,
+                                      PKSHANDSHAKE Out);
+
+typedef NTSTATUS (*PFNKSPIN)(PKSPIN Pin);
+
+typedef void (*PFNKSPINVOID)(PKSPIN Pin);
+
+typedef void (*PFNKSPINPOWER)(PKSPIN Pin, DEVICE_POWER_STATE State);
+
+typedef BOOLEAN (*PFNKSPINSETTIMER)(PKSPIN Pin, PKTIMER Timer,
+                                    LARGE_INTEGER DueTime, PKDPC Dpc);
+
+typedef BOOLEAN (*PFNKSPINCANCELTIMER)(PKSPIN Pin, PKTIMER Timer);
+
+typedef LONGLONG (FASTCALL * PFNKSPINCORRELATEDTIME)(PKSPIN Pin,
+                                                     PLONGLONG SystemTime);
+
+typedef void (*PFNKSPINRESOLUTION)(PKSPIN Pin, PKSRESOLUTION Resolution);
+
+typedef NTSTATUS (*PFNKSPININITIALIZEALLOCATOR)(PKSPIN Pin,
+                                                PKSALLOCATOR_FRAMING AllocatorFraming,
+                                                PVOID* Context);
+
+typedef void (*PFNKSSTREAMPOINTER)(PKSSTREAM_POINTER StreamPointer);
+
+typedef struct KSAUTOMATION_TABLE_ KSAUTOMATION_TABLE, * PKSAUTOMATION_TABLE;
+
+struct KSAUTOMATION_TABLE_
+{
+  ULONG PropertySetsCount;
+  ULONG PropertyItemSize;
+  const KSPROPERTY_SET* PropertySets;
+  ULONG MethodSetsCount;
+  ULONG MethodItemSize;
+  const KSMETHOD_SET* MethodSets;
+  ULONG EventSetsCount;
+  ULONG EventItemSize;
+  const KSEVENT_SET* EventSets;
+ # ifndef _WIN64
+  PVOID Alignment;
+ # endif
+};
+
+ # define DEFINE_KSAUTOMATION_TABLE(table)                \
+  const KSAUTOMATION_TABLE table =
+
+ # define DEFINE_KSAUTOMATION_PROPERTIES(table)               \
+  SIZEOF_ARRAY(table),                    \
+  sizeof(KSPROPERTY_ITEM),                \
+  table
+
+ # define DEFINE_KSAUTOMATION_METHODS(table)              \
+  SIZEOF_ARRAY(table),                    \
+  sizeof(KSMETHOD_ITEM),                  \
+  table
+
+ # define DEFINE_KSAUTOMATION_EVENTS(table)               \
+  SIZEOF_ARRAY(table),                    \
+  sizeof(KSEVENT_ITEM),                   \
+  table
+
+ # define DEFINE_KSAUTOMATION_PROPERTIES_NULL             \
+  0,                          \
+  sizeof(KSPROPERTY_ITEM),                \
+  NULL
+
+ # define DEFINE_KSAUTOMATION_METHODS_NULL                \
+  0,                          \
+  sizeof(KSMETHOD_ITEM),                  \
+  NULL
+
+ # define DEFINE_KSAUTOMATION_EVENTS_NULL                 \
+  0,                          \
+  sizeof(KSEVENT_ITEM),                   \
+  NULL
+
+ # define MIN_DEV_VER_FOR_QI (0x100)
+
+struct _KSDEVICE_DISPATCH
+{
+  PFNKSDEVICECREATE Add;
+  PFNKSDEVICEPNPSTART Start;
+  PFNKSDEVICE PostStart;
+  PFNKSDEVICEIRP QueryStop;
+  PFNKSDEVICEIRPVOID CancelStop;
+  PFNKSDEVICEIRPVOID Stop;
+  PFNKSDEVICEIRP QueryRemove;
+  PFNKSDEVICEIRPVOID CancelRemove;
+  PFNKSDEVICEIRPVOID Remove;
+  PFNKSDEVICEQUERYCAPABILITIES QueryCapabilities;
+  PFNKSDEVICEIRPVOID SurpriseRemoval;
+  PFNKSDEVICEQUERYPOWER QueryPower;
+  PFNKSDEVICESETPOWER SetPower;
+  PFNKSDEVICEIRP QueryInterface;
+};
+
+struct _KSFILTER_DISPATCH
+{
+  PFNKSFILTERIRP Create;
+  PFNKSFILTERIRP Close;
+  PFNKSFILTERPROCESS Process;
+  PFNKSFILTERVOID Reset;
+};
+
+struct _KSPIN_DISPATCH
+{
+  PFNKSPINIRP Create;
+  PFNKSPINIRP Close;
+  PFNKSPIN Process;
+  PFNKSPINVOID Reset;
+  PFNKSPINSETDATAFORMAT SetDataFormat;
+  PFNKSPINSETDEVICESTATE SetDeviceState;
+  PFNKSPIN Connect;
+  PFNKSPINVOID Disconnect;
+  const KSCLOCK_DISPATCH* Clock;
+  const KSALLOCATOR_DISPATCH* Allocator;
+};
+
+struct _KSCLOCK_DISPATCH
+{
+  PFNKSPINSETTIMER SetTimer;
+  PFNKSPINCANCELTIMER CancelTimer;
+  PFNKSPINCORRELATEDTIME CorrelatedTime;
+  PFNKSPINRESOLUTION Resolution;
+};
+
+struct _KSALLOCATOR_DISPATCH
+{
+  PFNKSPININITIALIZEALLOCATOR InitializeAllocator;
+  PFNKSDELETEALLOCATOR DeleteAllocator;
+  PFNKSDEFAULTALLOCATE Allocate;
+  PFNKSDEFAULTFREE Free;
+};
+
+ # define KSDEVICE_DESCRIPTOR_VERSION (0x100)
+
+struct _KSDEVICE_DESCRIPTOR
+{
+  const KSDEVICE_DISPATCH* Dispatch;
+  ULONG FilterDescriptorsCount;
+  const KSFILTER_DESCRIPTOR* const* FilterDescriptors;
+  ULONG Version;
+};
+
+struct _KSFILTER_DESCRIPTOR
+{
+  const KSFILTER_DISPATCH* Dispatch;
+  const KSAUTOMATION_TABLE* AutomationTable;
+  ULONG Version;
+ # define KSFILTER_DESCRIPTOR_VERSION ((ULONG)-1)
+  ULONG Flags;
+ # define KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING 0x00000001
+ # define KSFILTER_FLAG_CRITICAL_PROCESSING 0x00000002
+ # define KSFILTER_FLAG_HYPERCRITICAL_PROCESSING 0x00000004
+ # define KSFILTER_FLAG_RECEIVE_ZERO_LENGTH_SAMPLES 0x00000008
+ # define KSFILTER_FLAG_DENY_USERMODE_ACCESS 0x80000000
+  const GUID* ReferenceGuid;
+  ULONG PinDescriptorsCount;
+  ULONG PinDescriptorSize;
+  const KSPIN_DESCRIPTOR_EX* PinDescriptors;
+  ULONG CategoriesCount;
+  const GUID* Categories;
+  ULONG NodeDescriptorsCount;
+  ULONG NodeDescriptorSize;
+  const KSNODE_DESCRIPTOR* NodeDescriptors;
+  ULONG ConnectionsCount;
+  const KSTOPOLOGY_CONNECTION* Connections;
+  const KSCOMPONENTID* ComponentId;
+};
+
+ # define DEFINE_KSFILTER_DESCRIPTOR(descriptor)              \
+  const KSFILTER_DESCRIPTOR descriptor =
+
+ # define DEFINE_KSFILTER_PIN_DESCRIPTORS(table)              \
+  SIZEOF_ARRAY(table),                        \
+  sizeof(table[0]),                       \
+  table
+
+ # define DEFINE_KSFILTER_CATEGORIES(table)               \
+  SIZEOF_ARRAY(table),                        \
+  table
+
+ # define DEFINE_KSFILTER_CATEGORY(category)              \
+  1,                              \
+  &(category)
+
+ # define DEFINE_KSFILTER_CATEGORIES_NULL                 \
+  0,                              \
+  NULL
+
+ # define DEFINE_KSFILTER_NODE_DESCRIPTORS(table)             \
+  SIZEOF_ARRAY(table),                        \
+  sizeof(table[0]),                       \
+  table
+
+ # define DEFINE_KSFILTER_NODE_DESCRIPTORS_NULL               \
+  0,                              \
+  sizeof(KSNODE_DESCRIPTOR),                  \
+  NULL
+
+ # define DEFINE_KSFILTER_CONNECTIONS(table)              \
+  SIZEOF_ARRAY(table),                        \
+  table
+
+ # define DEFINE_KSFILTER_DEFAULT_CONNECTIONS             \
+  0,                              \
+  NULL
+
+ # define DEFINE_KSFILTER_DESCRIPTOR_TABLE(table)             \
+  const KSFILTER_DESCRIPTOR * const table[] =
+
+struct _KSPIN_DESCRIPTOR_EX
+{
+  const KSPIN_DISPATCH* Dispatch;
+  const KSAUTOMATION_TABLE* AutomationTable;
+  KSPIN_DESCRIPTOR PinDescriptor;
+  ULONG Flags;
+ # define KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING
+ # define KSPIN_FLAG_CRITICAL_PROCESSING KSFILTER_FLAG_CRITICAL_PROCESSING
+ # define KSPIN_FLAG_HYPERCRITICAL_PROCESSING KSFILTER_FLAG_HYPERCRITICAL_PROCESSING
+ # define KSPIN_FLAG_ASYNCHRONOUS_PROCESSING 0x00000008
+ # define KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING 0x00000010
+ # define KSPIN_FLAG_INITIATE_PROCESSING_ON_EVERY_ARRIVAL 0x00000020
+ # define KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING 0x00000040
+ # define KSPIN_FLAG_ENFORCE_FIFO 0x00000080
+ # define KSPIN_FLAG_GENERATE_MAPPINGS 0x00000100
+ # define KSPIN_FLAG_DISTINCT_TRAILING_EDGE 0x00000200
+ # define KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY 0x00010000
+ # define KSPIN_FLAG_SPLITTER 0x00020000
+ # define KSPIN_FLAG_USE_STANDARD_TRANSPORT 0x00040000
+ # define KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT 0x00080000
+ # define KSPIN_FLAG_FIXED_FORMAT 0x00100000
+ # define KSPIN_FLAG_GENERATE_EOS_EVENTS 0x00200000
+ # define KSPIN_FLAG_RENDERER (KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY | KSPIN_FLAG_GENERATE_EOS_EVENTS)
+ # define KSPIN_FLAG_IMPLEMENT_CLOCK 0x00400000
+ # define KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING 0x00800000
+ # define KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE 0x01000000
+ # define KSPIN_FLAG_DENY_USERMODE_ACCESS 0x80000000
+  ULONG InstancesPossible;
+  ULONG InstancesNecessary;
+  const KSALLOCATOR_FRAMING_EX* AllocatorFraming;
+  PFNKSINTERSECTHANDLEREX IntersectHandler;
+};
+
+ # define DEFINE_KSPIN_DEFAULT_INTERFACES                 \
+  0,                              \
+  NULL
+
+ # define DEFINE_KSPIN_DEFAULT_MEDIUMS                    \
+  0,                              \
+  NULL
+
+struct _KSNODE_DESCRIPTOR
+{
+  const KSAUTOMATION_TABLE* AutomationTable;
+  const GUID* Type;
+  const GUID* Name;
+ # ifndef _WIN64
+  PVOID Alignment;
+ # endif
+};
+
+ # ifndef _WIN64
+  #  define DEFINE_NODE_DESCRIPTOR(automation, type, name)            \
+  { (automation), (type), (name), NULL }
+ # else
+  #  define DEFINE_NODE_DESCRIPTOR(automation, type, name)            \
+  { (automation), (type), (name) }
+ # endif
+
+struct _KSDEVICE
+{
+  const KSDEVICE_DESCRIPTOR* Descriptor;
+  KSOBJECT_BAG Bag;
+  PVOID Context;
+  PDEVICE_OBJECT FunctionalDeviceObject;
+  PDEVICE_OBJECT PhysicalDeviceObject;
+  PDEVICE_OBJECT NextDeviceObject;
+  BOOLEAN Started;
+  SYSTEM_POWER_STATE SystemPowerState;
+  DEVICE_POWER_STATE DevicePowerState;
+};
+
+struct _KSFILTERFACTORY
+{
+  const KSFILTER_DESCRIPTOR* FilterDescriptor;
+  KSOBJECT_BAG Bag;
+  PVOID Context;
+};
+
+struct _KSFILTER
+{
+  const KSFILTER_DESCRIPTOR* Descriptor;
+  KSOBJECT_BAG Bag;
+  PVOID Context;
+};
+
+struct _KSPIN
+{
+  const KSPIN_DESCRIPTOR_EX* Descriptor;
+  KSOBJECT_BAG Bag;
+  PVOID Context;
+  ULONG Id;
+  KSPIN_COMMUNICATION Communication;
+  BOOLEAN ConnectionIsExternal;
+  KSPIN_INTERFACE ConnectionInterface;
+  KSPIN_MEDIUM ConnectionMedium;
+  KSPRIORITY ConnectionPriority;
+  PKSDATAFORMAT ConnectionFormat;
+  PKSMULTIPLE_ITEM AttributeList;
+  ULONG StreamHeaderSize;
+  KSPIN_DATAFLOW DataFlow;
+  KSSTATE DeviceState;
+  KSRESET ResetState;
+  KSSTATE ClientState;
+};
+
+struct _KSMAPPING
+{
+  PHYSICAL_ADDRESS PhysicalAddress;
+  ULONG ByteCount;
+  ULONG Alignment;
+};
+
+struct _KSSTREAM_POINTER_OFFSET
+{
+ # if defined(_NTDDK_)
+  __MINGW_EXTENSION union
+  {
+    PUCHAR Data;
+    PKSMAPPING Mappings;
+  };
+ # else
+  PUCHAR Data;
+ # endif /* _NTDDK_ */
+ # ifndef _WIN64
+  PVOID Alignment;
+ # endif
+  ULONG Count;
+  ULONG Remaining;
+};
+
+struct _KSSTREAM_POINTER
+{
+  PVOID Context;
+  PKSPIN Pin;
+  PKSSTREAM_HEADER StreamHeader;
+  PKSSTREAM_POINTER_OFFSET Offset;
+  KSSTREAM_POINTER_OFFSET OffsetIn;
+  KSSTREAM_POINTER_OFFSET OffsetOut;
+};
+
+struct _KSPROCESSPIN
+{
+  PKSPIN Pin;
+  PKSSTREAM_POINTER StreamPointer;
+  PKSPROCESSPIN InPlaceCounterpart;
+  PKSPROCESSPIN DelegateBranch;
+  PKSPROCESSPIN CopySource;
+  PVOID Data;
+  ULONG BytesAvailable;
+  ULONG BytesUsed;
+  ULONG Flags;
+  BOOLEAN Terminate;
+};
+
+struct _KSPROCESSPIN_INDEXENTRY
+{
+  PKSPROCESSPIN* Pins;
+  ULONG Count;
+};
+
+typedef enum
+{
+  KsObjectTypeDevice,
+  KsObjectTypeFilterFactory,
+  KsObjectTypeFilter,
+  KsObjectTypePin
+}KSOBJECTTYPE;
+
+typedef void (*PFNKSFREE)(PVOID Data);
+
+typedef void (*PFNKSPINFRAMERETURN)(PKSPIN Pin, PVOID Data, ULONG Size, PMDL Mdl,
+                                    PVOID Context, NTSTATUS Status);
+
+typedef void (*PFNKSPINIRPCOMPLETION)(PKSPIN Pin, PIRP Irp);
+
+ # if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)
+  #  ifndef _IKsControl_
+   #   define _IKsControl_
+
+typedef struct IKsControl* PIKSCONTROL;
+
+   #   ifndef DEFINE_ABSTRACT_UNKNOWN
+    #    define DEFINE_ABSTRACT_UNKNOWN()                   \
+  STDMETHOD_(NTSTATUS, QueryInterface) (THIS_          \
+                                        REFIID InterfaceId, \
+                                        PVOID * Interface    \
+                                        )PURE;         \
+  STDMETHOD_(ULONG, AddRef) (THIS)PURE;                \
+  STDMETHOD_(ULONG, Release) (THIS)PURE;
+   #   endif
+
+   #   undef INTERFACE
+   #   define INTERFACE IKsControl
+DECLARE_INTERFACE_(IKsControl, IUnknown)
+{
+  DEFINE_ABSTRACT_UNKNOWN()
+  STDMETHOD_(NTSTATUS, KsProperty) (THIS_
+                                    PKSPROPERTY Property,
+                                    ULONG PropertyLength,
+                                    PVOID PropertyData,
+                                    ULONG DataLength,
+                                    ULONG * BytesReturned
+                                    ) PURE;
+  STDMETHOD_(NTSTATUS, KsMethod) (THIS_
+                                  PKSMETHOD Method,
+                                  ULONG MethodLength,
+                                  PVOID MethodData,
+                                  ULONG DataLength,
+                                  ULONG * BytesReturned
+                                  ) PURE;
+  STDMETHOD_(NTSTATUS, KsEvent)  (THIS_
+                                  PKSEVENT Event,
+                                  ULONG EventLength,
+                                  PVOID EventData,
+                                  ULONG DataLength,
+                                  ULONG * BytesReturned
+                                  ) PURE;
+};
+typedef struct IKsReferenceClock* PIKSREFERENCECLOCK;
+
+   #   undef INTERFACE
+   #   define INTERFACE IKsReferenceClock
+DECLARE_INTERFACE_(IKsReferenceClock, IUnknown)
+{
+  DEFINE_ABSTRACT_UNKNOWN()
+  STDMETHOD_(LONGLONG, GetTime)      (THIS) PURE;
+  STDMETHOD_(LONGLONG, GetPhysicalTime)  (THIS) PURE;
+  STDMETHOD_(LONGLONG, GetCorrelatedTime) (THIS_
+                                           PLONGLONG SystemTime
+                                           ) PURE;
+  STDMETHOD_(LONGLONG, GetCorrelatedPhysicalTime) (THIS_
+                                                   PLONGLONG SystemTime
+                                                   ) PURE;
+  STDMETHOD_(NTSTATUS, GetResolution)    (THIS_
+                                          PKSRESOLUTION Resolution
+                                          ) PURE;
+  STDMETHOD_(NTSTATUS, GetState)     (THIS_
+                                      PKSSTATE State
+                                      ) PURE;
+};
+   #   undef INTERFACE
+
+   #   define INTERFACE IKsDeviceFunctions
+DECLARE_INTERFACE_(IKsDeviceFunctions, IUnknown)
+{
+  DEFINE_ABSTRACT_UNKNOWN()
+  STDMETHOD_(NTSTATUS, RegisterAdapterObjectEx)  (THIS_
+                                                  PADAPTER_OBJECT AdapterObject,
+                                                  PDEVICE_DESCRIPTION DeviceDescription,
+                                                  ULONG NumberOfMapRegisters,
+                                                  ULONG MaxMappingsByteCount,
+                                                  ULONG MappingTableStride
+                                                  ) PURE;
+};
+
+   #   undef INTERFACE
+   #   define STATIC_IID_IKsControl                       \
+  0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
+DEFINE_GUID(IID_IKsControl,
+            0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);
+   #   define STATIC_IID_IKsFastClock                     \
+  0xc9902485, 0xc180, 0x11d2, 0x84, 0x73, 0xd4, 0x23, 0x94, 0x45, 0x9e, 0x5e
+DEFINE_GUID(IID_IKsFastClock,
+            0xc9902485, 0xc180, 0x11d2, 0x84, 0x73, 0xd4, 0x23, 0x94, 0x45, 0x9e, 0x5e);
+   #   define STATIC_IID_IKsDeviceFunctions                   \
+  0xe234f2e2, 0xbd69, 0x4f8c, 0xb3, 0xf2, 0x7c, 0xd7, 0x9e, 0xd4, 0x66, 0xbd
+DEFINE_GUID(IID_IKsDeviceFunctions,
+            0xe234f2e2, 0xbd69, 0x4f8c, 0xb3, 0xf2, 0x7c, 0xd7, 0x9e, 0xd4, 0x66, 0xbd);
+  #  endif /* _IKsControl_ */
+ # endif /* defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__) */
+
+#endif /* _NTDDK_ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef _KSDDK_
+ # define KSDDKAPI
+#else
+ # define KSDDKAPI DECLSPEC_IMPORT
+#endif
+
+#if defined(_NTDDK_)
+
+KSDDKAPI NTSTATUS NTAPI KsEnableEvent(PIRP Irp, ULONG EventSetsCount, const KSEVENT_SET* EventSet, PLIST_ENTRY EventsList, KSEVENTS_LOCKTYPE EventsFlags, PVOID EventsLock);
+
+KSDDKAPI NTSTATUS NTAPI KsEnableEventWithAllocator(PIRP Irp, ULONG EventSetsCount, const KSEVENT_SET* EventSet, PLIST_ENTRY EventsList, KSEVENTS_LOCKTYPE EventsFlags, PVOID EventsLock, PFNKSALLOCATOR Allocator, ULONG EventItemSize);
+
+KSDDKAPI NTSTATUS NTAPI KsDisableEvent(PIRP Irp, PLIST_ENTRY EventsList, KSEVENTS_LOCKTYPE EventsFlags, PVOID EventsLock);
+
+KSDDKAPI VOID NTAPI KsDiscardEvent(PKSEVENT_ENTRY EventEntry);
+
+KSDDKAPI VOID NTAPI KsFreeEventList(PFILE_OBJECT FileObject, PLIST_ENTRY EventsList, KSEVENTS_LOCKTYPE EventsFlags, PVOID EventsLock);
+
+KSDDKAPI NTSTATUS NTAPI KsGenerateEvent(PKSEVENT_ENTRY EventEntry);
+
+KSDDKAPI NTSTATUS NTAPI KsGenerateDataEvent(PKSEVENT_ENTRY EventEntry, ULONG DataSize, PVOID Data);
+
+KSDDKAPI VOID NTAPI KsGenerateEventList(GUID* Set, ULONG EventId, PLIST_ENTRY EventsList, KSEVENTS_LOCKTYPE EventsFlags, PVOID EventsLock);
+
+KSDDKAPI NTSTATUS NTAPI KsPropertyHandler(PIRP Irp, ULONG PropertySetsCount, const KSPROPERTY_SET* PropertySet);
+
+KSDDKAPI NTSTATUS NTAPI KsPropertyHandlerWithAllocator(PIRP Irp, ULONG PropertySetsCount, const KSPROPERTY_SET* PropertySet, PFNKSALLOCATOR Allocator, ULONG PropertyItemSize);
+
+KSDDKAPI BOOLEAN NTAPI KsFastPropertyHandler(PFILE_OBJECT FileObject, PKSPROPERTY Property, ULONG PropertyLength, PVOID Data, ULONG DataLength, PIO_STATUS_BLOCK IoStatus, ULONG PropertySetsCount, const KSPROPERTY_SET* PropertySet);
+
+KSDDKAPI NTSTATUS NTAPI KsMethodHandler(PIRP Irp, ULONG MethodSetsCount, const KSMETHOD_SET* MethodSet);
+
+KSDDKAPI NTSTATUS NTAPI KsMethodHandlerWithAllocator(PIRP Irp, ULONG MethodSetsCount, const KSMETHOD_SET* MethodSet, PFNKSALLOCATOR Allocator, ULONG MethodItemSize);
+
+KSDDKAPI BOOLEAN NTAPI KsFastMethodHandler(PFILE_OBJECT FileObject, PKSMETHOD Method, ULONG MethodLength, PVOID Data, ULONG DataLength, PIO_STATUS_BLOCK IoStatus, ULONG MethodSetsCount, const KSMETHOD_SET* MethodSet);
+
+KSDDKAPI NTSTATUS NTAPI KsCreateDefaultAllocator(PIRP Irp);
+
+KSDDKAPI NTSTATUS NTAPI KsCreateDefaultAllocatorEx(PIRP Irp, PVOID InitializeContext, PFNKSDEFAULTALLOCATE DefaultAllocate, PFNKSDEFAULTFREE DefaultFree, PFNKSINITIALIZEALLOCATOR InitializeAllocator, PFNKSDELETEALLOCATOR DeleteAllocator);
+
+KSDDKAPI NTSTATUS NTAPI KsCreateAllocator(HANDLE ConnectionHandle, PKSALLOCATOR_FRAMING AllocatorFraming, PHANDLE AllocatorHandle);
+
+KSDDKAPI NTSTATUS NTAPI KsValidateAllocatorCreateRequest(PIRP Irp, PKSALLOCATOR_FRAMING* AllocatorFraming);
+
+KSDDKAPI NTSTATUS NTAPI KsValidateAllocatorFramingEx(PKSALLOCATOR_FRAMING_EX Framing, ULONG BufferSize, const KSALLOCATOR_FRAMING_EX* PinFraming);
+
+KSDDKAPI NTSTATUS NTAPI KsAllocateDefaultClock(PKSDEFAULTCLOCK* DefaultClock);
+
+KSDDKAPI NTSTATUS NTAPI KsAllocateDefaultClockEx(PKSDEFAULTCLOCK* DefaultClock, PVOID Context, PFNKSSETTIMER SetTimer, PFNKSCANCELTIMER CancelTimer, PFNKSCORRELATEDTIME CorrelatedTime, const KSRESOLUTION* Resolution, ULONG Flags);
+
+KSDDKAPI VOID NTAPI KsFreeDefaultClock(PKSDEFAULTCLOCK DefaultClock);
+KSDDKAPI NTSTATUS NTAPI KsCreateDefaultClock(PIRP Irp, PKSDEFAULTCLOCK DefaultClock);
+
+KSDDKAPI NTSTATUS NTAPI KsCreateClock(HANDLE ConnectionHandle, PKSCLOCK_CREATE ClockCreate, PHANDLE ClockHandle);
+
+KSDDKAPI NTSTATUS NTAPI KsValidateClockCreateRequest(PIRP Irp, PKSCLOCK_CREATE* ClockCreate);
+
+KSDDKAPI KSSTATE NTAPI KsGetDefaultClockState(PKSDEFAULTCLOCK DefaultClock);
+KSDDKAPI VOID NTAPI KsSetDefaultClockState(PKSDEFAULTCLOCK DefaultClock, KSSTATE State);
+KSDDKAPI LONGLONG NTAPI KsGetDefaultClockTime(PKSDEFAULTCLOCK DefaultClock);
+KSDDKAPI VOID NTAPI KsSetDefaultClockTime(PKSDEFAULTCLOCK DefaultClock, LONGLONG Time);
+
+KSDDKAPI NTSTATUS NTAPI KsCreatePin(HANDLE FilterHandle, PKSPIN_CONNECT Connect, ACCESS_MASK DesiredAccess, PHANDLE ConnectionHandle);
+
+KSDDKAPI NTSTATUS NTAPI KsValidateConnectRequest(PIRP Irp, ULONG DescriptorsCount, const KSPIN_DESCRIPTOR* Descriptor, PKSPIN_CONNECT* Connect);
+
+KSDDKAPI NTSTATUS NTAPI KsPinPropertyHandler(PIRP Irp, PKSPROPERTY Property, PVOID Data, ULONG DescriptorsCount, const KSPIN_DESCRIPTOR* Descriptor);
+
+KSDDKAPI NTSTATUS NTAPI KsPinDataIntersection(PIRP Irp, PKSP_PIN Pin, PVOID Data, ULONG DescriptorsCount, const KSPIN_DESCRIPTOR* Descriptor, PFNKSINTERSECTHANDLER IntersectHandler);
+
+KSDDKAPI NTSTATUS NTAPI KsPinDataIntersectionEx(PIRP Irp, PKSP_PIN Pin, PVOID Data, ULONG DescriptorsCount, const KSPIN_DESCRIPTOR* Descriptor, ULONG DescriptorSize, PFNKSINTERSECTHANDLEREX IntersectHandler, PVOID HandlerContext);
+
+KSDDKAPI NTSTATUS NTAPI KsHandleSizedListQuery(PIRP Irp, ULONG DataItemsCount, ULONG DataItemSize, const VOID* DataItems);
+
+ # ifndef MAKEINTRESOURCE
+  #  define MAKEINTRESOURCE(r) ((ULONG_PTR)(USHORT)r)
+ # endif
+ # ifndef RT_STRING
+  #  define RT_STRING MAKEINTRESOURCE(6)
+  #  define RT_RCDATA MAKEINTRESOURCE(10)
+ # endif
+
+KSDDKAPI NTSTATUS NTAPI KsLoadResource(PVOID ImageBase, POOL_TYPE PoolType, ULONG_PTR ResourceName, ULONG ResourceType, PVOID* Resource, PULONG ResourceSize);
+
+KSDDKAPI NTSTATUS NTAPI KsGetImageNameAndResourceId(HANDLE RegKey, PUNICODE_STRING ImageName, PULONG_PTR ResourceId, PULONG ValueType);
+
+KSDDKAPI NTSTATUS NTAPI KsMapModuleName(PDEVICE_OBJECT PhysicalDeviceObject, PUNICODE_STRING ModuleName, PUNICODE_STRING ImageName, PULONG_PTR ResourceId, PULONG ValueType);
+
+KSDDKAPI NTSTATUS NTAPI KsReferenceBusObject(KSDEVICE_HEADER Header);
+KSDDKAPI VOID NTAPI KsDereferenceBusObject(KSDEVICE_HEADER Header);
+KSDDKAPI NTSTATUS NTAPI KsDispatchQuerySecurity(PDEVICE_OBJECT DeviceObject, PIRP Irp);
+KSDDKAPI NTSTATUS NTAPI KsDispatchSetSecurity(PDEVICE_OBJECT DeviceObject, PIRP Irp);
+KSDDKAPI NTSTATUS NTAPI KsDispatchSpecificProperty(PIRP Irp, PFNKSHANDLER Handler);
+KSDDKAPI NTSTATUS NTAPI KsDispatchSpecificMethod(PIRP Irp, PFNKSHANDLER Handler);
+
+KSDDKAPI NTSTATUS NTAPI KsReadFile(PFILE_OBJECT FileObject, PKEVENT Event, PVOID PortContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG Key, KPROCESSOR_MODE RequestorMode);
+
+KSDDKAPI NTSTATUS NTAPI KsWriteFile(PFILE_OBJECT FileObject, PKEVENT Event, PVOID PortContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, ULONG Key, KPROCESSOR_MODE RequestorMode);
+
+KSDDKAPI NTSTATUS NTAPI KsQueryInformationFile(PFILE_OBJECT FileObject, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
+
+KSDDKAPI NTSTATUS NTAPI KsSetInformationFile(PFILE_OBJECT FileObject, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
+
+KSDDKAPI NTSTATUS NTAPI KsStreamIo(PFILE_OBJECT FileObject, PKEVENT Event, PVOID PortContext, PIO_COMPLETION_ROUTINE CompletionRoutine, PVOID CompletionContext, KSCOMPLETION_INVOCATION CompletionInvocationFlags, PIO_STATUS_BLOCK IoStatusBlock, PVOID StreamHeaders, ULONG Length, ULONG Flags, KPROCESSOR_MODE RequestorMode);
+
+KSDDKAPI NTSTATUS NTAPI KsProbeStreamIrp(PIRP Irp, ULONG ProbeFlags, ULONG HeaderSize);
+KSDDKAPI NTSTATUS NTAPI KsAllocateExtraData(PIRP Irp, ULONG ExtraSize, PVOID* ExtraBuffer);
+KSDDKAPI VOID NTAPI KsNullDriverUnload(PDRIVER_OBJECT DriverObject);
+
+KSDDKAPI NTSTATUS NTAPI KsSetMajorFunctionHandler(PDRIVER_OBJECT DriverObject, ULONG MajorFunction);
+
+KSDDKAPI NTSTATUS NTAPI KsDispatchInvalidDeviceRequest(PDEVICE_OBJECT DeviceObject, PIRP Irp);
+
+KSDDKAPI NTSTATUS NTAPI KsDefaultDeviceIoCompletion(PDEVICE_OBJECT DeviceObject, PIRP Irp);
+
+KSDDKAPI NTSTATUS NTAPI KsDispatchIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp);
+
+KSDDKAPI BOOLEAN NTAPI KsDispatchFastIoDeviceControlFailure(PFILE_OBJECT FileObject, BOOLEAN Wait, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, ULONG IoControlCode, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject);
+
+KSDDKAPI BOOLEAN NTAPI KsDispatchFastReadFailure(PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, ULONG Length, BOOLEAN Wait, ULONG LockKey, PVOID Buffer, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject);
+
+ # define KsDispatchFastWriteFailure KsDispatchFastReadFailure
+
+KSDDKAPI VOID NTAPI KsCancelRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp);
+KSDDKAPI VOID NTAPI KsCancelIo(PLIST_ENTRY QueueHead, PKSPIN_LOCK SpinLock);
+KSDDKAPI VOID NTAPI KsReleaseIrpOnCancelableQueue(PIRP Irp, PDRIVER_CANCEL DriverCancel);
+
+KSDDKAPI PIRP NTAPI KsRemoveIrpFromCancelableQueue(PLIST_ENTRY QueueHead, PKSPIN_LOCK SpinLock, KSLIST_ENTRY_LOCATION ListLocation, KSIRP_REMOVAL_OPERATION RemovalOperation);
+
+KSDDKAPI NTSTATUS NTAPI KsMoveIrpsOnCancelableQueue(PLIST_ENTRY SourceList, PKSPIN_LOCK SourceLock, PLIST_ENTRY DestinationList, PKSPIN_LOCK DestinationLock, KSLIST_ENTRY_LOCATION ListLocation, PFNKSIRPLISTCALLBACK ListCallback, PVOID Context);
+
+KSDDKAPI VOID NTAPI KsRemoveSpecificIrpFromCancelableQueue(PIRP Irp);
+
+KSDDKAPI VOID NTAPI KsAddIrpToCancelableQueue(PLIST_ENTRY QueueHead, PKSPIN_LOCK SpinLock, PIRP Irp, KSLIST_ENTRY_LOCATION ListLocation, PDRIVER_CANCEL DriverCancel);
+
+KSDDKAPI NTSTATUS NTAPI KsAcquireResetValue(PIRP Irp, KSRESET* ResetValue);
+
+KSDDKAPI NTSTATUS NTAPI KsTopologyPropertyHandler(PIRP Irp, PKSPROPERTY Property, PVOID Data, const KSTOPOLOGY* Topology);
+
+KSDDKAPI VOID NTAPI KsAcquireDeviceSecurityLock(KSDEVICE_HEADER Header, BOOLEAN Exclusive);
+KSDDKAPI VOID NTAPI KsReleaseDeviceSecurityLock(KSDEVICE_HEADER Header);
+KSDDKAPI NTSTATUS NTAPI KsDefaultDispatchPnp(PDEVICE_OBJECT DeviceObject, PIRP Irp);
+KSDDKAPI NTSTATUS NTAPI KsDefaultDispatchPower(PDEVICE_OBJECT DeviceObject, PIRP Irp);
+KSDDKAPI NTSTATUS NTAPI KsDefaultForwardIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp);
+
+KSDDKAPI VOID NTAPI KsSetDevicePnpAndBaseObject(KSDEVICE_HEADER Header, PDEVICE_OBJECT PnpDeviceObject, PDEVICE_OBJECT BaseObject);
+
+KSDDKAPI PDEVICE_OBJECT NTAPI KsQueryDevicePnpObject(KSDEVICE_HEADER Header);
+KSDDKAPI ACCESS_MASK NTAPI KsQueryObjectAccessMask(KSOBJECT_HEADER Header);
+
+KSDDKAPI VOID NTAPI KsRecalculateStackDepth(KSDEVICE_HEADER Header, BOOLEAN ReuseStackLocation);
+
+KSDDKAPI VOID NTAPI KsSetTargetState(KSOBJECT_HEADER Header, KSTARGET_STATE TargetState);
+
+KSDDKAPI VOID NTAPI KsSetTargetDeviceObject(KSOBJECT_HEADER Header, PDEVICE_OBJECT TargetDevice);
+
+KSDDKAPI VOID NTAPI KsSetPowerDispatch(KSOBJECT_HEADER Header, PFNKSCONTEXT_DISPATCH PowerDispatch, PVOID PowerContext);
+
+KSDDKAPI PKSOBJECT_CREATE_ITEM NTAPI KsQueryObjectCreateItem(KSOBJECT_HEADER Header);
+
+KSDDKAPI NTSTATUS NTAPI KsAllocateDeviceHeader(KSDEVICE_HEADER* Header, ULONG ItemsCount, PKSOBJECT_CREATE_ITEM ItemsList);
+
+KSDDKAPI VOID NTAPI KsFreeDeviceHeader(KSDEVICE_HEADER Header);
+
+KSDDKAPI NTSTATUS NTAPI KsAllocateObjectHeader(KSOBJECT_HEADER* Header, ULONG ItemsCount, PKSOBJECT_CREATE_ITEM ItemsList, PIRP Irp, const KSDISPATCH_TABLE* Table);
+
+KSDDKAPI VOID NTAPI KsFreeObjectHeader(KSOBJECT_HEADER Header);
+
+KSDDKAPI NTSTATUS NTAPI KsAddObjectCreateItemToDeviceHeader(KSDEVICE_HEADER Header, PDRIVER_DISPATCH Create, PVOID Context, PWSTR ObjectClass, PSECURITY_DESCRIPTOR SecurityDescriptor);
+
+KSDDKAPI NTSTATUS NTAPI KsAddObjectCreateItemToObjectHeader(KSOBJECT_HEADER Header, PDRIVER_DISPATCH Create, PVOID Context, PWSTR ObjectClass, PSECURITY_DESCRIPTOR SecurityDescriptor);
+
+KSDDKAPI NTSTATUS NTAPI KsAllocateObjectCreateItem(KSDEVICE_HEADER Header, PKSOBJECT_CREATE_ITEM CreateItem, BOOLEAN AllocateEntry, PFNKSITEMFREECALLBACK ItemFreeCallback);
+
+KSDDKAPI NTSTATUS NTAPI KsFreeObjectCreateItem(KSDEVICE_HEADER Header, PUNICODE_STRING CreateItem);
+
+KSDDKAPI NTSTATUS NTAPI KsFreeObjectCreateItemsByContext(KSDEVICE_HEADER Header, PVOID Context);
+
+KSDDKAPI NTSTATUS NTAPI KsCreateDefaultSecurity(PSECURITY_DESCRIPTOR ParentSecurity, PSECURITY_DESCRIPTOR* DefaultSecurity);
+
+KSDDKAPI NTSTATUS NTAPI KsForwardIrp(PIRP Irp, PFILE_OBJECT FileObject, BOOLEAN ReuseStackLocation);
+
+KSDDKAPI NTSTATUS NTAPI KsForwardAndCatchIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp, PFILE_OBJECT FileObject, KSSTACK_USE StackUse);
+
+KSDDKAPI NTSTATUS NTAPI KsSynchronousIoControlDevice(PFILE_OBJECT FileObject, KPROCESSOR_MODE RequestorMode, ULONG IoControl, PVOID InBuffer, ULONG InSize, PVOID OutBuffer, ULONG OutSize, PULONG BytesReturned);
+
+KSDDKAPI NTSTATUS NTAPI KsUnserializeObjectPropertiesFromRegistry(PFILE_OBJECT FileObject, HANDLE ParentKey, PUNICODE_STRING RegistryPath);
+
+KSDDKAPI NTSTATUS NTAPI KsCacheMedium(PUNICODE_STRING SymbolicLink, PKSPIN_MEDIUM Medium, ULONG PinDirection);
+
+KSDDKAPI NTSTATUS NTAPI KsRegisterWorker(WORK_QUEUE_TYPE WorkQueueType, PKSWORKER* Worker);
+
+KSDDKAPI NTSTATUS NTAPI KsRegisterCountedWorker(WORK_QUEUE_TYPE WorkQueueType, PWORK_QUEUE_ITEM CountedWorkItem, PKSWORKER* Worker);
+
+KSDDKAPI VOID NTAPI KsUnregisterWorker(PKSWORKER Worker);
+KSDDKAPI NTSTATUS NTAPI KsQueueWorkItem(PKSWORKER Worker, PWORK_QUEUE_ITEM WorkItem);
+KSDDKAPI ULONG NTAPI KsIncrementCountedWorker(PKSWORKER Worker);
+KSDDKAPI ULONG NTAPI KsDecrementCountedWorker(PKSWORKER Worker);
+
+KSDDKAPI NTSTATUS NTAPI KsCreateTopologyNode(HANDLE ParentHandle, PKSNODE_CREATE NodeCreate, ACCESS_MASK DesiredAccess, PHANDLE NodeHandle);
+
+KSDDKAPI NTSTATUS NTAPI KsValidateTopologyNodeCreateRequest(PIRP Irp, PKSTOPOLOGY Topology, PKSNODE_CREATE* NodeCreate);
+
+KSDDKAPI NTSTATUS NTAPI KsMergeAutomationTables(PKSAUTOMATION_TABLE* AutomationTableAB, PKSAUTOMATION_TABLE AutomationTableA, PKSAUTOMATION_TABLE AutomationTableB, KSOBJECT_BAG Bag);
+
+KSDDKAPI NTSTATUS NTAPI KsInitializeDriver(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPathName, const KSDEVICE_DESCRIPTOR* Descriptor);
+
+KSDDKAPI NTSTATUS NTAPI KsAddDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT PhysicalDeviceObject);
+
+KSDDKAPI NTSTATUS NTAPI KsCreateDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT PhysicalDeviceObject, const KSDEVICE_DESCRIPTOR* Descriptor, ULONG ExtensionSize, PKSDEVICE* Device);
+
+KSDDKAPI NTSTATUS NTAPI KsInitializeDevice(PDEVICE_OBJECT FunctionalDeviceObject, PDEVICE_OBJECT PhysicalDeviceObject, PDEVICE_OBJECT NextDeviceObject, const KSDEVICE_DESCRIPTOR* Descriptor);
+
+KSDDKAPI void NTAPI KsTerminateDevice(PDEVICE_OBJECT DeviceObject);
+KSDDKAPI PKSDEVICE NTAPI KsGetDeviceForDeviceObject(PDEVICE_OBJECT FunctionalDeviceObject);
+KSDDKAPI void NTAPI KsAcquireDevice(PKSDEVICE Device);
+KSDDKAPI void NTAPI KsReleaseDevice(PKSDEVICE Device);
+
+KSDDKAPI void NTAPI KsDeviceRegisterAdapterObject(PKSDEVICE Device, PADAPTER_OBJECT AdapterObject, ULONG MaxMappingsByteCount, ULONG MappingTableStride);
+
+KSDDKAPI ULONG NTAPI KsDeviceGetBusData(PKSDEVICE Device, ULONG DataType, PVOID Buffer, ULONG Offset, ULONG Length);
+
+KSDDKAPI ULONG NTAPI KsDeviceSetBusData(PKSDEVICE Device, ULONG DataType, PVOID Buffer, ULONG Offset, ULONG Length);
+
+KSDDKAPI NTSTATUS NTAPI KsCreateFilterFactory(PDEVICE_OBJECT DeviceObject, const KSFILTER_DESCRIPTOR* Descriptor, PWSTR RefString, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG CreateItemFlags, PFNKSFILTERFACTORYPOWER SleepCallback, PFNKSFILTERFACTORYPOWER WakeCallback, PKSFILTERFACTORY* FilterFactory);
+
+ # define KsDeleteFilterFactory(FilterFactory)                                                \
+  KsFreeObjectCreateItemsByContext(*(KSDEVICE_HEADER*)(                                     \
+                                     KsFilterFactoryGetParentDevice(FilterFactory)->FunctionalDeviceObject->DeviceExtension), \
+                                   FilterFactory)
+
+KSDDKAPI NTSTATUS NTAPI KsFilterFactoryUpdateCacheData(PKSFILTERFACTORY FilterFactory, const KSFILTER_DESCRIPTOR* FilterDescriptor);
+
+KSDDKAPI NTSTATUS NTAPI KsFilterFactoryAddCreateItem(PKSFILTERFACTORY FilterFactory, PWSTR RefString, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG CreateItemFlags);
+
+KSDDKAPI NTSTATUS NTAPI KsFilterFactorySetDeviceClassesState(PKSFILTERFACTORY FilterFactory, BOOLEAN NewState);
+
+KSDDKAPI PUNICODE_STRING NTAPI KsFilterFactoryGetSymbolicLink(PKSFILTERFACTORY FilterFactory);
+
+KSDDKAPI void NTAPI KsAddEvent(PVOID Object, PKSEVENT_ENTRY EventEntry);
+
+void __forceinline KsFilterAddEvent(PKSFILTER Filter, PKSEVENT_ENTRY EventEntry)
+{
+  KsAddEvent(Filter, EventEntry);
+}
+
+void __forceinline KsPinAddEvent(PKSPIN Pin, PKSEVENT_ENTRY EventEntry)
+{
+  KsAddEvent(Pin, EventEntry);
+}
+
+KSDDKAPI NTSTATUS NTAPI KsDefaultAddEventHandler(PIRP Irp, PKSEVENTDATA EventData, PKSEVENT_ENTRY EventEntry);
+
+KSDDKAPI void NTAPI KsGenerateEvents(PVOID Object, const GUID* EventSet, ULONG EventId, ULONG DataSize, PVOID Data, PFNKSGENERATEEVENTCALLBACK CallBack, PVOID CallBackContext);
+
+void __forceinline KsFilterGenerateEvents(PKSFILTER Filter, const GUID* EventSet, ULONG EventId, ULONG DataSize, PVOID Data, PFNKSGENERATEEVENTCALLBACK CallBack, PVOID CallBackContext)
+{
+  KsGenerateEvents(Filter, EventSet, EventId, DataSize, Data, CallBack,
+                   CallBackContext);
+}
+
+void __forceinline KsPinGenerateEvents(PKSPIN Pin, const GUID* EventSet, ULONG EventId, ULONG DataSize, PVOID Data, PFNKSGENERATEEVENTCALLBACK CallBack, PVOID CallBackContext)
+{
+  KsGenerateEvents(Pin, EventSet, EventId, DataSize, Data, CallBack,
+                   CallBackContext);
+}
+
+typedef enum
+{
+  KSSTREAM_POINTER_STATE_UNLOCKED = 0,
+  KSSTREAM_POINTER_STATE_LOCKED
+}KSSTREAM_POINTER_STATE;
+
+KSDDKAPI NTSTATUS NTAPI KsPinGetAvailableByteCount(PKSPIN Pin, PLONG InputDataBytes, PLONG OutputBufferBytes);
+
+KSDDKAPI PKSSTREAM_POINTER NTAPI KsPinGetLeadingEdgeStreamPointer(PKSPIN Pin, KSSTREAM_POINTER_STATE State);
+
+KSDDKAPI PKSSTREAM_POINTER NTAPI KsPinGetTrailingEdgeStreamPointer(PKSPIN Pin, KSSTREAM_POINTER_STATE State);
+
+KSDDKAPI NTSTATUS NTAPI KsStreamPointerSetStatusCode(PKSSTREAM_POINTER StreamPointer, NTSTATUS Status);
+
+KSDDKAPI NTSTATUS NTAPI KsStreamPointerLock(PKSSTREAM_POINTER StreamPointer);
+KSDDKAPI void NTAPI KsStreamPointerUnlock(PKSSTREAM_POINTER StreamPointer, BOOLEAN Eject);
+
+KSDDKAPI void NTAPI KsStreamPointerAdvanceOffsetsAndUnlock(PKSSTREAM_POINTER StreamPointer, ULONG InUsed, ULONG OutUsed, BOOLEAN Eject);
+
+KSDDKAPI void NTAPI KsStreamPointerDelete(PKSSTREAM_POINTER StreamPointer);
+
+KSDDKAPI NTSTATUS NTAPI KsStreamPointerClone(PKSSTREAM_POINTER StreamPointer, PFNKSSTREAMPOINTER CancelCallback, ULONG ContextSize, PKSSTREAM_POINTER* CloneStreamPointer);
+
+KSDDKAPI NTSTATUS NTAPI KsStreamPointerAdvanceOffsets(PKSSTREAM_POINTER StreamPointer, ULONG InUsed, ULONG OutUsed, BOOLEAN Eject);
+
+KSDDKAPI NTSTATUS NTAPI KsStreamPointerAdvance(PKSSTREAM_POINTER StreamPointer);
+KSDDKAPI PMDL NTAPI KsStreamPointerGetMdl(PKSSTREAM_POINTER StreamPointer);
+
+KSDDKAPI PIRP NTAPI KsStreamPointerGetIrp(PKSSTREAM_POINTER StreamPointer, PBOOLEAN FirstFrameInIrp, PBOOLEAN LastFrameInIrp);
+
+KSDDKAPI void NTAPI KsStreamPointerScheduleTimeout(PKSSTREAM_POINTER StreamPointer, PFNKSSTREAMPOINTER Callback, ULONGLONG Interval);
+
+KSDDKAPI void NTAPI KsStreamPointerCancelTimeout(PKSSTREAM_POINTER StreamPointer);
+KSDDKAPI PKSSTREAM_POINTER NTAPI KsPinGetFirstCloneStreamPointer(PKSPIN Pin);
+
+KSDDKAPI PKSSTREAM_POINTER NTAPI KsStreamPointerGetNextClone(PKSSTREAM_POINTER StreamPointer);
+
+KSDDKAPI NTSTATUS NTAPI KsPinHandshake(PKSPIN Pin, PKSHANDSHAKE In, PKSHANDSHAKE Out);
+KSDDKAPI void NTAPI KsCompletePendingRequest(PIRP Irp);
+KSDDKAPI KSOBJECTTYPE NTAPI KsGetObjectTypeFromIrp(PIRP Irp);
+KSDDKAPI PVOID NTAPI KsGetObjectFromFileObject(PFILE_OBJECT FileObject);
+KSDDKAPI KSOBJECTTYPE NTAPI KsGetObjectTypeFromFileObject(PFILE_OBJECT FileObject);
+
+PKSFILTER __forceinline KsGetFilterFromFileObject(PFILE_OBJECT FileObject)
+{
+  return (PKSFILTER)KsGetObjectFromFileObject(FileObject);
+}
+
+PKSPIN __forceinline KsGetPinFromFileObject(PFILE_OBJECT FileObject)
+{
+  return (PKSPIN)KsGetObjectFromFileObject(FileObject);
+}
+
+KSDDKAPI PKSGATE NTAPI KsFilterGetAndGate(PKSFILTER Filter);
+KSDDKAPI void NTAPI KsFilterAcquireProcessingMutex(PKSFILTER Filter);
+KSDDKAPI void NTAPI KsFilterReleaseProcessingMutex(PKSFILTER Filter);
+KSDDKAPI void NTAPI KsFilterAttemptProcessing(PKSFILTER Filter, BOOLEAN Asynchronous);
+KSDDKAPI PKSGATE NTAPI KsPinGetAndGate(PKSPIN Pin);
+KSDDKAPI void NTAPI KsPinAttachAndGate(PKSPIN Pin, PKSGATE AndGate);
+KSDDKAPI void NTAPI KsPinAttachOrGate(PKSPIN Pin, PKSGATE OrGate);
+KSDDKAPI void NTAPI KsPinAcquireProcessingMutex(PKSPIN Pin);
+KSDDKAPI void NTAPI KsPinReleaseProcessingMutex(PKSPIN Pin);
+KSDDKAPI BOOLEAN NTAPI KsProcessPinUpdate(PKSPROCESSPIN ProcessPin);
+
+KSDDKAPI void NTAPI KsPinGetCopyRelationships(PKSPIN Pin, PKSPIN* CopySource, PKSPIN* DelegateBranch);
+
+KSDDKAPI void NTAPI KsPinAttemptProcessing(PKSPIN Pin, BOOLEAN Asynchronous);
+KSDDKAPI PVOID NTAPI KsGetParent(PVOID Object);
+
+PKSDEVICE __forceinline KsFilterFactoryGetParentDevice(PKSFILTERFACTORY FilterFactory)
+{
+  return (PKSDEVICE)KsGetParent((PVOID)FilterFactory);
+}
+
+PKSFILTERFACTORY __forceinline KsFilterGetParentFilterFactory(PKSFILTER Filter)
+{
+  return (PKSFILTERFACTORY)KsGetParent((PVOID)Filter);
+}
+
+KSDDKAPI PKSFILTER NTAPI KsPinGetParentFilter(PKSPIN Pin);
+KSDDKAPI PVOID NTAPI KsGetFirstChild(PVOID Object);
+
+PKSFILTERFACTORY __forceinline KsDeviceGetFirstChildFilterFactory(PKSDEVICE Device)
+{
+  return (PKSFILTERFACTORY)KsGetFirstChild((PVOID)Device);
+}
+
+PKSFILTER __forceinline KsFilterFactoryGetFirstChildFilter(PKSFILTERFACTORY FilterFactory)
+{
+  return (PKSFILTER)KsGetFirstChild((PVOID)FilterFactory);
+}
+
+KSDDKAPI ULONG NTAPI KsFilterGetChildPinCount(PKSFILTER Filter, ULONG PinId);
+KSDDKAPI PKSPIN NTAPI KsFilterGetFirstChildPin(PKSFILTER Filter, ULONG PinId);
+KSDDKAPI PVOID NTAPI KsGetNextSibling(PVOID Object);
+KSDDKAPI PKSPIN NTAPI KsPinGetNextSiblingPin(PKSPIN Pin);
+
+PKSFILTERFACTORY __forceinline KsFilterFactoryGetNextSiblingFilterFactory(PKSFILTERFACTORY FilterFactory)
+{
+  return (PKSFILTERFACTORY)KsGetNextSibling((PVOID)FilterFactory);
+}
+
+PKSFILTER __forceinline KsFilterGetNextSiblingFilter(PKSFILTER Filter)
+{
+  return (PKSFILTER)KsGetNextSibling((PVOID)Filter);
+}
+
+KSDDKAPI PKSDEVICE NTAPI KsGetDevice(PVOID Object);
+
+PKSDEVICE __forceinline KsFilterFactoryGetDevice(PKSFILTERFACTORY FilterFactory)
+{
+  return KsGetDevice((PVOID)FilterFactory);
+}
+
+PKSDEVICE __forceinline KsFilterGetDevice(PKSFILTER Filter)
+{
+  return KsGetDevice((PVOID)Filter);
+}
+
+PKSDEVICE __forceinline KsPinGetDevice(PKSPIN Pin)
+{
+  return KsGetDevice((PVOID)Pin);
+}
+
+KSDDKAPI PKSFILTER NTAPI KsGetFilterFromIrp(PIRP Irp);
+KSDDKAPI PKSPIN NTAPI KsGetPinFromIrp(PIRP Irp);
+KSDDKAPI ULONG NTAPI KsGetNodeIdFromIrp(PIRP Irp);
+KSDDKAPI void NTAPI KsAcquireControl(PVOID Object);
+KSDDKAPI void NTAPI KsReleaseControl(PVOID Object);
+
+void __forceinline KsFilterAcquireControl(PKSFILTER Filter)
+{
+  KsAcquireControl((PVOID)Filter);
+}
+
+void __forceinline KsFilterReleaseControl(PKSFILTER Filter)
+{
+  KsReleaseControl((PVOID)Filter);
+}
+
+void __forceinline KsPinAcquireControl(PKSPIN Pin)
+{
+  KsAcquireControl((PVOID)Pin);
+}
+
+void __forceinline KsPinReleaseControl(PKSPIN Pin)
+{
+  KsReleaseControl((PVOID)Pin);
+}
+
+KSDDKAPI NTSTATUS NTAPI KsAddItemToObjectBag(KSOBJECT_BAG ObjectBag, PVOID Item, PFNKSFREE Free);
+
+KSDDKAPI ULONG NTAPI KsRemoveItemFromObjectBag(KSOBJECT_BAG ObjectBag, PVOID Item, BOOLEAN Free);
+
+ # define KsDiscard(Object, Pointer)                   \
+  KsRemoveItemFromObjectBag((Object)->Bag, (PVOID)(Pointer), TRUE)
+
+KSDDKAPI NTSTATUS NTAPI KsAllocateObjectBag(PKSDEVICE Device, KSOBJECT_BAG* ObjectBag);
+KSDDKAPI void NTAPI KsFreeObjectBag(KSOBJECT_BAG ObjectBag);
+
+KSDDKAPI NTSTATUS NTAPI KsCopyObjectBagItems(KSOBJECT_BAG ObjectBagDestination, KSOBJECT_BAG ObjectBagSource);
+
+KSDDKAPI NTSTATUS NTAPI _KsEdit(KSOBJECT_BAG ObjectBag, PVOID* PointerToPointerToItem, ULONG NewSize, ULONG OldSize, ULONG Tag);
+
+ # define KsEdit(Object, PointerToPointer, Tag)                       \
+  _KsEdit((Object)->Bag, (PVOID*)(PointerToPointer),              \
+          sizeof(**(PointerToPointer)), sizeof(**(PointerToPointer)), (Tag))
+
+ # define KsEditSized(Object, PointerToPointer, NewSize, OldSize, Tag)            \
+  _KsEdit((Object)->Bag, (PVOID*)(PointerToPointer), (NewSize), (OldSize), (Tag))
+
+KSDDKAPI NTSTATUS NTAPI KsRegisterFilterWithNoKSPins(PDEVICE_OBJECT DeviceObject, const GUID* InterfaceClassGUID, ULONG PinCount, WINBOOL* PinDirection, KSPIN_MEDIUM* MediumList, GUID* CategoryList);
+
+KSDDKAPI NTSTATUS NTAPI KsFilterCreatePinFactory(PKSFILTER Filter, const KSPIN_DESCRIPTOR_EX* const PinDescriptor, PULONG PinID);
+
+KSDDKAPI NTSTATUS NTAPI KsFilterCreateNode(PKSFILTER Filter, const KSNODE_DESCRIPTOR* const NodeDescriptor, PULONG NodeID);
+
+KSDDKAPI NTSTATUS NTAPI KsFilterAddTopologyConnections(PKSFILTER Filter, ULONG NewConnectionsCount, const KSTOPOLOGY_CONNECTION* const NewTopologyConnections);
+
+KSDDKAPI NTSTATUS NTAPI KsPinGetConnectedPinInterface(PKSPIN Pin, const GUID* InterfaceId, PVOID* Interface);
+
+KSDDKAPI PFILE_OBJECT NTAPI KsPinGetConnectedPinFileObject(PKSPIN Pin);
+KSDDKAPI PDEVICE_OBJECT NTAPI KsPinGetConnectedPinDeviceObject(PKSPIN Pin);
+
+KSDDKAPI NTSTATUS NTAPI KsPinGetConnectedFilterInterface(PKSPIN Pin, const GUID* InterfaceId, PVOID* Interface);
+
+ # if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)
+KSDDKAPI NTSTATUS NTAPI KsPinGetReferenceClockInterface(PKSPIN Pin, PIKSREFERENCECLOCK* Interface);
+ # endif /* defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__) */
+
+KSDDKAPI VOID NTAPI KsPinSetPinClockTime(PKSPIN Pin, LONGLONG Time);
+
+KSDDKAPI NTSTATUS NTAPI KsPinSubmitFrame(PKSPIN Pin, PVOID Data, ULONG Size, PKSSTREAM_HEADER StreamHeader, PVOID Context);
+
+KSDDKAPI NTSTATUS NTAPI KsPinSubmitFrameMdl(PKSPIN Pin, PMDL Mdl, PKSSTREAM_HEADER StreamHeader, PVOID Context);
+
+KSDDKAPI void NTAPI KsPinRegisterFrameReturnCallback(PKSPIN Pin, PFNKSPINFRAMERETURN FrameReturn);
+
+KSDDKAPI void NTAPI KsPinRegisterIrpCompletionCallback(PKSPIN Pin, PFNKSPINIRPCOMPLETION IrpCompletion);
+
+KSDDKAPI void NTAPI KsPinRegisterHandshakeCallback(PKSPIN Pin, PFNKSPINHANDSHAKE Handshake);
+
+KSDDKAPI void NTAPI KsFilterRegisterPowerCallbacks(PKSFILTER Filter, PFNKSFILTERPOWER Sleep, PFNKSFILTERPOWER Wake);
+
+KSDDKAPI void NTAPI KsPinRegisterPowerCallbacks(PKSPIN Pin, PFNKSPINPOWER Sleep, PFNKSPINPOWER Wake);
+
+ # if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)
+KSDDKAPI PUNKNOWN NTAPI KsRegisterAggregatedClientUnknown(PVOID Object, PUNKNOWN ClientUnknown);
+
+KSDDKAPI PUNKNOWN NTAPI KsGetOuterUnknown(PVOID Object);
+
+PUNKNOWN __forceinline KsDeviceRegisterAggregatedClientUnknown(PKSDEVICE Device, PUNKNOWN ClientUnknown)
+{
+  return KsRegisterAggregatedClientUnknown((PVOID)Device, ClientUnknown);
+}
+
+PUNKNOWN __forceinline KsDeviceGetOuterUnknown(PKSDEVICE Device)
+{
+  return KsGetOuterUnknown((PVOID)Device);
+}
+
+PUNKNOWN __forceinline KsFilterFactoryRegisterAggregatedClientUnknown(PKSFILTERFACTORY FilterFactory, PUNKNOWN ClientUnknown)
+{
+  return KsRegisterAggregatedClientUnknown((PVOID)FilterFactory, ClientUnknown);
+}
+
+PUNKNOWN __forceinline KsFilterFactoryGetOuterUnknown(PKSFILTERFACTORY FilterFactory)
+{
+  return KsGetOuterUnknown((PVOID)FilterFactory);
+}
+
+PUNKNOWN __forceinline KsFilterRegisterAggregatedClientUnknown(PKSFILTER Filter, PUNKNOWN ClientUnknown)
+{
+  return KsRegisterAggregatedClientUnknown((PVOID)Filter, ClientUnknown);
+}
+
+PUNKNOWN __forceinline KsFilterGetOuterUnknown(PKSFILTER Filter)
+{
+  return KsGetOuterUnknown((PVOID)Filter);
+}
+
+PUNKNOWN __forceinline KsPinRegisterAggregatedClientUnknown(PKSPIN Pin, PUNKNOWN ClientUnknown)
+{
+  return KsRegisterAggregatedClientUnknown((PVOID)Pin, ClientUnknown);
+}
+
+PUNKNOWN __forceinline KsPinGetOuterUnknown(PKSPIN Pin)
+{
+  return KsGetOuterUnknown((PVOID)Pin);
+}
+
+ # endif /* defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__) */
+
+#else /* _NTDDK_ */
+
+ # ifndef KS_NO_CREATE_FUNCTIONS
+KSDDKAPI DWORD WINAPI KsCreateAllocator(HANDLE ConnectionHandle, PKSALLOCATOR_FRAMING AllocatorFraming, PHANDLE AllocatorHandle);
+KSDDKAPI DWORD NTAPI KsCreateClock(HANDLE ConnectionHandle, PKSCLOCK_CREATE ClockCreate, PHANDLE ClockHandle);
+KSDDKAPI DWORD WINAPI KsCreatePin(HANDLE FilterHandle, PKSPIN_CONNECT Connect, ACCESS_MASK DesiredAccess, PHANDLE ConnectionHandle);
+KSDDKAPI DWORD WINAPI KsCreateTopologyNode(HANDLE ParentHandle, PKSNODE_CREATE NodeCreate, ACCESS_MASK DesiredAccess, PHANDLE NodeHandle);
+ # endif
+
+#endif /* _NTDDK_ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#define DENY_USERMODE_ACCESS(pIrp, CompleteRequest)          \
+  if(pIrp->RequestorMode != KernelMode){               \
+    pIrp->IoStatus.Information = 0;             \
+    pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;  \
+    if(CompleteRequest){                 \
+      IoCompleteRequest(pIrp, IO_NO_INCREMENT); }   \
+    return STATUS_INVALID_DEVICE_REQUEST;           \
+  }
+
+#endif /* _KS_ */
+
--- /dev/null
+++ giada-0.7.2/src/rtmidi/tests/Makefile.in
@@ -0,0 +1,48 @@
+### Do not edit -- Generated by 'configure --with-whatever' from Makefile.in
+### RtMidi tests Makefile - for various flavors of unix
+
+PROGRAMS = midiprobe midiout qmidiin cmidiin sysextest
+RM = /bin/rm
+SRC_PATH = ..
+INCLUDE = ..
+OBJECT_PATH = @object_path@
+vpath %.o $(OBJECT_PATH)
+
+OBJECTS	=	RtMidi.o
+
+CC       = @CXX@
+DEFS     = @CPPFLAGS@
+CFLAGS   = @CXXFLAGS@
+CFLAGS  += -I$(INCLUDE) -I$(INCLUDE)/include
+LIBRARY  = @LIBS@
+
+%.o : $(SRC_PATH)/%.cpp
+	$(CC) $(CFLAGS) $(DEFS) -c $(<) -o $(OBJECT_PATH)/$@
+
+all : $(PROGRAMS)
+
+midiprobe : midiprobe.cpp $(OBJECTS)
+	$(CC) $(CFLAGS) $(DEFS) -o midiprobe midiprobe.cpp $(OBJECT_PATH)/RtMidi.o $(LIBRARY)
+
+midiout : midiout.cpp $(OBJECTS)
+	$(CC) $(CFLAGS) $(DEFS) -o midiout midiout.cpp $(OBJECT_PATH)/RtMidi.o $(LIBRARY)
+
+qmidiin : qmidiin.cpp $(OBJECTS)
+	$(CC) $(CFLAGS) $(DEFS) -o qmidiin qmidiin.cpp $(OBJECT_PATH)/RtMidi.o $(LIBRARY)
+
+cmidiin : cmidiin.cpp $(OBJECTS)
+	$(CC) $(CFLAGS) $(DEFS) -o cmidiin cmidiin.cpp $(OBJECT_PATH)/RtMidi.o $(LIBRARY)
+
+sysextest : sysextest.cpp $(OBJECTS)
+	$(CC) $(CFLAGS) $(DEFS) -o sysextest sysextest.cpp $(OBJECT_PATH)/RtMidi.o $(LIBRARY)
+
+clean : 
+	$(RM) -f $(OBJECT_PATH)/*.o
+	$(RM) -f $(PROGRAMS) *.exe
+	$(RM) -f *~
+
+distclean: clean
+	$(RM) -f Makefile
+
+strip : 
+	strip $(PROGRAMS)
--- /dev/null
+++ giada-0.7.2/src/rtmidi/tests/midiout.cpp
@@ -0,0 +1,146 @@
+//*****************************************//
+//  midiout.cpp
+//  by Gary Scavone, 2003-2004.
+//
+//  Simple program to test MIDI output.
+//
+//*****************************************//
+
+#include <iostream>
+#include <cstdlib>
+#include "RtMidi.h"
+
+// Platform-dependent sleep routines.
+#if defined(__WINDOWS_MM__)
+  #include <windows.h>
+  #define SLEEP( milliseconds ) Sleep( (DWORD) milliseconds ) 
+#else // Unix variants
+  #include <unistd.h>
+  #define SLEEP( milliseconds ) usleep( (unsigned long) (milliseconds * 1000.0) )
+#endif
+
+// This function should be embedded in a try/catch block in case of
+// an exception.  It offers the user a choice of MIDI ports to open.
+// It returns false if there are no ports available.
+bool chooseMidiPort( RtMidiOut *rtmidi );
+
+int main( int argc, char *argv[] )
+{
+  RtMidiOut *midiout = 0;
+  std::vector<unsigned char> message;
+
+  // RtMidiOut constructor
+  try {
+    midiout = new RtMidiOut();
+  }
+  catch ( RtError &error ) {
+    error.printMessage();
+    exit( EXIT_FAILURE );
+  }
+
+  // Call function to select port.
+  try {
+    if ( chooseMidiPort( midiout ) == false ) goto cleanup;
+  }
+  catch ( RtError &error ) {
+    error.printMessage();
+    goto cleanup;
+  }
+
+  // Send out a series of MIDI messages.
+
+  // Program change: 192, 5
+  message.push_back( 192 );
+  message.push_back( 5 );
+  midiout->sendMessage( &message );
+
+  SLEEP( 500 );
+
+  message[0] = 0xF1;
+  message[1] = 60;
+  midiout->sendMessage( &message );
+
+  // Control Change: 176, 7, 100 (volume)
+  message[0] = 176;
+  message[1] = 7;
+  message.push_back( 100 );
+  midiout->sendMessage( &message );
+
+  // Note On: 144, 64, 90
+  message[0] = 144;
+  message[1] = 64;
+  message[2] = 90;
+  midiout->sendMessage( &message );
+
+  SLEEP( 500 );
+
+  // Note Off: 128, 64, 40
+  message[0] = 128;
+  message[1] = 64;
+  message[2] = 40;
+  midiout->sendMessage( &message );
+
+  SLEEP( 500 );
+
+  // Control Change: 176, 7, 40
+  message[0] = 176;
+  message[1] = 7;
+  message[2] = 40;
+  midiout->sendMessage( &message );
+
+  SLEEP( 500 );
+
+  // Sysex: 240, 67, 4, 3, 2, 247
+  message[0] = 240;
+  message[1] = 67;
+  message[2] = 4;
+  message.push_back( 3 );
+  message.push_back( 2 );
+  message.push_back( 247 );
+  midiout->sendMessage( &message );
+
+  // Clean up
+ cleanup:
+  delete midiout;
+
+  return 0;
+}
+
+bool chooseMidiPort( RtMidiOut *rtmidi )
+{
+  std::cout << "\nWould you like to open a virtual output port? [y/N] ";
+
+  std::string keyHit;
+  std::getline( std::cin, keyHit );
+  if ( keyHit == "y" ) {
+    rtmidi->openVirtualPort();
+    return true;
+  }
+
+  std::string portName;
+  unsigned int i = 0, nPorts = rtmidi->getPortCount();
+  if ( nPorts == 0 ) {
+    std::cout << "No output ports available!" << std::endl;
+    return false;
+  }
+
+  if ( nPorts == 1 ) {
+    std::cout << "\nOpening " << rtmidi->getPortName() << std::endl;
+  }
+  else {
+    for ( i=0; i<nPorts; i++ ) {
+      portName = rtmidi->getPortName(i);
+      std::cout << "  Output port #" << i << ": " << portName << '\n';
+    }
+
+    do {
+      std::cout << "\nChoose a port number: ";
+      std::cin >> i;
+    } while ( i >= nPorts );
+  }
+
+  std::cout << "\n";
+  rtmidi->openPort( i );
+
+  return true;
+}
--- /dev/null
+++ giada-0.7.2/src/rtmidi/tests/cmidiin.cpp
@@ -0,0 +1,111 @@
+//*****************************************//
+//  cmidiin.cpp
+//  by Gary Scavone, 2003-2004.
+//
+//  Simple program to test MIDI input and
+//  use of a user callback function.
+//
+//*****************************************//
+
+#include <iostream>
+#include <cstdlib>
+#include "RtMidi.h"
+
+void usage( void ) {
+  // Error function in case of incorrect command-line
+  // argument specifications.
+  std::cout << "\nuseage: cmidiin <port>\n";
+  std::cout << "    where port = the device to use (default = 0).\n\n";
+  exit( 0 );
+}
+
+void mycallback( double deltatime, std::vector< unsigned char > *message, void *userData )
+{
+  unsigned int nBytes = message->size();
+  for ( unsigned int i=0; i<nBytes; i++ )
+    std::cout << "Byte " << i << " = " << (int)message->at(i) << ", ";
+  if ( nBytes > 0 )
+    std::cout << "stamp = " << deltatime << std::endl;
+}
+
+// This function should be embedded in a try/catch block in case of
+// an exception.  It offers the user a choice of MIDI ports to open.
+// It returns false if there are no ports available.
+bool chooseMidiPort( RtMidiIn *rtmidi );
+
+int main( int argc, char *argv[] )
+{
+  RtMidiIn *midiin = 0;
+
+  // Minimal command-line check.
+  if ( argc > 2 ) usage();
+
+  try {
+
+    // RtMidiIn constructor
+    midiin = new RtMidiIn();
+
+    // Call function to select port.
+    if ( chooseMidiPort( midiin ) == false ) goto cleanup;
+
+    // Set our callback function.  This should be done immediately after
+    // opening the port to avoid having incoming messages written to the
+    // queue instead of sent to the callback function.
+    midiin->setCallback( &mycallback );
+
+    // Don't ignore sysex, timing, or active sensing messages.
+    midiin->ignoreTypes( false, false, false );
+
+    std::cout << "\nReading MIDI input ... press <enter> to quit.\n";
+    char input;
+    std::cin.get(input);
+
+  } catch ( RtError &error ) {
+    error.printMessage();
+  }
+
+ cleanup:
+
+  delete midiin;
+
+  return 0;
+}
+
+bool chooseMidiPort( RtMidiIn *rtmidi )
+{
+  std::cout << "\nWould you like to open a virtual input port? [y/N] ";
+
+  std::string keyHit;
+  std::getline( std::cin, keyHit );
+  if ( keyHit == "y" ) {
+    rtmidi->openVirtualPort();
+    return true;
+  }
+
+  std::string portName;
+  unsigned int i = 0, nPorts = rtmidi->getPortCount();
+  if ( nPorts == 0 ) {
+    std::cout << "No input ports available!" << std::endl;
+    return false;
+  }
+
+  if ( nPorts == 1 ) {
+    std::cout << "\nOpening " << rtmidi->getPortName() << std::endl;
+  }
+  else {
+    for ( i=0; i<nPorts; i++ ) {
+      portName = rtmidi->getPortName(i);
+      std::cout << "  Input port #" << i << ": " << portName << '\n';
+    }
+
+    do {
+      std::cout << "\nChoose a port number: ";
+      std::cin >> i;
+    } while ( i >= nPorts );
+  }
+
+  std::getline( std::cin, keyHit );  // used to clear out stdin
+  rtmidi->openPort( i );
+
+  return true;
+}
--- /dev/null
+++ giada-0.7.2/src/rtmidi/tests/midiprobe.cpp
@@ -0,0 +1,72 @@
+// midiprobe.cpp
+//
+// Simple program to check MIDI inputs and outputs.
+//
+// by Gary Scavone, 2003-2012.
+
+#include <iostream>
+#include <cstdlib>
+#include <map>
+#include "RtMidi.h"
+
+int main()
+{
+  // Create an api map.
+  std::map<int, std::string> apiMap;
+  apiMap[RtMidi::MACOSX_CORE] = "OS-X CoreMidi";
+  apiMap[RtMidi::WINDOWS_MM] = "Windows MultiMedia";
+  apiMap[RtMidi::WINDOWS_KS] = "Windows Kernel Straming";
+  apiMap[RtMidi::UNIX_JACK] = "Jack Client";
+  apiMap[RtMidi::LINUX_ALSA] = "Linux ALSA";
+  apiMap[RtMidi::RTMIDI_DUMMY] = "RtMidi Dummy";
+
+  std::vector< RtMidi::Api > apis;
+  RtMidi :: getCompiledApi( apis );
+
+  std::cout << "\nCompiled APIs:\n";
+  for ( unsigned int i=0; i<apis.size(); i++ )
+    std::cout << "  " << apiMap[ apis[i] ] << std::endl;
+
+  RtMidiIn  *midiin = 0;
+  RtMidiOut *midiout = 0;
+
+  try {
+
+    // RtMidiIn constructor ... exception possible
+    midiin = new RtMidiIn();
+
+    std::cout << "\nCurrent input API: " << apiMap[ midiin->getCurrentApi() ] << std::endl;
+
+    // Check inputs.
+    unsigned int nPorts = midiin->getPortCount();
+    std::cout << "\nThere are " << nPorts << " MIDI input sources available.\n";
+
+    for ( unsigned i=0; i<nPorts; i++ ) {
+      std::string portName = midiin->getPortName(i);
+      std::cout << "  Input Port #" << i+1 << ": " << portName << '\n';
+    }
+
+    // RtMidiOut constructor ... exception possible
+    midiout = new RtMidiOut();
+
+    std::cout << "\nCurrent output API: " << apiMap[ midiout->getCurrentApi() ] << std::endl;
+
+    // Check outputs.
+    nPorts = midiout->getPortCount();
+    std::cout << "\nThere are " << nPorts << " MIDI output ports available.\n";
+
+    for ( unsigned i=0; i<nPorts; i++ ) {
+      std::string portName = midiout->getPortName(i);
+      std::cout << "  Output Port #" << i+1 << ": " << portName << std::endl;
+    }
+    std::cout << std::endl;
+
+  } catch ( RtError &error ) {
+    error.printMessage();
+  }
+
+  delete midiin;
+  delete midiout;
+
+  return 0;
+}
--- /dev/null
+++ giada-0.7.2/src/rtmidi/tests/RtMidi.dsw
@@ -0,0 +1,77 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "cmidiin"=".\cmidiin.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "midiout"=".\midiout.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "midiprobe"=".\midiprobe.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "qmidiin"=".\qmidiin.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "sysextest"=".\sysextest.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
--- /dev/null
+++ giada-0.7.2/src/rtmidi/tests/sysextest.cpp
@@ -0,0 +1,154 @@
+//*****************************************//
+//  sysextest.cpp
+//  by Gary Scavone, 2003-2005.
+//
+//  Simple program to test MIDI sysex sending and receiving.
+//
+//*****************************************//
+
+#include <iostream>
+#include <cstdlib>
+#include <typeinfo>
+#include "RtMidi.h"
+
+void usage( void ) {
+  std::cout << "\nuseage: sysextest N\n";
+  std::cout << "    where N = length of sysex message to send / receive.\n\n";
+  exit( 0 );
+}
+
+// Platform-dependent sleep routines.
+#if defined(__WINDOWS_MM__)
+  #include <windows.h>
+  #define SLEEP( milliseconds ) Sleep( (DWORD) milliseconds ) 
+#else // Unix variants
+  #include <unistd.h>
+  #define SLEEP( milliseconds ) usleep( (unsigned long) (milliseconds * 1000.0) )
+#endif
+
+// This function should be embedded in a try/catch block in case of
+// an exception.  It offers the user a choice of MIDI ports to open.
+// It returns false if there are no ports available.
+bool chooseMidiPort( RtMidi *rtmidi );
+
+void mycallback( double deltatime, std::vector< unsigned char > *message, void *userData )
+{
+  unsigned int nBytes = message->size();
+  for ( unsigned int i=0; i<nBytes; i++ )
+    std::cout << "Byte " << i << " = " << (int)message->at(i) << ", ";
+  if ( nBytes > 0 )
+    std::cout << "stamp = " << deltatime << std::endl;
+}
+
+int main( int argc, char *argv[] )
+{
+  RtMidiOut *midiout = 0;
+  RtMidiIn *midiin = 0;
+  std::vector<unsigned char> message;
+  unsigned int i, nBytes;
+
+  // Minimal command-line check.
+  if ( argc != 2 ) usage();
+  nBytes = (unsigned int) atoi( argv[1] );
+
+  // RtMidiOut and RtMidiIn constructors
+  try {
+    midiout = new RtMidiOut();
+    midiin = new RtMidiIn();
+  }
+  catch ( RtError &error ) {
+    error.printMessage();
+    goto cleanup;
+  }
+
+  // Don't ignore sysex, timing, or active sensing messages.
+  midiin->ignoreTypes( false, true, true );
+
+  // Call function to select ports
+  try {
+    if ( chooseMidiPort( midiin ) == false ) goto cleanup;
+    if ( chooseMidiPort( midiout ) == false ) goto cleanup;
+  }
+  catch ( RtError &error ) {
+    error.printMessage();
+    goto cleanup;
+  }
+
+  midiin->setCallback( &mycallback );
+
+  message.push_back( 0xF6 );
+  midiout->sendMessage( &message );
+  SLEEP( 500 ); // pause a little
+
+  // Create a long sysex messages of numbered bytes and send it out.
+  for ( int n=0; n<2; n++ ) {
+  message.clear();
+  message.push_back( 240 );
+  for ( i=0; i<nBytes; i++ )
+    message.push_back( i % 128 );
+  message.push_back( 247 );
+  midiout->sendMessage( &message );
+
+  SLEEP( 500 ); // pause a little
+
+}
+
+  // Clean up
+ cleanup:
+  delete midiout;
+  delete midiin;
+
+  return 0;
+}
+
+bool chooseMidiPort( RtMidi *rtmidi )
+{
+  bool isInput = false;
+  if ( typeid( *rtmidi ) == typeid( RtMidiIn ) )
+    isInput = true;
+
+  if ( isInput )
+    std::cout << "\nWould you like to open a virtual input port? [y/N] ";
+  else
+    std::cout << "\nWould you like to open a virtual output port? [y/N] ";
+
+  std::string keyHit;
+  std::getline( std::cin, keyHit );
+  if ( keyHit == "y" ) {
+    rtmidi->openVirtualPort();
+    return true;
+  }
+
+  std::string portName;
+  unsigned int i = 0, nPorts = rtmidi->getPortCount();
+  if ( nPorts == 0 ) {
+    if ( isInput )
+      std::cout << "No input ports available!" << std::endl;
+    else
+      std::cout << "No output ports available!" << std::endl;
+    return false;
+  }
+
+  if ( nPorts == 1 ) {
+    std::cout << "\nOpening " << rtmidi->getPortName() << std::endl;
+  }
+  else {
+    for ( i=0; i<nPorts; i++ ) {
+      portName = rtmidi->getPortName(i);
+      if ( isInput )
+        std::cout << "  Input port #" << i << ": " << portName << '\n';
+      else
+        std::cout << "  Output port #" << i << ": " << portName << '\n';
+    }
+
+    do {
+      std::cout << "\nChoose a port number: ";
+      std::cin >> i;
+    } while ( i >= nPorts );
+  }
+
+  std::cout << std::endl;
+  rtmidi->openPort( i );
+
+  return true;
+}
--- /dev/null
+++ giada-0.7.2/src/rtmidi/tests/qmidiin.cpp
@@ -0,0 +1,98 @@
+//*****************************************//
+//  qmidiin.cpp
+//  by Gary Scavone, 2003-2004.
+//
+//  Simple program to test MIDI input and
+//  retrieval from the queue.
+//
+//*****************************************//
+
+#include <iostream>
+#include <cstdlib>
+#include <signal.h>
+#include "RtMidi.h"
+
+// Platform-dependent sleep routines.
+#if defined(__WINDOWS_MM__)
+  #include <windows.h>
+  #define SLEEP( milliseconds ) Sleep( (DWORD) milliseconds ) 
+#else // Unix variants
+  #include <unistd.h>
+  #define SLEEP( milliseconds ) usleep( (unsigned long) (milliseconds * 1000.0) )
+#endif
+
+bool done;
+static void finish( int ignore ){ done = true; }
+
+void usage( void ) {
+  // Error function in case of incorrect command-line
+  // argument specifications.
+  std::cout << "\nusage: qmidiin <port>\n";
+  std::cout << "    where port = the device to use (default = 0).\n\n";
+  exit( 0 );
+}
+
+int main( int argc, char *argv[] )
+{
+  RtMidiIn *midiin = 0;
+  std::vector<unsigned char> message;
+  int nBytes, i;
+  double stamp;
+
+  // Minimal command-line check.
+  if ( argc > 2 ) usage();
+
+  // RtMidiIn constructor
+  try {
+    midiin = new RtMidiIn();
+  }
+  catch ( RtError &error ) {
+    error.printMessage();
+    exit( EXIT_FAILURE );
+  }
+
+  // Check available ports vs. specified.
+  unsigned int port = 0;
+  unsigned int nPorts = midiin->getPortCount();
+  if ( argc == 2 ) port = (unsigned int) atoi( argv[1] );
+  if ( port >= nPorts ) {
+    delete midiin;
+    std::cout << "Invalid port specifier!\n";
+    usage();
+  }
+
+  try {
+    midiin->openPort( port );
+  }
+  catch ( RtError &error ) {
+    error.printMessage();
+    goto cleanup;
+  }
+
+  // Don't ignore sysex, timing, or active sensing messages.
+  midiin->ignoreTypes( false, false, false );
+
+  // Install an interrupt handler function.
+  done = false;
+  (void) signal(SIGINT, finish);
+
+  // Periodically check input queue.
+  std::cout << "Reading MIDI from port ... quit with Ctrl-C.\n";
+  while ( !done ) {
+    stamp = midiin->getMessage( &message );
+    nBytes = message.size();
+    for ( i=0; i<nBytes; i++ )
+      std::cout << "Byte " << i << " = " << (int)message[i] << ", ";
+    if ( nBytes > 0 )
+      std::cout << "stamp = " << stamp << std::endl;
+
+    // Sleep for 10 milliseconds.
+    SLEEP( 10 );
+  }
+
+  // Clean up
+ cleanup:
+  delete midiin;
+
+  return 0;
+}
--- /dev/null
+++ giada-0.7.2/src/rtmidi/config/config.guess
@@ -0,0 +1,1371 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
+#   Free Software Foundation, Inc.
+
+timestamp='2004-02-26'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Written by Per Bothner <bothner@cygnus.com>.
+# Please send patches to <config-patches@gnu.org>.
+#
+# This script attempts to guess a canonical system name similar to
+# config.sub.  If it succeeds, it prints the system name on stdout, and
+# exits with 0.  Otherwise, it exits with 1.
+#
+# The plan is that this can be called by configure scripts if you
+# don't specify an explicit build system type.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 99, 2000
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit 0 ;;
+    --version | -v )
+       echo "$version" ; exit 0 ;;
+    --help | --h* | -h )
+       echo "$usage"; exit 0 ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+
+dummy=dummy-$$
+trap 'rm -f $dummy.c $dummy.o $dummy.rel $dummy; exit 1' 1 2 15
+
+# CC_FOR_BUILD -- compiler used by this script.
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo "int dummy(){}" > $dummy.c
+	for c in cc gcc c89 ; do
+	  ($c $dummy.c -c -o $dummy.o) >/dev/null 2>&1
+	  if test $? = 0 ; then
+	     CC_FOR_BUILD="$c"; break
+	  fi
+	done
+	rm -f $dummy.c $dummy.o $dummy.rel
+	if test x"$CC_FOR_BUILD" = x ; then
+	  CC_FOR_BUILD=no_compiler_found
+	fi
+	;;
+ ,,*)   CC_FOR_BUILD=$CC ;;
+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+esac
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 8/24/94.)
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    *:NetBSD:*:*)
+	# Netbsd (nbsd) targets should (where applicable) match one or
+	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	# Determine the machine/vendor (is the vendor relevant).
+	case "${UNAME_MACHINE}" in
+	    amiga) machine=m68k-unknown ;;
+	    arm32) machine=arm-unknown ;;
+	    atari*) machine=m68k-atari ;;
+	    sun3*) machine=m68k-sun ;;
+	    mac68k) machine=m68k-apple ;;
+	    macppc) machine=powerpc-apple ;;
+	    hp3[0-9][05]) machine=m68k-hp ;;
+	    ibmrt|romp-ibm) machine=romp-ibm ;;
+	    *) machine=${UNAME_MACHINE}-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently, or will in the future.
+	case "${UNAME_MACHINE}" in
+	    i386|sparc|amiga|arm*|hp300|mvme68k|vax|atari|luna68k|mac68k|news68k|next68k|pc532|sun3*|x68k)
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep __ELF__ >/dev/null
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+	        os=netbsd
+		;;
+	esac
+	# The OS release
+	release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	echo "${machine}-${os}${release}"
+	exit 0 ;;
+    alpha:OSF1:*:*)
+	if test $UNAME_RELEASE = "V4.0"; then
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+	fi
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	cat <<EOF >$dummy.s
+	.data
+\$Lformat:
+	.byte 37,100,45,37,120,10,0	# "%d-%x\n"
+
+	.text
+	.globl main
+	.align 4
+	.ent main
+main:
+	.frame \$30,16,\$26,0
+	ldgp \$29,0(\$27)
+	.prologue 1
+	.long 0x47e03d80 # implver \$0
+	lda \$2,-1
+	.long 0x47e20c21 # amask \$2,\$1
+	lda \$16,\$Lformat
+	mov \$0,\$17
+	not \$1,\$18
+	jsr \$26,printf
+	ldgp \$29,0(\$26)
+	mov 0,\$16
+	jsr \$26,exit
+	.end main
+EOF
+	$CC_FOR_BUILD $dummy.s -o $dummy 2>/dev/null
+	if test "$?" = 0 ; then
+		case `./$dummy` in
+			0-0)
+				UNAME_MACHINE="alpha"
+				;;
+			1-0)
+				UNAME_MACHINE="alphaev5"
+				;;
+			1-1)
+				UNAME_MACHINE="alphaev56"
+				;;
+			1-101)
+				UNAME_MACHINE="alphapca56"
+				;;
+			2-303)
+				UNAME_MACHINE="alphaev6"
+				;;
+			2-307)
+				UNAME_MACHINE="alphaev67"
+				;;
+		esac
+	fi
+	rm -f $dummy.s $dummy
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit 0 ;;
+    Alpha\ *:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# Should we change UNAME_MACHINE based on the output of uname instead
+	# of the specific Alpha model?
+	echo alpha-pc-interix
+	exit 0 ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit 0 ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-unknown-sysv4
+	exit 0;;
+    amiga:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-amigaos
+	exit 0 ;;
+    arc64:OpenBSD:*:*)
+	echo mips64el-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    arc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    hkmips:OpenBSD:*:*)
+	echo mips-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    pmax:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sgi:OpenBSD:*:*)
+	echo mips-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    wgrisc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    *:OS/390:*:*)
+	echo i370-ibm-openedition
+	exit 0 ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit 0;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit 0;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit 0 ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit 0 ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    i86pc:SunOS:5.*:*)
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit 0 ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit 0 ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(head -1 /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	case "`/bin/arch`" in
+	    sun3)
+		echo m68k-sun-sunos${UNAME_RELEASE}
+		;;
+	    sun4)
+		echo sparc-sun-sunos${UNAME_RELEASE}
+		;;
+	esac
+	exit 0 ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit 0 ;;
+    atari*:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit 0 ;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+        exit 0 ;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit 0 ;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+        echo m68k-milan-mint${UNAME_RELEASE}
+        exit 0 ;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+        echo m68k-hades-mint${UNAME_RELEASE}
+        exit 0 ;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+        echo m68k-unknown-mint${UNAME_RELEASE}
+        exit 0 ;;
+    sun3*:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme88k:OpenBSD:*:*)
+	echo m88k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit 0 ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit 0 ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit 0 ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit 0 ;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	echo clipper-intergraph-clix${UNAME_RELEASE}
+	exit 0 ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	sed 's/^	//' << EOF >$dummy.c
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD $dummy.c -o $dummy \
+	  && ./$dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
+	  && rm -f $dummy.c $dummy && exit 0
+	rm -f $dummy.c $dummy
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit 0 ;;
+    Motorola:PowerMAX_OS:*:*)
+	echo powerpc-motorola-powermax
+	exit 0 ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit 0 ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit 0 ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit 0 ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit 0 ;;
+    AViiON:dgux:*:*)
+        # DG/UX returns AViiON for all architectures
+        UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	then
+	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
+	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	    else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	    fi
+	else
+	    echo i586-dg-dgux${UNAME_RELEASE}
+	fi
+ 	exit 0 ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit 0 ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit 0 ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit 0 ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit 0 ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit 0 ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
+	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
+	echo i386-ibm-aix
+	exit 0 ;;
+    ia64:AIX:*:*)
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	exit 0 ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		sed 's/^		//' << EOF >$dummy.c
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm -f $dummy.c $dummy && exit 0
+		rm -f $dummy.c $dummy
+		echo rs6000-ibm-aix3.2.5
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit 0 ;;
+    *:AIX:*:[45])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | head -1 | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit 0 ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit 0 ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit 0 ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit 0 ;;                           # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit 0 ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit 0 ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit 0 ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit 0 ;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+              case "${HPUX_REV}" in
+                11.[0-9][0-9])
+                  if [ -x /usr/bin/getconf ]; then
+                    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+                    case "${sc_cpu_version}" in
+                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+                      532)                      # CPU_PA_RISC2_0
+                        case "${sc_kernel_bits}" in
+                          32) HP_ARCH="hppa2.0n" ;;
+                          64) HP_ARCH="hppa2.0w" ;;
+                        esac ;;
+                    esac
+                  fi ;;
+              esac
+              if [ "${HP_ARCH}" = "" ]; then
+              sed 's/^              //' << EOF >$dummy.c
+
+              #define _HPUX_SOURCE
+              #include <stdlib.h>
+              #include <unistd.h>
+
+              int main ()
+              {
+              #if defined(_SC_KERNEL_BITS)
+                  long bits = sysconf(_SC_KERNEL_BITS);
+              #endif
+                  long cpu  = sysconf (_SC_CPU_VERSION);
+
+                  switch (cpu)
+              	{
+              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+              	case CPU_PA_RISC2_0:
+              #if defined(_SC_KERNEL_BITS)
+              	    switch (bits)
+              		{
+              		case 64: puts ("hppa2.0w"); break;
+              		case 32: puts ("hppa2.0n"); break;
+              		default: puts ("hppa2.0"); break;
+              		} break;
+              #else  /* !defined(_SC_KERNEL_BITS) */
+              	    puts ("hppa2.0"); break;
+              #endif
+              	default: puts ("hppa1.0"); break;
+              	}
+                  exit (0);
+              }
+EOF
+	(CCOPTS= $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null ) && HP_ARCH=`./$dummy`
+	if test -z "$HP_ARCH"; then HP_ARCH=hppa; fi
+	rm -f $dummy.c $dummy
+	fi ;;
+	esac
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit 0 ;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux${HPUX_REV}
+	exit 0 ;;
+    3050*:HI-UX:*:*)
+	sed 's/^	//' << EOF >$dummy.c
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm -f $dummy.c $dummy && exit 0
+	rm -f $dummy.c $dummy
+	echo unknown-hitachi-hiuxwe2
+	exit 0 ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit 0 ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit 0 ;;
+    *9??*:MPE/iX:*:*)
+	echo hppa1.0-hp-mpeix
+	exit 0 ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit 0 ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit 0 ;;
+    i*86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit 0 ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit 0 ;;
+    hppa*:OpenBSD:*:*)
+	echo hppa-unknown-openbsd
+	exit 0 ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+        exit 0 ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+        exit 0 ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+        exit 0 ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+        exit 0 ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+        exit 0 ;;
+    CRAY*X-MP:*:*:*)
+	echo xmp-cray-unicos
+        exit 0 ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE}
+	exit 0 ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/
+	exit 0 ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit 0 ;;
+    CRAY*T3D:*:*:*)
+	echo alpha-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit 0 ;;
+    CRAY*T3E:*:*:*)
+	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit 0 ;;
+    CRAY*SV1:*:*:*)
+	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit 0 ;;
+    CRAY-2:*:*:*)
+	echo cray2-cray-unicos
+        exit 0 ;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+        exit 0 ;;
+    hp300:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    *:FreeBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit 0 ;;
+    *:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    i*:CYGWIN*:*)
+	echo ${UNAME_MACHINE}-pc-cygwin
+	exit 0 ;;
+    i*:MINGW*:*)
+	echo ${UNAME_MACHINE}-pc-mingw32
+	exit 0 ;;
+    i*:PW*:*)
+	echo ${UNAME_MACHINE}-pc-pw32
+	exit 0 ;;
+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+	# UNAME_MACHINE based on the output of uname instead of i386?
+	echo i386-pc-interix
+	exit 0 ;;
+    i*:UWIN*:*)
+	echo ${UNAME_MACHINE}-pc-uwin
+	exit 0 ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin
+	exit 0 ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    *:GNU:*:*)
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit 0 ;;
+    i*86:Minix:*:*)
+	echo ${UNAME_MACHINE}-pc-minix
+	exit 0 ;;
+    arm*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
+    ia64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux
+	exit 0 ;;
+    m68*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
+    mips:Linux:*:*)
+	cat >$dummy.c <<EOF
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+int main (int argc, char *argv[]) {
+#else
+int main (argc, argv) int argc; char *argv[]; {
+#endif
+#ifdef __MIPSEB__
+  printf ("%s-unknown-linux-gnu\n", argv[1]);
+#endif
+#ifdef __MIPSEL__
+  printf ("%sel-unknown-linux-gnu\n", argv[1]);
+#endif
+  return 0;
+}
+EOF
+	$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm -f $dummy.c $dummy && exit 0
+	rm -f $dummy.c $dummy
+	;;
+    ppc:Linux:*:*)
+	# Determine Lib Version
+	cat >$dummy.c <<EOF
+#include <features.h>
+#if defined(__GLIBC__)
+extern char __libc_version[];
+extern char __libc_release[];
+#endif
+main(argc, argv)
+     int argc;
+     char *argv[];
+{
+#if defined(__GLIBC__)
+  printf("%s %s\n", __libc_version, __libc_release);
+#else
+  printf("unknown\n");
+#endif
+  return 0;
+}
+EOF
+	LIBC=""
+	$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null
+	if test "$?" = 0 ; then
+		./$dummy | grep 1\.99 > /dev/null
+		if test "$?" = 0 ; then LIBC="libc1" ; fi
+	fi
+	rm -f $dummy.c $dummy
+	echo powerpc-unknown-linux-gnu${LIBC}
+	exit 0 ;;
+    alpha:Linux:*:*)
+	cat <<EOF >$dummy.s
+	  .data
+	  \$Lformat:
+		.byte 37,100,45,37,120,10,0	# "%d-%x\n"
+	   .text
+		.globl main
+		.align 4
+		.ent main
+	    main:
+		.frame \$30,16,\$26,0
+		ldgp \$29,0(\$27)
+		.prologue 1
+		.long 0x47e03d80 # implver \$0
+		lda \$2,-1
+		.long 0x47e20c21 # amask \$2,\$1
+		lda \$16,\$Lformat
+		mov \$0,\$17
+		not \$1,\$18
+		jsr \$26,printf
+		ldgp \$29,0(\$26)
+		mov 0,\$16
+		jsr \$26,exit
+		.end main
+EOF
+	LIBC=""
+	$CC_FOR_BUILD $dummy.s -o $dummy 2>/dev/null
+	if test "$?" = 0 ; then
+		case `./$dummy` in
+		0-0)	UNAME_MACHINE="alpha" ;;
+		1-0)	UNAME_MACHINE="alphaev5" ;;
+		1-1)    UNAME_MACHINE="alphaev56" ;;
+		1-101)	UNAME_MACHINE="alphapca56" ;;
+		2-303)	UNAME_MACHINE="alphaev6" ;;
+		2-307)	UNAME_MACHINE="alphaev67" ;;
+		esac
+		objdump --private-headers $dummy | \
+		  grep ld.so.1 > /dev/null
+		if test "$?" = 0 ; then
+			LIBC="libc1"
+		fi
+	fi
+	rm -f $dummy.s $dummy
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit 0 ;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
+	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
+	  *)    echo hppa-unknown-linux-gnu ;;
+	esac
+	exit 0 ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-gnu
+	exit 0 ;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	echo ${UNAME_MACHINE}-ibm-linux
+	exit 0 ;;
+    sh*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
+    x86_64:Linux:*:*)
+	echo x86_64-unknown-linux-gnu
+	exit 0 ;;
+    i*86:Linux:*:*)
+	# The BFD linker knows what the default object file format is, so
+	# first see if it will tell us. cd to the root directory to prevent
+	# problems with other programs or directories called `ld' in the path.
+	ld_supported_emulations=`cd /; ld --help 2>&1 \
+			 | sed -ne '/supported emulations:/!d
+				    s/[ 	][ 	]*/ /g
+				    s/.*supported emulations: *//
+				    s/ .*//
+				    p'`
+        case "$ld_supported_emulations" in
+	  i*86linux)
+		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
+		exit 0
+		;;
+	  elf_i*86)
+		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
+		;;
+	  i*86coff)
+		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
+		exit 0
+		;;
+	esac
+	# Either a pre-BFD a.out linker (linux-gnuoldld)
+	# or one that does not give us useful --help.
+	# GCC wants to distinguish between linux-gnuoldld and linux-gnuaout.
+	# If ld does not provide *any* "supported emulations:"
+	# that means it is gnuoldld.
+	test -z "$ld_supported_emulations" && echo "${UNAME_MACHINE}-pc-linux-gnuoldld" && exit 0
+	case "${UNAME_MACHINE}" in
+	i*86)
+	  VENDOR=pc;
+	  ;;
+	*)
+	  VENDOR=unknown;
+	  ;;
+	esac
+	# Determine whether the default compiler is a.out or elf
+	cat >$dummy.c <<EOF
+#include <features.h>
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+#ifdef __ELF__
+# ifdef __GLIBC__
+#  if __GLIBC__ >= 2
+    printf ("%s-${VENDOR}-linux-gnu\n", argv[1]);
+#  else
+    printf ("%s-${VENDOR}-linux-gnulibc1\n", argv[1]);
+#  endif
+# else
+   printf ("%s-${VENDOR}-linux-gnulibc1\n", argv[1]);
+# endif
+#else
+  printf ("%s-${VENDOR}-linux-gnuaout\n", argv[1]);
+#endif
+  return 0;
+}
+EOF
+	$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm -f $dummy.c $dummy && exit 0
+	rm -f $dummy.c $dummy
+	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
+	;;
+# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions
+# are messed up and put the nodename in both sysname and nodename.
+    i*86:DYNIX/ptx:4*:*)
+	echo i386-sequent-sysv4
+	exit 0 ;;
+    i*86:UNIX_SV:4.2MP:2.*)
+        # Unixware is an offshoot of SVR4, but it has its own version
+        # number series starting with 2...
+        # I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+        # Use sysv4.2uw... so that sysv4* matches it.
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	exit 0 ;;
+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+	fi
+	exit 0 ;;
+    i*86:*:5:7*)
+        # Fixed at (any) Pentium or better
+        UNAME_MACHINE=i586
+        if [ ${UNAME_SYSTEM} = "UnixWare" ] ; then
+	    echo ${UNAME_MACHINE}-sco-sysv${UNAME_RELEASE}uw${UNAME_VERSION}
+	else
+	    echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}
+	fi
+	exit 0 ;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		(/bin/uname -X|egrep '^Machine.*Pent ?II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|egrep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit 0 ;;
+    i*86:*DOS:*:*)
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	exit 0 ;;
+    pc:*:*:*)
+	# Left here for compatibility:
+        # uname -m prints for DJGPP always 'pc', but it prints nothing about
+        # the processor, so we play safe by assuming i386.
+	echo i386-pc-msdosdjgpp
+        exit 0 ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit 0 ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit 0 ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit 0 ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit 0 ;;
+    M68*:*:R3V[567]*:*)
+	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
+    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+          && echo i486-ncr-sysv4 && exit 0 ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit 0 ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    rs6000:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit 0 ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit 0 ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit 0 ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit 0 ;;
+    PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                           # says <Richard.M.Bartel@ccMail.Census.GOV>
+        echo i586-unisys-sysv4
+        exit 0 ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit 0 ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit 0 ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit 0 ;;
+    news*:NEWS-OS:6*:*)
+	echo mips-sony-newsos6
+	exit 0 ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if [ -d /usr/nec ]; then
+	        echo mips-nec-sysv${UNAME_RELEASE}
+	else
+	        echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+        exit 0 ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit 0 ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit 0 ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit 0 ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux${UNAME_RELEASE}
+	exit 0 ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux${UNAME_RELEASE}
+	exit 0 ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	exit 0 ;;
+    *:Rhapsody:*:*)
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	exit 0 ;;
+    *:Darwin:*:*)
+	echo `uname -p`-apple-darwin${UNAME_RELEASE}
+	exit 0 ;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	if test "${UNAME_MACHINE}" = "x86pc"; then
+		UNAME_MACHINE=pc
+	fi
+	echo `uname -p`-${UNAME_MACHINE}-nto-qnx
+	exit 0 ;;
+    *:QNX:*:4*)
+	echo i386-pc-qnx
+	exit 0 ;;
+    NSR-[KW]:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk${UNAME_RELEASE}
+	exit 0 ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit 0 ;;
+    BS2000:POSIX*:*:*)
+	echo bs2000-siemens-sysv
+	exit 0 ;;
+    DS/*:UNIX_System_V:*:*)
+	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	exit 0 ;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test "$cputype" = "386"; then
+	    UNAME_MACHINE=i386
+	else
+	    UNAME_MACHINE="$cputype"
+	fi
+	echo ${UNAME_MACHINE}-unknown-plan9
+	exit 0 ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo ${UNAME_MACHINE}-pc-os2-emx
+	exit 0 ;;
+    *:TOPS-10:*:*)
+	echo pdp10-unknown-tops10
+	exit 0 ;;
+    *:TENEX:*:*)
+	echo pdp10-unknown-tenex
+	exit 0 ;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	echo pdp10-dec-tops20
+	exit 0 ;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	echo pdp10-xkl-tops20
+	exit 0 ;;
+    *:TOPS-20:*:*)
+	echo pdp10-unknown-tops20
+	exit 0 ;;
+    *:ITS:*:*)
+	echo pdp10-unknown-its
+	exit 0 ;;
+esac
+
+#echo '(No uname command or uname output not recognized.)' 1>&2
+#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
+
+cat >$dummy.c <<EOF
+#ifdef _SEQUENT_
+# include <sys/types.h>
+# include <sys/utsname.h>
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+          "4"
+#else
+	  ""
+#endif
+         ); exit (0);
+#endif
+#endif
+
+#if defined (__arm) && defined (__acorn) && defined (__unix)
+  printf ("arm-acorn-riscix"); exit (0);
+#endif
+
+#if defined (hp300) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+    struct utsname un;
+
+    uname(&un);
+
+    if (strncmp(un.version, "V2", 2) == 0) {
+	printf ("i386-sequent-ptx2\n"); exit (0);
+    }
+    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+	printf ("i386-sequent-ptx1\n"); exit (0);
+    }
+    printf ("i386-sequent-ptx\n"); exit (0);
+
+#endif
+
+#if defined (vax)
+# if !defined (ultrix)
+#  include <sys/param.h>
+#  if defined (BSD)
+#   if BSD == 43
+      printf ("vax-dec-bsd4.3\n"); exit (0);
+#   else
+#    if BSD == 199006
+      printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#    else
+      printf ("vax-dec-bsd\n"); exit (0);
+#    endif
+#   endif
+#  else
+    printf ("vax-dec-bsd\n"); exit (0);
+#  endif
+# else
+    printf ("vax-dec-ultrix\n"); exit (0);
+# endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy && rm -f $dummy.c $dummy && exit 0
+rm -f $dummy.c $dummy
+
+# Apollos put the system type in the environment.
+
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
+
+# Convex versions that predate uname can use getsysinfo(1)
+
+if [ -x /usr/convex/getsysinfo ]
+then
+    case `getsysinfo -f cpu_type` in
+    c1*)
+	echo c1-convex-bsd
+	exit 0 ;;
+    c2*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit 0 ;;
+    c34*)
+	echo c34-convex-bsd
+	exit 0 ;;
+    c38*)
+	echo c38-convex-bsd
+	exit 0 ;;
+    c4*)
+	echo c4-convex-bsd
+	exit 0 ;;
+    esac
+fi
+
+cat >&2 <<EOF
+$0: unable to guess system type
+
+This script, last modified $timestamp, has failed to recognize
+the operating system you are using. It is advised that you
+download the most up to date version of the config scripts from
+
+    ftp://ftp.gnu.org/pub/gnu/config/
+
+If the version you run ($0) is already up to date, please
+send the following data and any information you think might be
+pertinent to <config-patches@gnu.org> in order to provide the needed
+information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = ${UNAME_MACHINE}
+UNAME_RELEASE = ${UNAME_RELEASE}
+UNAME_SYSTEM  = ${UNAME_SYSTEM}
+UNAME_VERSION = ${UNAME_VERSION}
+EOF
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
--- /dev/null
+++ giada-0.7.2/src/rtmidi/config/config.sub
@@ -0,0 +1,1366 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
+#   Free Software Foundation, Inc.
+
+timestamp='2004-02-26'
+
+# This file is (in principle) common to ALL GNU software.
+# The presence of a machine in this file suggests that SOME GNU software
+# can handle that machine.  It does not imply ALL GNU software can.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Please send patches to <config-patches@gnu.org>.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS
+       $0 [OPTION] ALIAS
+
+Canonicalize a configuration name.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit 0 ;;
+    --version | -v )
+       echo "$version" ; exit 0 ;;
+    --help | --h* | -h )
+       echo "$usage"; exit 0 ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help"
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo $1
+       exit 0;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  nto-qnx* | linux-gnu* | storm-chaos* | os2-emx*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple | -axis)
+		os=
+		basic_machine=$1
+		;;
+	-sim | -cisco | -oki | -wec | -winbond)
+		os=
+		basic_machine=$1
+		;;
+	-scout)
+		;;
+	-wrs)
+		os=-vxworks
+		basic_machine=$1
+		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco5)
+		os=-sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-udk*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+	-mint | -mint[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	tahoe | i860 | ia64 | m32r | m68k | m68000 | m88k | ns32k | arc \
+	        | arm | arme[lb] | arm[bl]e | armv[2345] | armv[345][lb] | strongarm | xscale \
+		| pyramid | mn10200 | mn10300 | tron | a29k \
+		| 580 | i960 | h8300 \
+		| x86 | ppcbe | mipsbe | mipsle | shbe | shle \
+		| hppa | hppa1.0 | hppa1.1 | hppa2.0 | hppa2.0w | hppa2.0n \
+		| hppa64 \
+		| alpha | alphaev[4-8] | alphaev56 | alphapca5[67] \
+		| alphaev6[78] \
+		| we32k | ns16k | clipper | i370 | sh | sh[34] \
+		| powerpc | powerpc64 | powerpcle \
+		| 1750a | dsp16xx | pdp10 | pdp11 \
+		| mips16 | mips64 | mipsel | mips64el \
+		| mips64orion | mips64orionel | mipstx39 | mipstx39el \
+		| mips64vr4300 | mips64vr4300el | mips64vr4100 | mips64vr4100el \
+		| mips64vr5000 | miprs64vr5000el | mcore | s390 | s390x \
+		| sparc | sparclet | sparclite | sparc64 | sparcv9 | sparcv9b \
+		| v850 | c4x \
+		| thumb | d10v | d30v | fr30 | avr | openrisc | tic80 \
+		| pj | pjl | h8500)
+		basic_machine=$basic_machine-unknown
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12)
+		# Motorola 68HC11/12.
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | z8k | v70 | w65)
+		;;
+
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	# FIXME: clean up the formatting here.
+	vax-* | tahoe-* | i*86-* | i860-* | ia64-* | m32r-* | m68k-* | m68000-* \
+	      | m88k-* | sparc-* | ns32k-* | fx80-* | arc-* | c[123]* \
+	      | arm-*  | armbe-* | armle-* | armv*-* | strongarm-* | xscale-* \
+	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \
+	      | power-* | none-* | 580-* | cray2-* | h8300-* | h8500-* | i960-* \
+	      | xmp-* | ymp-* \
+	      | x86-* | ppcbe-* | mipsbe-* | mipsle-* | shbe-* | shle-* \
+	      | hppa-* | hppa1.0-* | hppa1.1-* | hppa2.0-* | hppa2.0w-* \
+	      | hppa2.0n-* | hppa64-* \
+	      | alpha-* | alphaev[4-8]-* | alphaev56-* | alphapca5[67]-* \
+	      | alphaev6[78]-* \
+	      | we32k-* | cydra-* | ns16k-* | pn-* | np1-* | xps100-* \
+	      | clipper-* | orion-* \
+	      | sparclite-* | pdp10-* | pdp11-* | sh-* | powerpc-* | powerpc64-* | powerpcle-* \
+	      | sparc64-* | sparcv9-* | sparcv9b-* | sparc86x-* \
+	      | mips16-* | mips64-* | mipsel-* \
+	      | mips64el-* | mips64orion-* | mips64orionel-* \
+	      | mips64vr4100-* | mips64vr4100el-* | mips64vr4300-* | mips64vr4300el-* \
+	      | mipstx39-* | mipstx39el-* | mcore-* \
+	      | f30[01]-* | f700-* | s390-* | s390x-* | sv1-* | t3e-* \
+	      | [cjt]90-* \
+	      | m88110-* | m680[01234]0-* | m683?2-* | m68360-* | z8k-* | d10v-* \
+	      | thumb-* | v850-* | d30v-* | tic30-* | tic80-* | c30-* | fr30-* \
+	      | bs2000-* | tic54x-* | c54x-* | x86_64-* | pj-* | pjl-*)
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	386bsd)
+		basic_machine=i386-unknown
+		os=-bsd
+		;;
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	a29khif)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	adobe68k)
+		basic_machine=m68010-adobe
+		os=-scout
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-unknown
+		;;
+	amigaos | amigados)
+		basic_machine=m68k-unknown
+		os=-amigaos
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-unknown
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	apollo68bsd)
+		basic_machine=m68k-apollo
+		os=-bsd
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	cray2)
+		basic_machine=cray2-cray
+		os=-unicos
+		;;
+	[cjt]90)
+		basic_machine=${basic_machine}-cray
+		os=-unicos
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	cris | cris-* | etrax*)
+		basic_machine=cris-axis
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	es1800 | OSE68k | ose68k | ose | OSE)
+		basic_machine=m68k-ericsson
+		os=-ose
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	go32)
+		basic_machine=i386-pc
+		os=-go32
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	h8300xray)
+		basic_machine=h8300-hitachi
+		os=-xray
+		;;
+	h8500hms)
+		basic_machine=h8500-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	hppaosf)
+		basic_machine=hppa1.1-hp
+		os=-osf
+		;;
+	hppro)
+		basic_machine=hppa1.1-hp
+		os=-proelf
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		;;
+# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
+	i*86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i*86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i*86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i*86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	i386mach)
+		basic_machine=i386-mach
+		os=-mach
+		;;
+	i386-vsta | vsta)
+		basic_machine=i386-unknown
+		os=-vsta
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	mingw32)
+		basic_machine=i386-pc
+		os=-mingw32
+		;;
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+	mipsel*-linux*)
+		basic_machine=mipsel-unknown
+		os=-linux-gnu
+		;;
+	mips*-linux*)
+		basic_machine=mips-unknown
+		os=-linux-gnu
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	mmix*)
+		basic_machine=mmix-knuth
+		os=-mmixware
+		;;
+	monitor)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	msdos)
+		basic_machine=i386-pc
+		os=-msdos
+		;;
+	mvs)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	netbsd386)
+		basic_machine=i386-unknown
+		os=-netbsd
+		;;
+	netwinder)
+		basic_machine=armv4l-rebel
+		os=-linux
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	necv70)
+		basic_machine=v70-nec
+		os=-sysv
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	mon960)
+		basic_machine=i960-intel
+		os=-mon960
+		;;
+	nonstopux)
+		basic_machine=mips-compaq
+		os=-nonstopux
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	nsr-tandem)
+		basic_machine=nsr-tandem
+		;;
+	op50n-* | op60c-*)
+		basic_machine=hppa1.1-oki
+		os=-proelf
+		;;
+	OSE68000 | ose68000)
+		basic_machine=m68000-ericsson
+		os=-ose
+		;;
+	os68k)
+		basic_machine=m68k-none
+		os=-os68k
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+        pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pentium | p5 | k5 | k6 | nexgen)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | 6x86 | athlon)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2)
+		basic_machine=i686-pc
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=power-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+	        ;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64)	basic_machine=powerpc64-unknown
+		;;
+	ppc64-*)	basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+	        ;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	pw32)
+		basic_machine=i586-unknown
+		os=-pw32
+		;;
+	rom68k)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	sa29200)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sparclite-wrs)
+		basic_machine=sparclite-wrs
+		os=-vxworks
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	st2000)
+		basic_machine=m68k-tandem
+		;;
+	stratus)
+		basic_machine=i860-stratus
+		os=-sysv4
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	sv1)
+		basic_machine=sv1-cray
+		os=-unicos
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	t3e)
+		basic_machine=t3e-cray
+		os=-unicos
+		;;
+	tic54x | c54x*)
+		basic_machine=tic54x-unknown
+		os=-coff
+		;;
+	tx39)
+		basic_machine=mipstx39-unknown
+		;;
+	tx39el)
+		basic_machine=mipstx39el-unknown
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	v810 | necv810)
+		basic_machine=v810-nec
+		os=-none
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+	vpp*|vx|vx-*)
+               basic_machine=f301-fujitsu
+               ;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	w65*)
+		basic_machine=w65-wdc
+		os=-none
+		;;
+	w89k-*)
+		basic_machine=hppa1.1-winbond
+		os=-proelf
+		;;
+	xmp)
+		basic_machine=xmp-cray
+		os=-unicos
+		;;
+        xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	z8k-*-coff)
+		basic_machine=z8k-unknown
+		os=-sim
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		basic_machine=hppa1.1-winbond
+		;;
+	op50n)
+		basic_machine=hppa1.1-oki
+		;;
+	op60c)
+		basic_machine=hppa1.1-oki
+		;;
+	mips)
+		if [ x$os = x-linux-gnu ]; then
+			basic_machine=mips-unknown
+		else
+			basic_machine=mips-mips
+		fi
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp10)
+		# there are many clones, so DEC is not a safe bet
+		basic_machine=pdp10-unknown
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sh3 | sh4)
+		basic_machine=sh-unknown
+		;;
+	sparc | sparcv9 | sparcv9b)
+		basic_machine=sparc-sun
+		;;
+        cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	mac | mpw | mac-mpw)
+		basic_machine=m68k-apple
+		;;
+	pmac | pmac-mpw)
+		basic_machine=powerpc-apple
+		;;
+	c4x*)
+		basic_machine=c4x-none
+		os=-coff
+		;;
+	*-unknown)
+		# Make sure to match an already-canonicalized machine name.
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x"$os" != x"" ]
+then
+case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-svr4*)
+		os=-sysv4
+		;;
+	-unixware*)
+		os=-sysv4.2uw
+		;;
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
+	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -interix* | -uwin* | -rhapsody* | -darwin* | -opened* \
+	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* | -os2*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-qnx*)
+		case $basic_machine in
+		    x86-* | i*86-*)
+			;;
+		    *)
+			os=-nto$os
+			;;
+		esac
+		;;
+	-nto*)
+		os=-nto-qnx
+		;;
+	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
+	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+		;;
+	-mac*)
+		os=`echo $os | sed -e 's|mac|macos|'`
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-opened*)
+		os=-openedition
+		;;
+	-wince*)
+		os=-wince
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-386bsd)
+		os=-bsd
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-ns2 )
+	        os=-nextstep2
+		;;
+	-nsk*)
+		os=-nsk
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-ose*)
+		os=-ose
+		;;
+	-es1800*)
+		os=-ose
+		;;
+	-xenix)
+		os=-xenix
+		;;
+        -*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+	        os=-mint
+		;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-rebel)
+		os=-linux
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+	pdp10-*)
+		os=-tops20
+		;;
+        pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		# This also exists in the configure program, but was not the
+		# default.
+		# os=-sunos4
+		;;
+	m68*-cisco)
+		os=-aout
+		;;
+	mips*-cisco)
+		os=-elf
+		;;
+	mips*-*)
+		os=-elf
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-be)
+		os=-beos
+		;;
+	*-ibm)
+		os=-aix
+		;;
+	*-wec)
+		os=-proelf
+		;;
+	*-winbond)
+		os=-proelf
+		;;
+	*-oki)
+		os=-proelf
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigaos
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+        *-gould)
+		os=-sysv
+		;;
+        *-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+        *-sgi)
+		os=-irix
+		;;
+        *-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=-uxpv
+		;;
+	*-rom68k)
+		os=-coff
+		;;
+	*-*bug)
+		os=-coff
+		;;
+	*-apple)
+		os=-macos
+		;;
+	*-atari*)
+		os=-mint
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-aix*)
+				vendor=ibm
+				;;
+			-beos*)
+				vendor=be
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-mpeix*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs* | -opened*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-vxsim* | -vxworks*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+			-hms*)
+				vendor=hitachi
+				;;
+			-mpw* | -macos*)
+				vendor=apple
+				;;
+			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+				vendor=atari
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
+		;;
+esac
+
+echo $basic_machine$os
+exit 0
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
--- /dev/null
+++ giada-0.7.2/src/rtmidi/config/install.sh
@@ -0,0 +1 @@
+#
